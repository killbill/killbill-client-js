/* tslint:disable */
/* eslint-disable */
/**
 * Kill Bill
 * Kill Bill is an open-source billing and payments platform
 *
 * The version of the OpenAPI document: 0.24.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Account
 */
export interface Account {
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'accountId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof Account
     */
    'firstNameLength'?: number;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'externalKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'email'?: string;
    /**
     * 
     * @type {number}
     * @memberof Account
     */
    'billCycleDayLocal'?: number;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'currency'?: AccountCurrencyEnum;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'parentAccountId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Account
     */
    'isPaymentDelegatedToParent'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'paymentMethodId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'referenceTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'timeZone'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'address1'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'address2'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'postalCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'company'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'country'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'locale'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'phone'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'notes'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Account
     */
    'isMigrated'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Account
     */
    'accountBalance'?: number;
    /**
     * 
     * @type {number}
     * @memberof Account
     */
    'accountCBA'?: number;
    /**
     * 
     * @type {Array<AuditLog>}
     * @memberof Account
     */
    'auditLogs'?: Array<AuditLog>;
}

export const AccountCurrencyEnum = {
    Aed: 'AED',
    Afn: 'AFN',
    All: 'ALL',
    Amd: 'AMD',
    Ang: 'ANG',
    Aoa: 'AOA',
    Ars: 'ARS',
    Aud: 'AUD',
    Awg: 'AWG',
    Azn: 'AZN',
    Bam: 'BAM',
    Bbd: 'BBD',
    Bdt: 'BDT',
    Bgn: 'BGN',
    Bhd: 'BHD',
    Bif: 'BIF',
    Bmd: 'BMD',
    Bnd: 'BND',
    Bob: 'BOB',
    Brl: 'BRL',
    Bsd: 'BSD',
    Btn: 'BTN',
    Bwp: 'BWP',
    Byr: 'BYR',
    Bzd: 'BZD',
    Cad: 'CAD',
    Cdf: 'CDF',
    Chf: 'CHF',
    Clp: 'CLP',
    Cny: 'CNY',
    Cop: 'COP',
    Crc: 'CRC',
    Cuc: 'CUC',
    Cup: 'CUP',
    Cve: 'CVE',
    Czk: 'CZK',
    Djf: 'DJF',
    Dkk: 'DKK',
    Dop: 'DOP',
    Dzd: 'DZD',
    Egp: 'EGP',
    Ern: 'ERN',
    Etb: 'ETB',
    Eur: 'EUR',
    Fjd: 'FJD',
    Fkp: 'FKP',
    Gbp: 'GBP',
    Gel: 'GEL',
    Ggp: 'GGP',
    Ghs: 'GHS',
    Gip: 'GIP',
    Gmd: 'GMD',
    Gnf: 'GNF',
    Gtq: 'GTQ',
    Gyd: 'GYD',
    Hkd: 'HKD',
    Hnl: 'HNL',
    Hrk: 'HRK',
    Htg: 'HTG',
    Huf: 'HUF',
    Idr: 'IDR',
    Ils: 'ILS',
    Imp: 'IMP',
    Inr: 'INR',
    Iqd: 'IQD',
    Irr: 'IRR',
    Isk: 'ISK',
    Jep: 'JEP',
    Jmd: 'JMD',
    Jod: 'JOD',
    Jpy: 'JPY',
    Kes: 'KES',
    Kgs: 'KGS',
    Khr: 'KHR',
    Kmf: 'KMF',
    Kpw: 'KPW',
    Krw: 'KRW',
    Kwd: 'KWD',
    Kyd: 'KYD',
    Kzt: 'KZT',
    Lak: 'LAK',
    Lbp: 'LBP',
    Lkr: 'LKR',
    Lrd: 'LRD',
    Lsl: 'LSL',
    Ltl: 'LTL',
    Lvl: 'LVL',
    Lyd: 'LYD',
    Mad: 'MAD',
    Mdl: 'MDL',
    Mga: 'MGA',
    Mkd: 'MKD',
    Mmk: 'MMK',
    Mnt: 'MNT',
    Mop: 'MOP',
    Mro: 'MRO',
    Mur: 'MUR',
    Mvr: 'MVR',
    Mwk: 'MWK',
    Mxn: 'MXN',
    Myr: 'MYR',
    Mzn: 'MZN',
    Nad: 'NAD',
    Ngn: 'NGN',
    Nio: 'NIO',
    Nok: 'NOK',
    Npr: 'NPR',
    Nzd: 'NZD',
    Omr: 'OMR',
    Pab: 'PAB',
    Pen: 'PEN',
    Pgk: 'PGK',
    Php: 'PHP',
    Pkr: 'PKR',
    Pln: 'PLN',
    Pyg: 'PYG',
    Qar: 'QAR',
    Ron: 'RON',
    Rsd: 'RSD',
    Rub: 'RUB',
    Rwf: 'RWF',
    Sar: 'SAR',
    Sbd: 'SBD',
    Scr: 'SCR',
    Sdg: 'SDG',
    Sek: 'SEK',
    Sgd: 'SGD',
    Shp: 'SHP',
    Sll: 'SLL',
    Sos: 'SOS',
    Spl: 'SPL',
    Srd: 'SRD',
    Std: 'STD',
    Svc: 'SVC',
    Syp: 'SYP',
    Szl: 'SZL',
    Thb: 'THB',
    Tjs: 'TJS',
    Tmt: 'TMT',
    Tnd: 'TND',
    Top: 'TOP',
    Try: 'TRY',
    Ttd: 'TTD',
    Tvd: 'TVD',
    Twd: 'TWD',
    Tzs: 'TZS',
    Uah: 'UAH',
    Ugx: 'UGX',
    Usd: 'USD',
    Uyu: 'UYU',
    Uzs: 'UZS',
    Vef: 'VEF',
    Vnd: 'VND',
    Vuv: 'VUV',
    Wst: 'WST',
    Xaf: 'XAF',
    Xcd: 'XCD',
    Xdr: 'XDR',
    Xof: 'XOF',
    Xpf: 'XPF',
    Yer: 'YER',
    Zar: 'ZAR',
    Zmw: 'ZMW',
    Zwd: 'ZWD',
    Btc: 'BTC'
} as const;

export type AccountCurrencyEnum = typeof AccountCurrencyEnum[keyof typeof AccountCurrencyEnum];

/**
 * 
 * @export
 * @interface AccountEmail
 */
export interface AccountEmail {
    /**
     * 
     * @type {string}
     * @memberof AccountEmail
     */
    'accountId'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountEmail
     */
    'email': string;
    /**
     * 
     * @type {Array<AuditLog>}
     * @memberof AccountEmail
     */
    'auditLogs'?: Array<AuditLog>;
}
/**
 * 
 * @export
 * @interface AccountTimeline
 */
export interface AccountTimeline {
    /**
     * 
     * @type {Account}
     * @memberof AccountTimeline
     */
    'account'?: Account;
    /**
     * 
     * @type {Array<Bundle>}
     * @memberof AccountTimeline
     */
    'bundles'?: Array<Bundle>;
    /**
     * 
     * @type {Array<Invoice>}
     * @memberof AccountTimeline
     */
    'invoices'?: Array<Invoice>;
    /**
     * 
     * @type {Array<InvoicePayment>}
     * @memberof AccountTimeline
     */
    'payments'?: Array<InvoicePayment>;
}
/**
 * 
 * @export
 * @interface AdminPayment
 */
export interface AdminPayment {
    /**
     * 
     * @type {string}
     * @memberof AdminPayment
     */
    'lastSuccessPaymentState'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminPayment
     */
    'currentPaymentStateName'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminPayment
     */
    'transactionStatus'?: string;
}
/**
 * 
 * @export
 * @interface AuditLog
 */
export interface AuditLog {
    /**
     * 
     * @type {string}
     * @memberof AuditLog
     */
    'changeType'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuditLog
     */
    'changeDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuditLog
     */
    'objectType'?: AuditLogObjectTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof AuditLog
     */
    'objectId'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuditLog
     */
    'changedBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuditLog
     */
    'reasonCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuditLog
     */
    'comments'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuditLog
     */
    'userToken'?: string;
    /**
     * 
     * @type {Entity}
     * @memberof AuditLog
     */
    'history'?: Entity;
}

export const AuditLogObjectTypeEnum = {
    Account: 'ACCOUNT',
    AccountEmail: 'ACCOUNT_EMAIL',
    BlockingStates: 'BLOCKING_STATES',
    Bundle: 'BUNDLE',
    CustomField: 'CUSTOM_FIELD',
    Invoice: 'INVOICE',
    Payment: 'PAYMENT',
    Transaction: 'TRANSACTION',
    InvoiceItem: 'INVOICE_ITEM',
    InvoicePayment: 'INVOICE_PAYMENT',
    Subscription: 'SUBSCRIPTION',
    SubscriptionEvent: 'SUBSCRIPTION_EVENT',
    ServiceBroadcast: 'SERVICE_BROADCAST',
    PaymentAttempt: 'PAYMENT_ATTEMPT',
    PaymentMethod: 'PAYMENT_METHOD',
    Tag: 'TAG',
    TagDefinition: 'TAG_DEFINITION',
    Tenant: 'TENANT',
    TenantKvs: 'TENANT_KVS'
} as const;

export type AuditLogObjectTypeEnum = typeof AuditLogObjectTypeEnum[keyof typeof AuditLogObjectTypeEnum];

/**
 * 
 * @export
 * @interface BlockPrice
 */
export interface BlockPrice {
    /**
     * 
     * @type {string}
     * @memberof BlockPrice
     */
    'unitName'?: string;
    /**
     * 
     * @type {number}
     * @memberof BlockPrice
     */
    'size'?: number;
    /**
     * 
     * @type {number}
     * @memberof BlockPrice
     */
    'price'?: number;
    /**
     * 
     * @type {number}
     * @memberof BlockPrice
     */
    'max'?: number;
}
/**
 * 
 * @export
 * @interface BlockingState
 */
export interface BlockingState {
    /**
     * 
     * @type {string}
     * @memberof BlockingState
     */
    'blockedId'?: string;
    /**
     * 
     * @type {string}
     * @memberof BlockingState
     */
    'stateName'?: string;
    /**
     * 
     * @type {string}
     * @memberof BlockingState
     */
    'service'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BlockingState
     */
    'isBlockChange'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BlockingState
     */
    'isBlockEntitlement'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BlockingState
     */
    'isBlockBilling'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof BlockingState
     */
    'effectiveDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof BlockingState
     */
    'type'?: BlockingStateTypeEnum;
    /**
     * 
     * @type {Array<AuditLog>}
     * @memberof BlockingState
     */
    'auditLogs'?: Array<AuditLog>;
}

export const BlockingStateTypeEnum = {
    Subscription: 'SUBSCRIPTION',
    SubscriptionBundle: 'SUBSCRIPTION_BUNDLE',
    Account: 'ACCOUNT'
} as const;

export type BlockingStateTypeEnum = typeof BlockingStateTypeEnum[keyof typeof BlockingStateTypeEnum];

/**
 * 
 * @export
 * @interface BulkSubscriptionsBundle
 */
export interface BulkSubscriptionsBundle {
    /**
     * 
     * @type {Array<Subscription>}
     * @memberof BulkSubscriptionsBundle
     */
    'baseEntitlementAndAddOns': Array<Subscription>;
}
/**
 * 
 * @export
 * @interface Bundle
 */
export interface Bundle {
    /**
     * 
     * @type {string}
     * @memberof Bundle
     */
    'accountId': string;
    /**
     * 
     * @type {string}
     * @memberof Bundle
     */
    'bundleId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Bundle
     */
    'externalKey'?: string;
    /**
     * 
     * @type {Array<Subscription>}
     * @memberof Bundle
     */
    'subscriptions'?: Array<Subscription>;
    /**
     * 
     * @type {BundleTimeline}
     * @memberof Bundle
     */
    'timeline'?: BundleTimeline;
    /**
     * 
     * @type {Array<AuditLog>}
     * @memberof Bundle
     */
    'auditLogs'?: Array<AuditLog>;
}
/**
 * 
 * @export
 * @interface BundleTimeline
 */
export interface BundleTimeline {
    /**
     * 
     * @type {string}
     * @memberof BundleTimeline
     */
    'accountId'?: string;
    /**
     * 
     * @type {string}
     * @memberof BundleTimeline
     */
    'bundleId'?: string;
    /**
     * 
     * @type {string}
     * @memberof BundleTimeline
     */
    'externalKey'?: string;
    /**
     * 
     * @type {Array<EventSubscription>}
     * @memberof BundleTimeline
     */
    'events'?: Array<EventSubscription>;
    /**
     * 
     * @type {Array<AuditLog>}
     * @memberof BundleTimeline
     */
    'auditLogs'?: Array<AuditLog>;
}
/**
 * 
 * @export
 * @interface Catalog
 */
export interface Catalog {
    /**
     * 
     * @type {string}
     * @memberof Catalog
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Catalog
     */
    'effectiveDate'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Catalog
     */
    'currencies'?: Array<CatalogCurrenciesEnum>;
    /**
     * 
     * @type {Array<Unit>}
     * @memberof Catalog
     */
    'units'?: Array<Unit>;
    /**
     * 
     * @type {Array<Product>}
     * @memberof Catalog
     */
    'products'?: Array<Product>;
    /**
     * 
     * @type {Array<PriceList>}
     * @memberof Catalog
     */
    'priceLists'?: Array<PriceList>;
}

export const CatalogCurrenciesEnum = {
    Aed: 'AED',
    Afn: 'AFN',
    All: 'ALL',
    Amd: 'AMD',
    Ang: 'ANG',
    Aoa: 'AOA',
    Ars: 'ARS',
    Aud: 'AUD',
    Awg: 'AWG',
    Azn: 'AZN',
    Bam: 'BAM',
    Bbd: 'BBD',
    Bdt: 'BDT',
    Bgn: 'BGN',
    Bhd: 'BHD',
    Bif: 'BIF',
    Bmd: 'BMD',
    Bnd: 'BND',
    Bob: 'BOB',
    Brl: 'BRL',
    Bsd: 'BSD',
    Btn: 'BTN',
    Bwp: 'BWP',
    Byr: 'BYR',
    Bzd: 'BZD',
    Cad: 'CAD',
    Cdf: 'CDF',
    Chf: 'CHF',
    Clp: 'CLP',
    Cny: 'CNY',
    Cop: 'COP',
    Crc: 'CRC',
    Cuc: 'CUC',
    Cup: 'CUP',
    Cve: 'CVE',
    Czk: 'CZK',
    Djf: 'DJF',
    Dkk: 'DKK',
    Dop: 'DOP',
    Dzd: 'DZD',
    Egp: 'EGP',
    Ern: 'ERN',
    Etb: 'ETB',
    Eur: 'EUR',
    Fjd: 'FJD',
    Fkp: 'FKP',
    Gbp: 'GBP',
    Gel: 'GEL',
    Ggp: 'GGP',
    Ghs: 'GHS',
    Gip: 'GIP',
    Gmd: 'GMD',
    Gnf: 'GNF',
    Gtq: 'GTQ',
    Gyd: 'GYD',
    Hkd: 'HKD',
    Hnl: 'HNL',
    Hrk: 'HRK',
    Htg: 'HTG',
    Huf: 'HUF',
    Idr: 'IDR',
    Ils: 'ILS',
    Imp: 'IMP',
    Inr: 'INR',
    Iqd: 'IQD',
    Irr: 'IRR',
    Isk: 'ISK',
    Jep: 'JEP',
    Jmd: 'JMD',
    Jod: 'JOD',
    Jpy: 'JPY',
    Kes: 'KES',
    Kgs: 'KGS',
    Khr: 'KHR',
    Kmf: 'KMF',
    Kpw: 'KPW',
    Krw: 'KRW',
    Kwd: 'KWD',
    Kyd: 'KYD',
    Kzt: 'KZT',
    Lak: 'LAK',
    Lbp: 'LBP',
    Lkr: 'LKR',
    Lrd: 'LRD',
    Lsl: 'LSL',
    Ltl: 'LTL',
    Lvl: 'LVL',
    Lyd: 'LYD',
    Mad: 'MAD',
    Mdl: 'MDL',
    Mga: 'MGA',
    Mkd: 'MKD',
    Mmk: 'MMK',
    Mnt: 'MNT',
    Mop: 'MOP',
    Mro: 'MRO',
    Mur: 'MUR',
    Mvr: 'MVR',
    Mwk: 'MWK',
    Mxn: 'MXN',
    Myr: 'MYR',
    Mzn: 'MZN',
    Nad: 'NAD',
    Ngn: 'NGN',
    Nio: 'NIO',
    Nok: 'NOK',
    Npr: 'NPR',
    Nzd: 'NZD',
    Omr: 'OMR',
    Pab: 'PAB',
    Pen: 'PEN',
    Pgk: 'PGK',
    Php: 'PHP',
    Pkr: 'PKR',
    Pln: 'PLN',
    Pyg: 'PYG',
    Qar: 'QAR',
    Ron: 'RON',
    Rsd: 'RSD',
    Rub: 'RUB',
    Rwf: 'RWF',
    Sar: 'SAR',
    Sbd: 'SBD',
    Scr: 'SCR',
    Sdg: 'SDG',
    Sek: 'SEK',
    Sgd: 'SGD',
    Shp: 'SHP',
    Sll: 'SLL',
    Sos: 'SOS',
    Spl: 'SPL',
    Srd: 'SRD',
    Std: 'STD',
    Svc: 'SVC',
    Syp: 'SYP',
    Szl: 'SZL',
    Thb: 'THB',
    Tjs: 'TJS',
    Tmt: 'TMT',
    Tnd: 'TND',
    Top: 'TOP',
    Try: 'TRY',
    Ttd: 'TTD',
    Tvd: 'TVD',
    Twd: 'TWD',
    Tzs: 'TZS',
    Uah: 'UAH',
    Ugx: 'UGX',
    Usd: 'USD',
    Uyu: 'UYU',
    Uzs: 'UZS',
    Vef: 'VEF',
    Vnd: 'VND',
    Vuv: 'VUV',
    Wst: 'WST',
    Xaf: 'XAF',
    Xcd: 'XCD',
    Xdr: 'XDR',
    Xof: 'XOF',
    Xpf: 'XPF',
    Yer: 'YER',
    Zar: 'ZAR',
    Zmw: 'ZMW',
    Zwd: 'ZWD',
    Btc: 'BTC'
} as const;

export type CatalogCurrenciesEnum = typeof CatalogCurrenciesEnum[keyof typeof CatalogCurrenciesEnum];

/**
 * 
 * @export
 * @interface CatalogValidation
 */
export interface CatalogValidation {
    /**
     * 
     * @type {Array<CatalogValidationError>}
     * @memberof CatalogValidation
     */
    'catalogValidationErrors'?: Array<CatalogValidationError>;
}
/**
 * 
 * @export
 * @interface CatalogValidationError
 */
export interface CatalogValidationError {
    /**
     * 
     * @type {string}
     * @memberof CatalogValidationError
     */
    'errorDescription'?: string;
}
/**
 * 
 * @export
 * @interface ComboHostedPaymentPage
 */
export interface ComboHostedPaymentPage {
    /**
     * 
     * @type {Account}
     * @memberof ComboHostedPaymentPage
     */
    'account'?: Account;
    /**
     * 
     * @type {PaymentMethod}
     * @memberof ComboHostedPaymentPage
     */
    'paymentMethod'?: PaymentMethod;
    /**
     * 
     * @type {HostedPaymentPageFields}
     * @memberof ComboHostedPaymentPage
     */
    'hostedPaymentPageFields'?: HostedPaymentPageFields;
    /**
     * 
     * @type {Array<PluginProperty>}
     * @memberof ComboHostedPaymentPage
     */
    'paymentMethodPluginProperties'?: Array<PluginProperty>;
    /**
     * 
     * @type {Array<AuditLog>}
     * @memberof ComboHostedPaymentPage
     */
    'auditLogs'?: Array<AuditLog>;
}
/**
 * 
 * @export
 * @interface ComboPaymentTransaction
 */
export interface ComboPaymentTransaction {
    /**
     * 
     * @type {Account}
     * @memberof ComboPaymentTransaction
     */
    'account'?: Account;
    /**
     * 
     * @type {PaymentMethod}
     * @memberof ComboPaymentTransaction
     */
    'paymentMethod'?: PaymentMethod;
    /**
     * 
     * @type {PaymentTransaction}
     * @memberof ComboPaymentTransaction
     */
    'transaction'?: PaymentTransaction;
    /**
     * 
     * @type {Array<PluginProperty>}
     * @memberof ComboPaymentTransaction
     */
    'paymentMethodPluginProperties'?: Array<PluginProperty>;
    /**
     * 
     * @type {Array<PluginProperty>}
     * @memberof ComboPaymentTransaction
     */
    'transactionPluginProperties'?: Array<PluginProperty>;
    /**
     * 
     * @type {Array<AuditLog>}
     * @memberof ComboPaymentTransaction
     */
    'auditLogs'?: Array<AuditLog>;
}
/**
 * 
 * @export
 * @interface CustomField
 */
export interface CustomField {
    /**
     * 
     * @type {string}
     * @memberof CustomField
     */
    'customFieldId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomField
     */
    'objectId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomField
     */
    'objectType'?: CustomFieldObjectTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CustomField
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CustomField
     */
    'value': string;
    /**
     * 
     * @type {Array<AuditLog>}
     * @memberof CustomField
     */
    'auditLogs'?: Array<AuditLog>;
}

export const CustomFieldObjectTypeEnum = {
    Account: 'ACCOUNT',
    AccountEmail: 'ACCOUNT_EMAIL',
    BlockingStates: 'BLOCKING_STATES',
    Bundle: 'BUNDLE',
    CustomField: 'CUSTOM_FIELD',
    Invoice: 'INVOICE',
    Payment: 'PAYMENT',
    Transaction: 'TRANSACTION',
    InvoiceItem: 'INVOICE_ITEM',
    InvoicePayment: 'INVOICE_PAYMENT',
    Subscription: 'SUBSCRIPTION',
    SubscriptionEvent: 'SUBSCRIPTION_EVENT',
    ServiceBroadcast: 'SERVICE_BROADCAST',
    PaymentAttempt: 'PAYMENT_ATTEMPT',
    PaymentMethod: 'PAYMENT_METHOD',
    Tag: 'TAG',
    TagDefinition: 'TAG_DEFINITION',
    Tenant: 'TENANT',
    TenantKvs: 'TENANT_KVS'
} as const;

export type CustomFieldObjectTypeEnum = typeof CustomFieldObjectTypeEnum[keyof typeof CustomFieldObjectTypeEnum];

/**
 * 
 * @export
 * @interface Duration
 */
export interface Duration {
    /**
     * 
     * @type {string}
     * @memberof Duration
     */
    'unit'?: DurationUnitEnum;
    /**
     * 
     * @type {number}
     * @memberof Duration
     */
    'number'?: number;
}

export const DurationUnitEnum = {
    Days: 'DAYS',
    Weeks: 'WEEKS',
    Months: 'MONTHS',
    Years: 'YEARS',
    Unlimited: 'UNLIMITED'
} as const;

export type DurationUnitEnum = typeof DurationUnitEnum[keyof typeof DurationUnitEnum];

/**
 * 
 * @export
 * @interface Entity
 */
export interface Entity {
    /**
     * 
     * @type {string}
     * @memberof Entity
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Entity
     */
    'createdDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof Entity
     */
    'updatedDate'?: string;
}
/**
 * 
 * @export
 * @interface EventSubscription
 */
export interface EventSubscription {
    /**
     * 
     * @type {string}
     * @memberof EventSubscription
     */
    'eventId'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventSubscription
     */
    'billingPeriod'?: EventSubscriptionBillingPeriodEnum;
    /**
     * 
     * @type {string}
     * @memberof EventSubscription
     */
    'effectiveDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventSubscription
     */
    'catalogEffectiveDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventSubscription
     */
    'plan'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventSubscription
     */
    'product'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventSubscription
     */
    'priceList'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventSubscription
     */
    'eventType'?: EventSubscriptionEventTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof EventSubscription
     */
    'isBlockedBilling'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EventSubscription
     */
    'isBlockedEntitlement'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EventSubscription
     */
    'serviceName'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventSubscription
     */
    'serviceStateName'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventSubscription
     */
    'phase'?: string;
    /**
     * 
     * @type {Array<AuditLog>}
     * @memberof EventSubscription
     */
    'auditLogs'?: Array<AuditLog>;
}

export const EventSubscriptionBillingPeriodEnum = {
    Daily: 'DAILY',
    Weekly: 'WEEKLY',
    Biweekly: 'BIWEEKLY',
    ThirtyDays: 'THIRTY_DAYS',
    ThirtyOneDays: 'THIRTY_ONE_DAYS',
    SixtyDays: 'SIXTY_DAYS',
    NinetyDays: 'NINETY_DAYS',
    Monthly: 'MONTHLY',
    Bimestrial: 'BIMESTRIAL',
    Quarterly: 'QUARTERLY',
    Triannual: 'TRIANNUAL',
    Biannual: 'BIANNUAL',
    Annual: 'ANNUAL',
    Sesquiennial: 'SESQUIENNIAL',
    Biennial: 'BIENNIAL',
    Triennial: 'TRIENNIAL',
    NoBillingPeriod: 'NO_BILLING_PERIOD'
} as const;

export type EventSubscriptionBillingPeriodEnum = typeof EventSubscriptionBillingPeriodEnum[keyof typeof EventSubscriptionBillingPeriodEnum];
export const EventSubscriptionEventTypeEnum = {
    StartEntitlement: 'START_ENTITLEMENT',
    StartBilling: 'START_BILLING',
    PauseEntitlement: 'PAUSE_ENTITLEMENT',
    PauseBilling: 'PAUSE_BILLING',
    ResumeEntitlement: 'RESUME_ENTITLEMENT',
    ResumeBilling: 'RESUME_BILLING',
    Phase: 'PHASE',
    Change: 'CHANGE',
    StopEntitlement: 'STOP_ENTITLEMENT',
    StopBilling: 'STOP_BILLING',
    ServiceStateChange: 'SERVICE_STATE_CHANGE'
} as const;

export type EventSubscriptionEventTypeEnum = typeof EventSubscriptionEventTypeEnum[keyof typeof EventSubscriptionEventTypeEnum];

/**
 * 
 * @export
 * @interface HostedPaymentPageFields
 */
export interface HostedPaymentPageFields {
    /**
     * 
     * @type {Array<PluginProperty>}
     * @memberof HostedPaymentPageFields
     */
    'formFields'?: Array<PluginProperty>;
}
/**
 * 
 * @export
 * @interface HostedPaymentPageFormDescriptor
 */
export interface HostedPaymentPageFormDescriptor {
    /**
     * 
     * @type {string}
     * @memberof HostedPaymentPageFormDescriptor
     */
    'kbAccountId'?: string;
    /**
     * 
     * @type {string}
     * @memberof HostedPaymentPageFormDescriptor
     */
    'formMethod'?: string;
    /**
     * 
     * @type {string}
     * @memberof HostedPaymentPageFormDescriptor
     */
    'formUrl'?: string;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof HostedPaymentPageFormDescriptor
     */
    'formFields'?: { [key: string]: object; };
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof HostedPaymentPageFormDescriptor
     */
    'properties'?: { [key: string]: object; };
    /**
     * 
     * @type {Array<AuditLog>}
     * @memberof HostedPaymentPageFormDescriptor
     */
    'auditLogs'?: Array<AuditLog>;
}
/**
 * 
 * @export
 * @interface Invoice
 */
export interface Invoice {
    /**
     * 
     * @type {number}
     * @memberof Invoice
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'currency'?: InvoiceCurrencyEnum;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'status'?: InvoiceStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof Invoice
     */
    'creditAdj'?: number;
    /**
     * 
     * @type {number}
     * @memberof Invoice
     */
    'refundAdj'?: number;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'invoiceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'invoiceDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'targetDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'invoiceNumber'?: string;
    /**
     * 
     * @type {number}
     * @memberof Invoice
     */
    'balance'?: number;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'accountId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'bundleKeys'?: string;
    /**
     * 
     * @type {Array<InvoiceItem>}
     * @memberof Invoice
     */
    'credits'?: Array<InvoiceItem>;
    /**
     * 
     * @type {Array<InvoiceItem>}
     * @memberof Invoice
     */
    'items'?: Array<InvoiceItem>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Invoice
     */
    'trackingIds'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof Invoice
     */
    'isParentInvoice'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'parentInvoiceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    'parentAccountId'?: string;
    /**
     * 
     * @type {Array<AuditLog>}
     * @memberof Invoice
     */
    'auditLogs'?: Array<AuditLog>;
}

export const InvoiceCurrencyEnum = {
    Aed: 'AED',
    Afn: 'AFN',
    All: 'ALL',
    Amd: 'AMD',
    Ang: 'ANG',
    Aoa: 'AOA',
    Ars: 'ARS',
    Aud: 'AUD',
    Awg: 'AWG',
    Azn: 'AZN',
    Bam: 'BAM',
    Bbd: 'BBD',
    Bdt: 'BDT',
    Bgn: 'BGN',
    Bhd: 'BHD',
    Bif: 'BIF',
    Bmd: 'BMD',
    Bnd: 'BND',
    Bob: 'BOB',
    Brl: 'BRL',
    Bsd: 'BSD',
    Btn: 'BTN',
    Bwp: 'BWP',
    Byr: 'BYR',
    Bzd: 'BZD',
    Cad: 'CAD',
    Cdf: 'CDF',
    Chf: 'CHF',
    Clp: 'CLP',
    Cny: 'CNY',
    Cop: 'COP',
    Crc: 'CRC',
    Cuc: 'CUC',
    Cup: 'CUP',
    Cve: 'CVE',
    Czk: 'CZK',
    Djf: 'DJF',
    Dkk: 'DKK',
    Dop: 'DOP',
    Dzd: 'DZD',
    Egp: 'EGP',
    Ern: 'ERN',
    Etb: 'ETB',
    Eur: 'EUR',
    Fjd: 'FJD',
    Fkp: 'FKP',
    Gbp: 'GBP',
    Gel: 'GEL',
    Ggp: 'GGP',
    Ghs: 'GHS',
    Gip: 'GIP',
    Gmd: 'GMD',
    Gnf: 'GNF',
    Gtq: 'GTQ',
    Gyd: 'GYD',
    Hkd: 'HKD',
    Hnl: 'HNL',
    Hrk: 'HRK',
    Htg: 'HTG',
    Huf: 'HUF',
    Idr: 'IDR',
    Ils: 'ILS',
    Imp: 'IMP',
    Inr: 'INR',
    Iqd: 'IQD',
    Irr: 'IRR',
    Isk: 'ISK',
    Jep: 'JEP',
    Jmd: 'JMD',
    Jod: 'JOD',
    Jpy: 'JPY',
    Kes: 'KES',
    Kgs: 'KGS',
    Khr: 'KHR',
    Kmf: 'KMF',
    Kpw: 'KPW',
    Krw: 'KRW',
    Kwd: 'KWD',
    Kyd: 'KYD',
    Kzt: 'KZT',
    Lak: 'LAK',
    Lbp: 'LBP',
    Lkr: 'LKR',
    Lrd: 'LRD',
    Lsl: 'LSL',
    Ltl: 'LTL',
    Lvl: 'LVL',
    Lyd: 'LYD',
    Mad: 'MAD',
    Mdl: 'MDL',
    Mga: 'MGA',
    Mkd: 'MKD',
    Mmk: 'MMK',
    Mnt: 'MNT',
    Mop: 'MOP',
    Mro: 'MRO',
    Mur: 'MUR',
    Mvr: 'MVR',
    Mwk: 'MWK',
    Mxn: 'MXN',
    Myr: 'MYR',
    Mzn: 'MZN',
    Nad: 'NAD',
    Ngn: 'NGN',
    Nio: 'NIO',
    Nok: 'NOK',
    Npr: 'NPR',
    Nzd: 'NZD',
    Omr: 'OMR',
    Pab: 'PAB',
    Pen: 'PEN',
    Pgk: 'PGK',
    Php: 'PHP',
    Pkr: 'PKR',
    Pln: 'PLN',
    Pyg: 'PYG',
    Qar: 'QAR',
    Ron: 'RON',
    Rsd: 'RSD',
    Rub: 'RUB',
    Rwf: 'RWF',
    Sar: 'SAR',
    Sbd: 'SBD',
    Scr: 'SCR',
    Sdg: 'SDG',
    Sek: 'SEK',
    Sgd: 'SGD',
    Shp: 'SHP',
    Sll: 'SLL',
    Sos: 'SOS',
    Spl: 'SPL',
    Srd: 'SRD',
    Std: 'STD',
    Svc: 'SVC',
    Syp: 'SYP',
    Szl: 'SZL',
    Thb: 'THB',
    Tjs: 'TJS',
    Tmt: 'TMT',
    Tnd: 'TND',
    Top: 'TOP',
    Try: 'TRY',
    Ttd: 'TTD',
    Tvd: 'TVD',
    Twd: 'TWD',
    Tzs: 'TZS',
    Uah: 'UAH',
    Ugx: 'UGX',
    Usd: 'USD',
    Uyu: 'UYU',
    Uzs: 'UZS',
    Vef: 'VEF',
    Vnd: 'VND',
    Vuv: 'VUV',
    Wst: 'WST',
    Xaf: 'XAF',
    Xcd: 'XCD',
    Xdr: 'XDR',
    Xof: 'XOF',
    Xpf: 'XPF',
    Yer: 'YER',
    Zar: 'ZAR',
    Zmw: 'ZMW',
    Zwd: 'ZWD',
    Btc: 'BTC'
} as const;

export type InvoiceCurrencyEnum = typeof InvoiceCurrencyEnum[keyof typeof InvoiceCurrencyEnum];
export const InvoiceStatusEnum = {
    Draft: 'DRAFT',
    Committed: 'COMMITTED',
    Void: 'VOID'
} as const;

export type InvoiceStatusEnum = typeof InvoiceStatusEnum[keyof typeof InvoiceStatusEnum];

/**
 * 
 * @export
 * @interface InvoiceDryRun
 */
export interface InvoiceDryRun {
    /**
     * 
     * @type {string}
     * @memberof InvoiceDryRun
     */
    'dryRunType'?: InvoiceDryRunDryRunTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof InvoiceDryRun
     */
    'dryRunAction'?: InvoiceDryRunDryRunActionEnum;
    /**
     * 
     * @type {string}
     * @memberof InvoiceDryRun
     */
    'phaseType'?: InvoiceDryRunPhaseTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof InvoiceDryRun
     */
    'productName'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceDryRun
     */
    'productCategory'?: InvoiceDryRunProductCategoryEnum;
    /**
     * 
     * @type {string}
     * @memberof InvoiceDryRun
     */
    'billingPeriod'?: InvoiceDryRunBillingPeriodEnum;
    /**
     * 
     * @type {string}
     * @memberof InvoiceDryRun
     */
    'priceListName'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceDryRun
     */
    'subscriptionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceDryRun
     */
    'bundleId'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceDryRun
     */
    'effectiveDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceDryRun
     */
    'billingPolicy'?: InvoiceDryRunBillingPolicyEnum;
    /**
     * 
     * @type {Array<PhasePrice>}
     * @memberof InvoiceDryRun
     */
    'priceOverrides'?: Array<PhasePrice>;
    /**
     * 
     * @type {string}
     * @memberof InvoiceDryRun
     */
    'planName'?: string;
}

export const InvoiceDryRunDryRunTypeEnum = {
    TargetDate: 'TARGET_DATE',
    UpcomingInvoice: 'UPCOMING_INVOICE',
    SubscriptionAction: 'SUBSCRIPTION_ACTION'
} as const;

export type InvoiceDryRunDryRunTypeEnum = typeof InvoiceDryRunDryRunTypeEnum[keyof typeof InvoiceDryRunDryRunTypeEnum];
export const InvoiceDryRunDryRunActionEnum = {
    StartEntitlement: 'START_ENTITLEMENT',
    StartBilling: 'START_BILLING',
    PauseEntitlement: 'PAUSE_ENTITLEMENT',
    PauseBilling: 'PAUSE_BILLING',
    ResumeEntitlement: 'RESUME_ENTITLEMENT',
    ResumeBilling: 'RESUME_BILLING',
    Phase: 'PHASE',
    Change: 'CHANGE',
    StopEntitlement: 'STOP_ENTITLEMENT',
    StopBilling: 'STOP_BILLING',
    ServiceStateChange: 'SERVICE_STATE_CHANGE'
} as const;

export type InvoiceDryRunDryRunActionEnum = typeof InvoiceDryRunDryRunActionEnum[keyof typeof InvoiceDryRunDryRunActionEnum];
export const InvoiceDryRunPhaseTypeEnum = {
    Trial: 'TRIAL',
    Discount: 'DISCOUNT',
    Fixedterm: 'FIXEDTERM',
    Evergreen: 'EVERGREEN'
} as const;

export type InvoiceDryRunPhaseTypeEnum = typeof InvoiceDryRunPhaseTypeEnum[keyof typeof InvoiceDryRunPhaseTypeEnum];
export const InvoiceDryRunProductCategoryEnum = {
    Base: 'BASE',
    AddOn: 'ADD_ON',
    Standalone: 'STANDALONE'
} as const;

export type InvoiceDryRunProductCategoryEnum = typeof InvoiceDryRunProductCategoryEnum[keyof typeof InvoiceDryRunProductCategoryEnum];
export const InvoiceDryRunBillingPeriodEnum = {
    Daily: 'DAILY',
    Weekly: 'WEEKLY',
    Biweekly: 'BIWEEKLY',
    ThirtyDays: 'THIRTY_DAYS',
    ThirtyOneDays: 'THIRTY_ONE_DAYS',
    SixtyDays: 'SIXTY_DAYS',
    NinetyDays: 'NINETY_DAYS',
    Monthly: 'MONTHLY',
    Bimestrial: 'BIMESTRIAL',
    Quarterly: 'QUARTERLY',
    Triannual: 'TRIANNUAL',
    Biannual: 'BIANNUAL',
    Annual: 'ANNUAL',
    Sesquiennial: 'SESQUIENNIAL',
    Biennial: 'BIENNIAL',
    Triennial: 'TRIENNIAL',
    NoBillingPeriod: 'NO_BILLING_PERIOD'
} as const;

export type InvoiceDryRunBillingPeriodEnum = typeof InvoiceDryRunBillingPeriodEnum[keyof typeof InvoiceDryRunBillingPeriodEnum];
export const InvoiceDryRunBillingPolicyEnum = {
    StartOfTerm: 'START_OF_TERM',
    EndOfTerm: 'END_OF_TERM',
    Immediate: 'IMMEDIATE',
    Illegal: 'ILLEGAL'
} as const;

export type InvoiceDryRunBillingPolicyEnum = typeof InvoiceDryRunBillingPolicyEnum[keyof typeof InvoiceDryRunBillingPolicyEnum];

/**
 * 
 * @export
 * @interface InvoiceItem
 */
export interface InvoiceItem {
    /**
     * 
     * @type {string}
     * @memberof InvoiceItem
     */
    'invoiceItemId': string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceItem
     */
    'invoiceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceItem
     */
    'linkedInvoiceItemId'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceItem
     */
    'accountId': string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceItem
     */
    'childAccountId'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceItem
     */
    'bundleId'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceItem
     */
    'subscriptionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceItem
     */
    'productName'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceItem
     */
    'planName'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceItem
     */
    'phaseName'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceItem
     */
    'usageName'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceItem
     */
    'prettyProductName'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceItem
     */
    'prettyPlanName'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceItem
     */
    'prettyPhaseName'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceItem
     */
    'prettyUsageName'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceItem
     */
    'itemType'?: InvoiceItemItemTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof InvoiceItem
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceItem
     */
    'startDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceItem
     */
    'endDate'?: string;
    /**
     * 
     * @type {number}
     * @memberof InvoiceItem
     */
    'amount'?: number;
    /**
     * 
     * @type {number}
     * @memberof InvoiceItem
     */
    'rate'?: number;
    /**
     * 
     * @type {string}
     * @memberof InvoiceItem
     */
    'currency'?: InvoiceItemCurrencyEnum;
    /**
     * 
     * @type {number}
     * @memberof InvoiceItem
     */
    'quantity'?: number;
    /**
     * 
     * @type {string}
     * @memberof InvoiceItem
     */
    'itemDetails'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceItem
     */
    'catalogEffectiveDate'?: string;
    /**
     * 
     * @type {Array<InvoiceItem>}
     * @memberof InvoiceItem
     */
    'childItems'?: Array<InvoiceItem>;
    /**
     * 
     * @type {Array<AuditLog>}
     * @memberof InvoiceItem
     */
    'auditLogs'?: Array<AuditLog>;
}

export const InvoiceItemItemTypeEnum = {
    ExternalCharge: 'EXTERNAL_CHARGE',
    Fixed: 'FIXED',
    Recurring: 'RECURRING',
    RepairAdj: 'REPAIR_ADJ',
    CbaAdj: 'CBA_ADJ',
    CreditAdj: 'CREDIT_ADJ',
    ItemAdj: 'ITEM_ADJ',
    Usage: 'USAGE',
    Tax: 'TAX',
    ParentSummary: 'PARENT_SUMMARY'
} as const;

export type InvoiceItemItemTypeEnum = typeof InvoiceItemItemTypeEnum[keyof typeof InvoiceItemItemTypeEnum];
export const InvoiceItemCurrencyEnum = {
    Aed: 'AED',
    Afn: 'AFN',
    All: 'ALL',
    Amd: 'AMD',
    Ang: 'ANG',
    Aoa: 'AOA',
    Ars: 'ARS',
    Aud: 'AUD',
    Awg: 'AWG',
    Azn: 'AZN',
    Bam: 'BAM',
    Bbd: 'BBD',
    Bdt: 'BDT',
    Bgn: 'BGN',
    Bhd: 'BHD',
    Bif: 'BIF',
    Bmd: 'BMD',
    Bnd: 'BND',
    Bob: 'BOB',
    Brl: 'BRL',
    Bsd: 'BSD',
    Btn: 'BTN',
    Bwp: 'BWP',
    Byr: 'BYR',
    Bzd: 'BZD',
    Cad: 'CAD',
    Cdf: 'CDF',
    Chf: 'CHF',
    Clp: 'CLP',
    Cny: 'CNY',
    Cop: 'COP',
    Crc: 'CRC',
    Cuc: 'CUC',
    Cup: 'CUP',
    Cve: 'CVE',
    Czk: 'CZK',
    Djf: 'DJF',
    Dkk: 'DKK',
    Dop: 'DOP',
    Dzd: 'DZD',
    Egp: 'EGP',
    Ern: 'ERN',
    Etb: 'ETB',
    Eur: 'EUR',
    Fjd: 'FJD',
    Fkp: 'FKP',
    Gbp: 'GBP',
    Gel: 'GEL',
    Ggp: 'GGP',
    Ghs: 'GHS',
    Gip: 'GIP',
    Gmd: 'GMD',
    Gnf: 'GNF',
    Gtq: 'GTQ',
    Gyd: 'GYD',
    Hkd: 'HKD',
    Hnl: 'HNL',
    Hrk: 'HRK',
    Htg: 'HTG',
    Huf: 'HUF',
    Idr: 'IDR',
    Ils: 'ILS',
    Imp: 'IMP',
    Inr: 'INR',
    Iqd: 'IQD',
    Irr: 'IRR',
    Isk: 'ISK',
    Jep: 'JEP',
    Jmd: 'JMD',
    Jod: 'JOD',
    Jpy: 'JPY',
    Kes: 'KES',
    Kgs: 'KGS',
    Khr: 'KHR',
    Kmf: 'KMF',
    Kpw: 'KPW',
    Krw: 'KRW',
    Kwd: 'KWD',
    Kyd: 'KYD',
    Kzt: 'KZT',
    Lak: 'LAK',
    Lbp: 'LBP',
    Lkr: 'LKR',
    Lrd: 'LRD',
    Lsl: 'LSL',
    Ltl: 'LTL',
    Lvl: 'LVL',
    Lyd: 'LYD',
    Mad: 'MAD',
    Mdl: 'MDL',
    Mga: 'MGA',
    Mkd: 'MKD',
    Mmk: 'MMK',
    Mnt: 'MNT',
    Mop: 'MOP',
    Mro: 'MRO',
    Mur: 'MUR',
    Mvr: 'MVR',
    Mwk: 'MWK',
    Mxn: 'MXN',
    Myr: 'MYR',
    Mzn: 'MZN',
    Nad: 'NAD',
    Ngn: 'NGN',
    Nio: 'NIO',
    Nok: 'NOK',
    Npr: 'NPR',
    Nzd: 'NZD',
    Omr: 'OMR',
    Pab: 'PAB',
    Pen: 'PEN',
    Pgk: 'PGK',
    Php: 'PHP',
    Pkr: 'PKR',
    Pln: 'PLN',
    Pyg: 'PYG',
    Qar: 'QAR',
    Ron: 'RON',
    Rsd: 'RSD',
    Rub: 'RUB',
    Rwf: 'RWF',
    Sar: 'SAR',
    Sbd: 'SBD',
    Scr: 'SCR',
    Sdg: 'SDG',
    Sek: 'SEK',
    Sgd: 'SGD',
    Shp: 'SHP',
    Sll: 'SLL',
    Sos: 'SOS',
    Spl: 'SPL',
    Srd: 'SRD',
    Std: 'STD',
    Svc: 'SVC',
    Syp: 'SYP',
    Szl: 'SZL',
    Thb: 'THB',
    Tjs: 'TJS',
    Tmt: 'TMT',
    Tnd: 'TND',
    Top: 'TOP',
    Try: 'TRY',
    Ttd: 'TTD',
    Tvd: 'TVD',
    Twd: 'TWD',
    Tzs: 'TZS',
    Uah: 'UAH',
    Ugx: 'UGX',
    Usd: 'USD',
    Uyu: 'UYU',
    Uzs: 'UZS',
    Vef: 'VEF',
    Vnd: 'VND',
    Vuv: 'VUV',
    Wst: 'WST',
    Xaf: 'XAF',
    Xcd: 'XCD',
    Xdr: 'XDR',
    Xof: 'XOF',
    Xpf: 'XPF',
    Yer: 'YER',
    Zar: 'ZAR',
    Zmw: 'ZMW',
    Zwd: 'ZWD',
    Btc: 'BTC'
} as const;

export type InvoiceItemCurrencyEnum = typeof InvoiceItemCurrencyEnum[keyof typeof InvoiceItemCurrencyEnum];

/**
 * 
 * @export
 * @interface InvoicePayment
 */
export interface InvoicePayment {
    /**
     * 
     * @type {string}
     * @memberof InvoicePayment
     */
    'targetInvoiceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoicePayment
     */
    'accountId'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoicePayment
     */
    'paymentId'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoicePayment
     */
    'paymentNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoicePayment
     */
    'paymentExternalKey'?: string;
    /**
     * 
     * @type {number}
     * @memberof InvoicePayment
     */
    'authAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof InvoicePayment
     */
    'capturedAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof InvoicePayment
     */
    'purchasedAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof InvoicePayment
     */
    'refundedAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof InvoicePayment
     */
    'creditedAmount'?: number;
    /**
     * 
     * @type {string}
     * @memberof InvoicePayment
     */
    'currency'?: InvoicePaymentCurrencyEnum;
    /**
     * 
     * @type {string}
     * @memberof InvoicePayment
     */
    'paymentMethodId'?: string;
    /**
     * 
     * @type {Array<PaymentTransaction>}
     * @memberof InvoicePayment
     */
    'transactions'?: Array<PaymentTransaction>;
    /**
     * 
     * @type {Array<PaymentAttempt>}
     * @memberof InvoicePayment
     */
    'paymentAttempts'?: Array<PaymentAttempt>;
    /**
     * 
     * @type {Array<AuditLog>}
     * @memberof InvoicePayment
     */
    'auditLogs'?: Array<AuditLog>;
}

export const InvoicePaymentCurrencyEnum = {
    Aed: 'AED',
    Afn: 'AFN',
    All: 'ALL',
    Amd: 'AMD',
    Ang: 'ANG',
    Aoa: 'AOA',
    Ars: 'ARS',
    Aud: 'AUD',
    Awg: 'AWG',
    Azn: 'AZN',
    Bam: 'BAM',
    Bbd: 'BBD',
    Bdt: 'BDT',
    Bgn: 'BGN',
    Bhd: 'BHD',
    Bif: 'BIF',
    Bmd: 'BMD',
    Bnd: 'BND',
    Bob: 'BOB',
    Brl: 'BRL',
    Bsd: 'BSD',
    Btn: 'BTN',
    Bwp: 'BWP',
    Byr: 'BYR',
    Bzd: 'BZD',
    Cad: 'CAD',
    Cdf: 'CDF',
    Chf: 'CHF',
    Clp: 'CLP',
    Cny: 'CNY',
    Cop: 'COP',
    Crc: 'CRC',
    Cuc: 'CUC',
    Cup: 'CUP',
    Cve: 'CVE',
    Czk: 'CZK',
    Djf: 'DJF',
    Dkk: 'DKK',
    Dop: 'DOP',
    Dzd: 'DZD',
    Egp: 'EGP',
    Ern: 'ERN',
    Etb: 'ETB',
    Eur: 'EUR',
    Fjd: 'FJD',
    Fkp: 'FKP',
    Gbp: 'GBP',
    Gel: 'GEL',
    Ggp: 'GGP',
    Ghs: 'GHS',
    Gip: 'GIP',
    Gmd: 'GMD',
    Gnf: 'GNF',
    Gtq: 'GTQ',
    Gyd: 'GYD',
    Hkd: 'HKD',
    Hnl: 'HNL',
    Hrk: 'HRK',
    Htg: 'HTG',
    Huf: 'HUF',
    Idr: 'IDR',
    Ils: 'ILS',
    Imp: 'IMP',
    Inr: 'INR',
    Iqd: 'IQD',
    Irr: 'IRR',
    Isk: 'ISK',
    Jep: 'JEP',
    Jmd: 'JMD',
    Jod: 'JOD',
    Jpy: 'JPY',
    Kes: 'KES',
    Kgs: 'KGS',
    Khr: 'KHR',
    Kmf: 'KMF',
    Kpw: 'KPW',
    Krw: 'KRW',
    Kwd: 'KWD',
    Kyd: 'KYD',
    Kzt: 'KZT',
    Lak: 'LAK',
    Lbp: 'LBP',
    Lkr: 'LKR',
    Lrd: 'LRD',
    Lsl: 'LSL',
    Ltl: 'LTL',
    Lvl: 'LVL',
    Lyd: 'LYD',
    Mad: 'MAD',
    Mdl: 'MDL',
    Mga: 'MGA',
    Mkd: 'MKD',
    Mmk: 'MMK',
    Mnt: 'MNT',
    Mop: 'MOP',
    Mro: 'MRO',
    Mur: 'MUR',
    Mvr: 'MVR',
    Mwk: 'MWK',
    Mxn: 'MXN',
    Myr: 'MYR',
    Mzn: 'MZN',
    Nad: 'NAD',
    Ngn: 'NGN',
    Nio: 'NIO',
    Nok: 'NOK',
    Npr: 'NPR',
    Nzd: 'NZD',
    Omr: 'OMR',
    Pab: 'PAB',
    Pen: 'PEN',
    Pgk: 'PGK',
    Php: 'PHP',
    Pkr: 'PKR',
    Pln: 'PLN',
    Pyg: 'PYG',
    Qar: 'QAR',
    Ron: 'RON',
    Rsd: 'RSD',
    Rub: 'RUB',
    Rwf: 'RWF',
    Sar: 'SAR',
    Sbd: 'SBD',
    Scr: 'SCR',
    Sdg: 'SDG',
    Sek: 'SEK',
    Sgd: 'SGD',
    Shp: 'SHP',
    Sll: 'SLL',
    Sos: 'SOS',
    Spl: 'SPL',
    Srd: 'SRD',
    Std: 'STD',
    Svc: 'SVC',
    Syp: 'SYP',
    Szl: 'SZL',
    Thb: 'THB',
    Tjs: 'TJS',
    Tmt: 'TMT',
    Tnd: 'TND',
    Top: 'TOP',
    Try: 'TRY',
    Ttd: 'TTD',
    Tvd: 'TVD',
    Twd: 'TWD',
    Tzs: 'TZS',
    Uah: 'UAH',
    Ugx: 'UGX',
    Usd: 'USD',
    Uyu: 'UYU',
    Uzs: 'UZS',
    Vef: 'VEF',
    Vnd: 'VND',
    Vuv: 'VUV',
    Wst: 'WST',
    Xaf: 'XAF',
    Xcd: 'XCD',
    Xdr: 'XDR',
    Xof: 'XOF',
    Xpf: 'XPF',
    Yer: 'YER',
    Zar: 'ZAR',
    Zmw: 'ZMW',
    Zwd: 'ZWD',
    Btc: 'BTC'
} as const;

export type InvoicePaymentCurrencyEnum = typeof InvoicePaymentCurrencyEnum[keyof typeof InvoicePaymentCurrencyEnum];

/**
 * 
 * @export
 * @interface InvoicePaymentTransaction
 */
export interface InvoicePaymentTransaction {
    /**
     * 
     * @type {string}
     * @memberof InvoicePaymentTransaction
     */
    'transactionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoicePaymentTransaction
     */
    'transactionExternalKey'?: string;
    /**
     * Associated payment id, required when notifying state transitions
     * @type {string}
     * @memberof InvoicePaymentTransaction
     */
    'paymentId'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoicePaymentTransaction
     */
    'paymentExternalKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoicePaymentTransaction
     */
    'transactionType'?: InvoicePaymentTransactionTransactionTypeEnum;
    /**
     * Transaction amount, required except for void operations
     * @type {number}
     * @memberof InvoicePaymentTransaction
     */
    'amount'?: number;
    /**
     * Amount currency (account currency unless specified)
     * @type {string}
     * @memberof InvoicePaymentTransaction
     */
    'currency'?: InvoicePaymentTransactionCurrencyEnum;
    /**
     * 
     * @type {string}
     * @memberof InvoicePaymentTransaction
     */
    'effectiveDate'?: string;
    /**
     * 
     * @type {number}
     * @memberof InvoicePaymentTransaction
     */
    'processedAmount'?: number;
    /**
     * 
     * @type {string}
     * @memberof InvoicePaymentTransaction
     */
    'processedCurrency'?: InvoicePaymentTransactionProcessedCurrencyEnum;
    /**
     * Transaction status, required for state change notifications
     * @type {string}
     * @memberof InvoicePaymentTransaction
     */
    'status'?: InvoicePaymentTransactionStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof InvoicePaymentTransaction
     */
    'gatewayErrorCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoicePaymentTransaction
     */
    'gatewayErrorMsg'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoicePaymentTransaction
     */
    'firstPaymentReferenceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoicePaymentTransaction
     */
    'secondPaymentReferenceId'?: string;
    /**
     * 
     * @type {Array<PluginProperty>}
     * @memberof InvoicePaymentTransaction
     */
    'properties'?: Array<PluginProperty>;
    /**
     * 
     * @type {boolean}
     * @memberof InvoicePaymentTransaction
     */
    'isAdjusted'?: boolean;
    /**
     * 
     * @type {Array<InvoiceItem>}
     * @memberof InvoicePaymentTransaction
     */
    'adjustments'?: Array<InvoiceItem>;
    /**
     * 
     * @type {Array<AuditLog>}
     * @memberof InvoicePaymentTransaction
     */
    'auditLogs'?: Array<AuditLog>;
}

export const InvoicePaymentTransactionTransactionTypeEnum = {
    Authorize: 'AUTHORIZE',
    Capture: 'CAPTURE',
    Chargeback: 'CHARGEBACK',
    Credit: 'CREDIT',
    Purchase: 'PURCHASE',
    Refund: 'REFUND',
    Void: 'VOID'
} as const;

export type InvoicePaymentTransactionTransactionTypeEnum = typeof InvoicePaymentTransactionTransactionTypeEnum[keyof typeof InvoicePaymentTransactionTransactionTypeEnum];
export const InvoicePaymentTransactionCurrencyEnum = {
    Aed: 'AED',
    Afn: 'AFN',
    All: 'ALL',
    Amd: 'AMD',
    Ang: 'ANG',
    Aoa: 'AOA',
    Ars: 'ARS',
    Aud: 'AUD',
    Awg: 'AWG',
    Azn: 'AZN',
    Bam: 'BAM',
    Bbd: 'BBD',
    Bdt: 'BDT',
    Bgn: 'BGN',
    Bhd: 'BHD',
    Bif: 'BIF',
    Bmd: 'BMD',
    Bnd: 'BND',
    Bob: 'BOB',
    Brl: 'BRL',
    Bsd: 'BSD',
    Btn: 'BTN',
    Bwp: 'BWP',
    Byr: 'BYR',
    Bzd: 'BZD',
    Cad: 'CAD',
    Cdf: 'CDF',
    Chf: 'CHF',
    Clp: 'CLP',
    Cny: 'CNY',
    Cop: 'COP',
    Crc: 'CRC',
    Cuc: 'CUC',
    Cup: 'CUP',
    Cve: 'CVE',
    Czk: 'CZK',
    Djf: 'DJF',
    Dkk: 'DKK',
    Dop: 'DOP',
    Dzd: 'DZD',
    Egp: 'EGP',
    Ern: 'ERN',
    Etb: 'ETB',
    Eur: 'EUR',
    Fjd: 'FJD',
    Fkp: 'FKP',
    Gbp: 'GBP',
    Gel: 'GEL',
    Ggp: 'GGP',
    Ghs: 'GHS',
    Gip: 'GIP',
    Gmd: 'GMD',
    Gnf: 'GNF',
    Gtq: 'GTQ',
    Gyd: 'GYD',
    Hkd: 'HKD',
    Hnl: 'HNL',
    Hrk: 'HRK',
    Htg: 'HTG',
    Huf: 'HUF',
    Idr: 'IDR',
    Ils: 'ILS',
    Imp: 'IMP',
    Inr: 'INR',
    Iqd: 'IQD',
    Irr: 'IRR',
    Isk: 'ISK',
    Jep: 'JEP',
    Jmd: 'JMD',
    Jod: 'JOD',
    Jpy: 'JPY',
    Kes: 'KES',
    Kgs: 'KGS',
    Khr: 'KHR',
    Kmf: 'KMF',
    Kpw: 'KPW',
    Krw: 'KRW',
    Kwd: 'KWD',
    Kyd: 'KYD',
    Kzt: 'KZT',
    Lak: 'LAK',
    Lbp: 'LBP',
    Lkr: 'LKR',
    Lrd: 'LRD',
    Lsl: 'LSL',
    Ltl: 'LTL',
    Lvl: 'LVL',
    Lyd: 'LYD',
    Mad: 'MAD',
    Mdl: 'MDL',
    Mga: 'MGA',
    Mkd: 'MKD',
    Mmk: 'MMK',
    Mnt: 'MNT',
    Mop: 'MOP',
    Mro: 'MRO',
    Mur: 'MUR',
    Mvr: 'MVR',
    Mwk: 'MWK',
    Mxn: 'MXN',
    Myr: 'MYR',
    Mzn: 'MZN',
    Nad: 'NAD',
    Ngn: 'NGN',
    Nio: 'NIO',
    Nok: 'NOK',
    Npr: 'NPR',
    Nzd: 'NZD',
    Omr: 'OMR',
    Pab: 'PAB',
    Pen: 'PEN',
    Pgk: 'PGK',
    Php: 'PHP',
    Pkr: 'PKR',
    Pln: 'PLN',
    Pyg: 'PYG',
    Qar: 'QAR',
    Ron: 'RON',
    Rsd: 'RSD',
    Rub: 'RUB',
    Rwf: 'RWF',
    Sar: 'SAR',
    Sbd: 'SBD',
    Scr: 'SCR',
    Sdg: 'SDG',
    Sek: 'SEK',
    Sgd: 'SGD',
    Shp: 'SHP',
    Sll: 'SLL',
    Sos: 'SOS',
    Spl: 'SPL',
    Srd: 'SRD',
    Std: 'STD',
    Svc: 'SVC',
    Syp: 'SYP',
    Szl: 'SZL',
    Thb: 'THB',
    Tjs: 'TJS',
    Tmt: 'TMT',
    Tnd: 'TND',
    Top: 'TOP',
    Try: 'TRY',
    Ttd: 'TTD',
    Tvd: 'TVD',
    Twd: 'TWD',
    Tzs: 'TZS',
    Uah: 'UAH',
    Ugx: 'UGX',
    Usd: 'USD',
    Uyu: 'UYU',
    Uzs: 'UZS',
    Vef: 'VEF',
    Vnd: 'VND',
    Vuv: 'VUV',
    Wst: 'WST',
    Xaf: 'XAF',
    Xcd: 'XCD',
    Xdr: 'XDR',
    Xof: 'XOF',
    Xpf: 'XPF',
    Yer: 'YER',
    Zar: 'ZAR',
    Zmw: 'ZMW',
    Zwd: 'ZWD',
    Btc: 'BTC'
} as const;

export type InvoicePaymentTransactionCurrencyEnum = typeof InvoicePaymentTransactionCurrencyEnum[keyof typeof InvoicePaymentTransactionCurrencyEnum];
export const InvoicePaymentTransactionProcessedCurrencyEnum = {
    Aed: 'AED',
    Afn: 'AFN',
    All: 'ALL',
    Amd: 'AMD',
    Ang: 'ANG',
    Aoa: 'AOA',
    Ars: 'ARS',
    Aud: 'AUD',
    Awg: 'AWG',
    Azn: 'AZN',
    Bam: 'BAM',
    Bbd: 'BBD',
    Bdt: 'BDT',
    Bgn: 'BGN',
    Bhd: 'BHD',
    Bif: 'BIF',
    Bmd: 'BMD',
    Bnd: 'BND',
    Bob: 'BOB',
    Brl: 'BRL',
    Bsd: 'BSD',
    Btn: 'BTN',
    Bwp: 'BWP',
    Byr: 'BYR',
    Bzd: 'BZD',
    Cad: 'CAD',
    Cdf: 'CDF',
    Chf: 'CHF',
    Clp: 'CLP',
    Cny: 'CNY',
    Cop: 'COP',
    Crc: 'CRC',
    Cuc: 'CUC',
    Cup: 'CUP',
    Cve: 'CVE',
    Czk: 'CZK',
    Djf: 'DJF',
    Dkk: 'DKK',
    Dop: 'DOP',
    Dzd: 'DZD',
    Egp: 'EGP',
    Ern: 'ERN',
    Etb: 'ETB',
    Eur: 'EUR',
    Fjd: 'FJD',
    Fkp: 'FKP',
    Gbp: 'GBP',
    Gel: 'GEL',
    Ggp: 'GGP',
    Ghs: 'GHS',
    Gip: 'GIP',
    Gmd: 'GMD',
    Gnf: 'GNF',
    Gtq: 'GTQ',
    Gyd: 'GYD',
    Hkd: 'HKD',
    Hnl: 'HNL',
    Hrk: 'HRK',
    Htg: 'HTG',
    Huf: 'HUF',
    Idr: 'IDR',
    Ils: 'ILS',
    Imp: 'IMP',
    Inr: 'INR',
    Iqd: 'IQD',
    Irr: 'IRR',
    Isk: 'ISK',
    Jep: 'JEP',
    Jmd: 'JMD',
    Jod: 'JOD',
    Jpy: 'JPY',
    Kes: 'KES',
    Kgs: 'KGS',
    Khr: 'KHR',
    Kmf: 'KMF',
    Kpw: 'KPW',
    Krw: 'KRW',
    Kwd: 'KWD',
    Kyd: 'KYD',
    Kzt: 'KZT',
    Lak: 'LAK',
    Lbp: 'LBP',
    Lkr: 'LKR',
    Lrd: 'LRD',
    Lsl: 'LSL',
    Ltl: 'LTL',
    Lvl: 'LVL',
    Lyd: 'LYD',
    Mad: 'MAD',
    Mdl: 'MDL',
    Mga: 'MGA',
    Mkd: 'MKD',
    Mmk: 'MMK',
    Mnt: 'MNT',
    Mop: 'MOP',
    Mro: 'MRO',
    Mur: 'MUR',
    Mvr: 'MVR',
    Mwk: 'MWK',
    Mxn: 'MXN',
    Myr: 'MYR',
    Mzn: 'MZN',
    Nad: 'NAD',
    Ngn: 'NGN',
    Nio: 'NIO',
    Nok: 'NOK',
    Npr: 'NPR',
    Nzd: 'NZD',
    Omr: 'OMR',
    Pab: 'PAB',
    Pen: 'PEN',
    Pgk: 'PGK',
    Php: 'PHP',
    Pkr: 'PKR',
    Pln: 'PLN',
    Pyg: 'PYG',
    Qar: 'QAR',
    Ron: 'RON',
    Rsd: 'RSD',
    Rub: 'RUB',
    Rwf: 'RWF',
    Sar: 'SAR',
    Sbd: 'SBD',
    Scr: 'SCR',
    Sdg: 'SDG',
    Sek: 'SEK',
    Sgd: 'SGD',
    Shp: 'SHP',
    Sll: 'SLL',
    Sos: 'SOS',
    Spl: 'SPL',
    Srd: 'SRD',
    Std: 'STD',
    Svc: 'SVC',
    Syp: 'SYP',
    Szl: 'SZL',
    Thb: 'THB',
    Tjs: 'TJS',
    Tmt: 'TMT',
    Tnd: 'TND',
    Top: 'TOP',
    Try: 'TRY',
    Ttd: 'TTD',
    Tvd: 'TVD',
    Twd: 'TWD',
    Tzs: 'TZS',
    Uah: 'UAH',
    Ugx: 'UGX',
    Usd: 'USD',
    Uyu: 'UYU',
    Uzs: 'UZS',
    Vef: 'VEF',
    Vnd: 'VND',
    Vuv: 'VUV',
    Wst: 'WST',
    Xaf: 'XAF',
    Xcd: 'XCD',
    Xdr: 'XDR',
    Xof: 'XOF',
    Xpf: 'XPF',
    Yer: 'YER',
    Zar: 'ZAR',
    Zmw: 'ZMW',
    Zwd: 'ZWD',
    Btc: 'BTC'
} as const;

export type InvoicePaymentTransactionProcessedCurrencyEnum = typeof InvoicePaymentTransactionProcessedCurrencyEnum[keyof typeof InvoicePaymentTransactionProcessedCurrencyEnum];
export const InvoicePaymentTransactionStatusEnum = {
    Success: 'SUCCESS',
    Unknown: 'UNKNOWN',
    Pending: 'PENDING',
    PaymentFailure: 'PAYMENT_FAILURE',
    PluginFailure: 'PLUGIN_FAILURE',
    PaymentSystemOff: 'PAYMENT_SYSTEM_OFF'
} as const;

export type InvoicePaymentTransactionStatusEnum = typeof InvoicePaymentTransactionStatusEnum[keyof typeof InvoicePaymentTransactionStatusEnum];

/**
 * 
 * @export
 * @interface Limit
 */
export interface Limit {
    /**
     * 
     * @type {string}
     * @memberof Limit
     */
    'unit'?: string;
    /**
     * 
     * @type {string}
     * @memberof Limit
     */
    'max'?: string;
    /**
     * 
     * @type {string}
     * @memberof Limit
     */
    'min'?: string;
}
/**
 * 
 * @export
 * @interface NodeCommand
 */
export interface NodeCommand {
    /**
     * 
     * @type {boolean}
     * @memberof NodeCommand
     */
    'isSystemCommandType'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof NodeCommand
     */
    'nodeCommandType'?: string;
    /**
     * 
     * @type {Array<NodeCommandProperty>}
     * @memberof NodeCommand
     */
    'nodeCommandProperties'?: Array<NodeCommandProperty>;
}
/**
 * 
 * @export
 * @interface NodeCommandProperty
 */
export interface NodeCommandProperty {
    /**
     * 
     * @type {string}
     * @memberof NodeCommandProperty
     */
    'key'?: string;
    /**
     * 
     * @type {object}
     * @memberof NodeCommandProperty
     */
    'value'?: object;
}
/**
 * 
 * @export
 * @interface NodeInfo
 */
export interface NodeInfo {
    /**
     * 
     * @type {string}
     * @memberof NodeInfo
     */
    'nodeName'?: string;
    /**
     * 
     * @type {string}
     * @memberof NodeInfo
     */
    'bootTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof NodeInfo
     */
    'lastUpdatedDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof NodeInfo
     */
    'kbVersion'?: string;
    /**
     * 
     * @type {string}
     * @memberof NodeInfo
     */
    'apiVersion'?: string;
    /**
     * 
     * @type {string}
     * @memberof NodeInfo
     */
    'pluginApiVersion'?: string;
    /**
     * 
     * @type {string}
     * @memberof NodeInfo
     */
    'commonVersion'?: string;
    /**
     * 
     * @type {string}
     * @memberof NodeInfo
     */
    'platformVersion'?: string;
    /**
     * 
     * @type {Array<PluginInfo>}
     * @memberof NodeInfo
     */
    'pluginsInfo'?: Array<PluginInfo>;
}
/**
 * 
 * @export
 * @interface Overdue
 */
export interface Overdue {
    /**
     * 
     * @type {number}
     * @memberof Overdue
     */
    'initialReevaluationInterval'?: number;
    /**
     * 
     * @type {Array<OverdueStateConfig>}
     * @memberof Overdue
     */
    'overdueStates'?: Array<OverdueStateConfig>;
}
/**
 * 
 * @export
 * @interface OverdueCondition
 */
export interface OverdueCondition {
    /**
     * 
     * @type {Duration}
     * @memberof OverdueCondition
     */
    'timeSinceEarliestUnpaidInvoiceEqualsOrExceeds'?: Duration;
    /**
     * 
     * @type {string}
     * @memberof OverdueCondition
     */
    'controlTagInclusion'?: OverdueConditionControlTagInclusionEnum;
    /**
     * 
     * @type {string}
     * @memberof OverdueCondition
     */
    'controlTagExclusion'?: OverdueConditionControlTagExclusionEnum;
    /**
     * 
     * @type {number}
     * @memberof OverdueCondition
     */
    'numberOfUnpaidInvoicesEqualsOrExceeds'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof OverdueCondition
     */
    'responseForLastFailedPayment'?: Array<OverdueConditionResponseForLastFailedPaymentEnum>;
    /**
     * 
     * @type {number}
     * @memberof OverdueCondition
     */
    'totalUnpaidInvoiceBalanceEqualsOrExceeds'?: number;
}

export const OverdueConditionControlTagInclusionEnum = {
    AutoPayOff: 'AUTO_PAY_OFF',
    AutoInvoicingOff: 'AUTO_INVOICING_OFF',
    OverdueEnforcementOff: 'OVERDUE_ENFORCEMENT_OFF',
    WrittenOff: 'WRITTEN_OFF',
    ManualPay: 'MANUAL_PAY',
    Test: 'TEST',
    Partner: 'PARTNER',
    AutoInvoicingDraft: 'AUTO_INVOICING_DRAFT',
    AutoInvoicingReuseDraft: 'AUTO_INVOICING_REUSE_DRAFT'
} as const;

export type OverdueConditionControlTagInclusionEnum = typeof OverdueConditionControlTagInclusionEnum[keyof typeof OverdueConditionControlTagInclusionEnum];
export const OverdueConditionControlTagExclusionEnum = {
    AutoPayOff: 'AUTO_PAY_OFF',
    AutoInvoicingOff: 'AUTO_INVOICING_OFF',
    OverdueEnforcementOff: 'OVERDUE_ENFORCEMENT_OFF',
    WrittenOff: 'WRITTEN_OFF',
    ManualPay: 'MANUAL_PAY',
    Test: 'TEST',
    Partner: 'PARTNER',
    AutoInvoicingDraft: 'AUTO_INVOICING_DRAFT',
    AutoInvoicingReuseDraft: 'AUTO_INVOICING_REUSE_DRAFT'
} as const;

export type OverdueConditionControlTagExclusionEnum = typeof OverdueConditionControlTagExclusionEnum[keyof typeof OverdueConditionControlTagExclusionEnum];
export const OverdueConditionResponseForLastFailedPaymentEnum = {
    InvalidCard: 'INVALID_CARD',
    ExpiredCard: 'EXPIRED_CARD',
    LostOrStolenCard: 'LOST_OR_STOLEN_CARD',
    DoNotHonor: 'DO_NOT_HONOR',
    InsufficientFunds: 'INSUFFICIENT_FUNDS',
    Decline: 'DECLINE',
    ProcessingError: 'PROCESSING_ERROR',
    InvalidAmount: 'INVALID_AMOUNT',
    DuplicateTransaction: 'DUPLICATE_TRANSACTION',
    Other: 'OTHER'
} as const;

export type OverdueConditionResponseForLastFailedPaymentEnum = typeof OverdueConditionResponseForLastFailedPaymentEnum[keyof typeof OverdueConditionResponseForLastFailedPaymentEnum];

/**
 * 
 * @export
 * @interface OverdueState
 */
export interface OverdueState {
    /**
     * 
     * @type {string}
     * @memberof OverdueState
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OverdueState
     */
    'externalMessage'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OverdueState
     */
    'isDisableEntitlementAndChangesBlocked'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OverdueState
     */
    'isBlockChanges'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OverdueState
     */
    'isClearState'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof OverdueState
     */
    'reevaluationIntervalDays'?: number;
}
/**
 * 
 * @export
 * @interface OverdueStateConfig
 */
export interface OverdueStateConfig {
    /**
     * 
     * @type {string}
     * @memberof OverdueStateConfig
     */
    'name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OverdueStateConfig
     */
    'isClearState'?: boolean;
    /**
     * 
     * @type {OverdueCondition}
     * @memberof OverdueStateConfig
     */
    'condition'?: OverdueCondition;
    /**
     * 
     * @type {string}
     * @memberof OverdueStateConfig
     */
    'externalMessage'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OverdueStateConfig
     */
    'isBlockChanges'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OverdueStateConfig
     */
    'isDisableEntitlement'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OverdueStateConfig
     */
    'subscriptionCancellationPolicy'?: OverdueStateConfigSubscriptionCancellationPolicyEnum;
    /**
     * 
     * @type {number}
     * @memberof OverdueStateConfig
     */
    'autoReevaluationIntervalDays'?: number;
}

export const OverdueStateConfigSubscriptionCancellationPolicyEnum = {
    EndOfTerm: 'END_OF_TERM',
    Immediate: 'IMMEDIATE',
    None: 'NONE'
} as const;

export type OverdueStateConfigSubscriptionCancellationPolicyEnum = typeof OverdueStateConfigSubscriptionCancellationPolicyEnum[keyof typeof OverdueStateConfigSubscriptionCancellationPolicyEnum];

/**
 * 
 * @export
 * @interface Payment
 */
export interface Payment {
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    'accountId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    'paymentId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    'paymentNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    'paymentExternalKey'?: string;
    /**
     * 
     * @type {number}
     * @memberof Payment
     */
    'authAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof Payment
     */
    'capturedAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof Payment
     */
    'purchasedAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof Payment
     */
    'refundedAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof Payment
     */
    'creditedAmount'?: number;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    'currency'?: PaymentCurrencyEnum;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    'paymentMethodId'?: string;
    /**
     * 
     * @type {Array<PaymentTransaction>}
     * @memberof Payment
     */
    'transactions'?: Array<PaymentTransaction>;
    /**
     * 
     * @type {Array<PaymentAttempt>}
     * @memberof Payment
     */
    'paymentAttempts'?: Array<PaymentAttempt>;
    /**
     * 
     * @type {Array<AuditLog>}
     * @memberof Payment
     */
    'auditLogs'?: Array<AuditLog>;
}

export const PaymentCurrencyEnum = {
    Aed: 'AED',
    Afn: 'AFN',
    All: 'ALL',
    Amd: 'AMD',
    Ang: 'ANG',
    Aoa: 'AOA',
    Ars: 'ARS',
    Aud: 'AUD',
    Awg: 'AWG',
    Azn: 'AZN',
    Bam: 'BAM',
    Bbd: 'BBD',
    Bdt: 'BDT',
    Bgn: 'BGN',
    Bhd: 'BHD',
    Bif: 'BIF',
    Bmd: 'BMD',
    Bnd: 'BND',
    Bob: 'BOB',
    Brl: 'BRL',
    Bsd: 'BSD',
    Btn: 'BTN',
    Bwp: 'BWP',
    Byr: 'BYR',
    Bzd: 'BZD',
    Cad: 'CAD',
    Cdf: 'CDF',
    Chf: 'CHF',
    Clp: 'CLP',
    Cny: 'CNY',
    Cop: 'COP',
    Crc: 'CRC',
    Cuc: 'CUC',
    Cup: 'CUP',
    Cve: 'CVE',
    Czk: 'CZK',
    Djf: 'DJF',
    Dkk: 'DKK',
    Dop: 'DOP',
    Dzd: 'DZD',
    Egp: 'EGP',
    Ern: 'ERN',
    Etb: 'ETB',
    Eur: 'EUR',
    Fjd: 'FJD',
    Fkp: 'FKP',
    Gbp: 'GBP',
    Gel: 'GEL',
    Ggp: 'GGP',
    Ghs: 'GHS',
    Gip: 'GIP',
    Gmd: 'GMD',
    Gnf: 'GNF',
    Gtq: 'GTQ',
    Gyd: 'GYD',
    Hkd: 'HKD',
    Hnl: 'HNL',
    Hrk: 'HRK',
    Htg: 'HTG',
    Huf: 'HUF',
    Idr: 'IDR',
    Ils: 'ILS',
    Imp: 'IMP',
    Inr: 'INR',
    Iqd: 'IQD',
    Irr: 'IRR',
    Isk: 'ISK',
    Jep: 'JEP',
    Jmd: 'JMD',
    Jod: 'JOD',
    Jpy: 'JPY',
    Kes: 'KES',
    Kgs: 'KGS',
    Khr: 'KHR',
    Kmf: 'KMF',
    Kpw: 'KPW',
    Krw: 'KRW',
    Kwd: 'KWD',
    Kyd: 'KYD',
    Kzt: 'KZT',
    Lak: 'LAK',
    Lbp: 'LBP',
    Lkr: 'LKR',
    Lrd: 'LRD',
    Lsl: 'LSL',
    Ltl: 'LTL',
    Lvl: 'LVL',
    Lyd: 'LYD',
    Mad: 'MAD',
    Mdl: 'MDL',
    Mga: 'MGA',
    Mkd: 'MKD',
    Mmk: 'MMK',
    Mnt: 'MNT',
    Mop: 'MOP',
    Mro: 'MRO',
    Mur: 'MUR',
    Mvr: 'MVR',
    Mwk: 'MWK',
    Mxn: 'MXN',
    Myr: 'MYR',
    Mzn: 'MZN',
    Nad: 'NAD',
    Ngn: 'NGN',
    Nio: 'NIO',
    Nok: 'NOK',
    Npr: 'NPR',
    Nzd: 'NZD',
    Omr: 'OMR',
    Pab: 'PAB',
    Pen: 'PEN',
    Pgk: 'PGK',
    Php: 'PHP',
    Pkr: 'PKR',
    Pln: 'PLN',
    Pyg: 'PYG',
    Qar: 'QAR',
    Ron: 'RON',
    Rsd: 'RSD',
    Rub: 'RUB',
    Rwf: 'RWF',
    Sar: 'SAR',
    Sbd: 'SBD',
    Scr: 'SCR',
    Sdg: 'SDG',
    Sek: 'SEK',
    Sgd: 'SGD',
    Shp: 'SHP',
    Sll: 'SLL',
    Sos: 'SOS',
    Spl: 'SPL',
    Srd: 'SRD',
    Std: 'STD',
    Svc: 'SVC',
    Syp: 'SYP',
    Szl: 'SZL',
    Thb: 'THB',
    Tjs: 'TJS',
    Tmt: 'TMT',
    Tnd: 'TND',
    Top: 'TOP',
    Try: 'TRY',
    Ttd: 'TTD',
    Tvd: 'TVD',
    Twd: 'TWD',
    Tzs: 'TZS',
    Uah: 'UAH',
    Ugx: 'UGX',
    Usd: 'USD',
    Uyu: 'UYU',
    Uzs: 'UZS',
    Vef: 'VEF',
    Vnd: 'VND',
    Vuv: 'VUV',
    Wst: 'WST',
    Xaf: 'XAF',
    Xcd: 'XCD',
    Xdr: 'XDR',
    Xof: 'XOF',
    Xpf: 'XPF',
    Yer: 'YER',
    Zar: 'ZAR',
    Zmw: 'ZMW',
    Zwd: 'ZWD',
    Btc: 'BTC'
} as const;

export type PaymentCurrencyEnum = typeof PaymentCurrencyEnum[keyof typeof PaymentCurrencyEnum];

/**
 * 
 * @export
 * @interface PaymentAttempt
 */
export interface PaymentAttempt {
    /**
     * 
     * @type {string}
     * @memberof PaymentAttempt
     */
    'accountId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentAttempt
     */
    'paymentMethodId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentAttempt
     */
    'paymentExternalKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentAttempt
     */
    'transactionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentAttempt
     */
    'transactionExternalKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentAttempt
     */
    'transactionType'?: PaymentAttemptTransactionTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof PaymentAttempt
     */
    'effectiveDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentAttempt
     */
    'stateName'?: string;
    /**
     * Transaction amount, required except for void operations
     * @type {number}
     * @memberof PaymentAttempt
     */
    'amount'?: number;
    /**
     * Amount currency (account currency unless specified)
     * @type {string}
     * @memberof PaymentAttempt
     */
    'currency'?: PaymentAttemptCurrencyEnum;
    /**
     * 
     * @type {string}
     * @memberof PaymentAttempt
     */
    'pluginName'?: string;
    /**
     * 
     * @type {Array<PluginProperty>}
     * @memberof PaymentAttempt
     */
    'pluginProperties'?: Array<PluginProperty>;
    /**
     * 
     * @type {Array<AuditLog>}
     * @memberof PaymentAttempt
     */
    'auditLogs'?: Array<AuditLog>;
}

export const PaymentAttemptTransactionTypeEnum = {
    Authorize: 'AUTHORIZE',
    Capture: 'CAPTURE',
    Chargeback: 'CHARGEBACK',
    Credit: 'CREDIT',
    Purchase: 'PURCHASE',
    Refund: 'REFUND',
    Void: 'VOID'
} as const;

export type PaymentAttemptTransactionTypeEnum = typeof PaymentAttemptTransactionTypeEnum[keyof typeof PaymentAttemptTransactionTypeEnum];
export const PaymentAttemptCurrencyEnum = {
    Aed: 'AED',
    Afn: 'AFN',
    All: 'ALL',
    Amd: 'AMD',
    Ang: 'ANG',
    Aoa: 'AOA',
    Ars: 'ARS',
    Aud: 'AUD',
    Awg: 'AWG',
    Azn: 'AZN',
    Bam: 'BAM',
    Bbd: 'BBD',
    Bdt: 'BDT',
    Bgn: 'BGN',
    Bhd: 'BHD',
    Bif: 'BIF',
    Bmd: 'BMD',
    Bnd: 'BND',
    Bob: 'BOB',
    Brl: 'BRL',
    Bsd: 'BSD',
    Btn: 'BTN',
    Bwp: 'BWP',
    Byr: 'BYR',
    Bzd: 'BZD',
    Cad: 'CAD',
    Cdf: 'CDF',
    Chf: 'CHF',
    Clp: 'CLP',
    Cny: 'CNY',
    Cop: 'COP',
    Crc: 'CRC',
    Cuc: 'CUC',
    Cup: 'CUP',
    Cve: 'CVE',
    Czk: 'CZK',
    Djf: 'DJF',
    Dkk: 'DKK',
    Dop: 'DOP',
    Dzd: 'DZD',
    Egp: 'EGP',
    Ern: 'ERN',
    Etb: 'ETB',
    Eur: 'EUR',
    Fjd: 'FJD',
    Fkp: 'FKP',
    Gbp: 'GBP',
    Gel: 'GEL',
    Ggp: 'GGP',
    Ghs: 'GHS',
    Gip: 'GIP',
    Gmd: 'GMD',
    Gnf: 'GNF',
    Gtq: 'GTQ',
    Gyd: 'GYD',
    Hkd: 'HKD',
    Hnl: 'HNL',
    Hrk: 'HRK',
    Htg: 'HTG',
    Huf: 'HUF',
    Idr: 'IDR',
    Ils: 'ILS',
    Imp: 'IMP',
    Inr: 'INR',
    Iqd: 'IQD',
    Irr: 'IRR',
    Isk: 'ISK',
    Jep: 'JEP',
    Jmd: 'JMD',
    Jod: 'JOD',
    Jpy: 'JPY',
    Kes: 'KES',
    Kgs: 'KGS',
    Khr: 'KHR',
    Kmf: 'KMF',
    Kpw: 'KPW',
    Krw: 'KRW',
    Kwd: 'KWD',
    Kyd: 'KYD',
    Kzt: 'KZT',
    Lak: 'LAK',
    Lbp: 'LBP',
    Lkr: 'LKR',
    Lrd: 'LRD',
    Lsl: 'LSL',
    Ltl: 'LTL',
    Lvl: 'LVL',
    Lyd: 'LYD',
    Mad: 'MAD',
    Mdl: 'MDL',
    Mga: 'MGA',
    Mkd: 'MKD',
    Mmk: 'MMK',
    Mnt: 'MNT',
    Mop: 'MOP',
    Mro: 'MRO',
    Mur: 'MUR',
    Mvr: 'MVR',
    Mwk: 'MWK',
    Mxn: 'MXN',
    Myr: 'MYR',
    Mzn: 'MZN',
    Nad: 'NAD',
    Ngn: 'NGN',
    Nio: 'NIO',
    Nok: 'NOK',
    Npr: 'NPR',
    Nzd: 'NZD',
    Omr: 'OMR',
    Pab: 'PAB',
    Pen: 'PEN',
    Pgk: 'PGK',
    Php: 'PHP',
    Pkr: 'PKR',
    Pln: 'PLN',
    Pyg: 'PYG',
    Qar: 'QAR',
    Ron: 'RON',
    Rsd: 'RSD',
    Rub: 'RUB',
    Rwf: 'RWF',
    Sar: 'SAR',
    Sbd: 'SBD',
    Scr: 'SCR',
    Sdg: 'SDG',
    Sek: 'SEK',
    Sgd: 'SGD',
    Shp: 'SHP',
    Sll: 'SLL',
    Sos: 'SOS',
    Spl: 'SPL',
    Srd: 'SRD',
    Std: 'STD',
    Svc: 'SVC',
    Syp: 'SYP',
    Szl: 'SZL',
    Thb: 'THB',
    Tjs: 'TJS',
    Tmt: 'TMT',
    Tnd: 'TND',
    Top: 'TOP',
    Try: 'TRY',
    Ttd: 'TTD',
    Tvd: 'TVD',
    Twd: 'TWD',
    Tzs: 'TZS',
    Uah: 'UAH',
    Ugx: 'UGX',
    Usd: 'USD',
    Uyu: 'UYU',
    Uzs: 'UZS',
    Vef: 'VEF',
    Vnd: 'VND',
    Vuv: 'VUV',
    Wst: 'WST',
    Xaf: 'XAF',
    Xcd: 'XCD',
    Xdr: 'XDR',
    Xof: 'XOF',
    Xpf: 'XPF',
    Yer: 'YER',
    Zar: 'ZAR',
    Zmw: 'ZMW',
    Zwd: 'ZWD',
    Btc: 'BTC'
} as const;

export type PaymentAttemptCurrencyEnum = typeof PaymentAttemptCurrencyEnum[keyof typeof PaymentAttemptCurrencyEnum];

/**
 * 
 * @export
 * @interface PaymentMethod
 */
export interface PaymentMethod {
    /**
     * 
     * @type {string}
     * @memberof PaymentMethod
     */
    'paymentMethodId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethod
     */
    'externalKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethod
     */
    'accountId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentMethod
     */
    'isDefault'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethod
     */
    'pluginName'?: string;
    /**
     * 
     * @type {PaymentMethodPluginDetail}
     * @memberof PaymentMethod
     */
    'pluginInfo'?: PaymentMethodPluginDetail;
    /**
     * 
     * @type {Array<AuditLog>}
     * @memberof PaymentMethod
     */
    'auditLogs'?: Array<AuditLog>;
}
/**
 * 
 * @export
 * @interface PaymentMethodPluginDetail
 */
export interface PaymentMethodPluginDetail {
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodPluginDetail
     */
    'externalPaymentMethodId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentMethodPluginDetail
     */
    'isDefaultPaymentMethod'?: boolean;
    /**
     * 
     * @type {Array<PluginProperty>}
     * @memberof PaymentMethodPluginDetail
     */
    'properties'?: Array<PluginProperty>;
}
/**
 * 
 * @export
 * @interface PaymentTransaction
 */
export interface PaymentTransaction {
    /**
     * 
     * @type {string}
     * @memberof PaymentTransaction
     */
    'transactionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentTransaction
     */
    'transactionExternalKey'?: string;
    /**
     * Associated payment id, required when notifying state transitions
     * @type {string}
     * @memberof PaymentTransaction
     */
    'paymentId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentTransaction
     */
    'paymentExternalKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentTransaction
     */
    'transactionType'?: PaymentTransactionTransactionTypeEnum;
    /**
     * Transaction amount, required except for void operations
     * @type {number}
     * @memberof PaymentTransaction
     */
    'amount'?: number;
    /**
     * Amount currency (account currency unless specified)
     * @type {string}
     * @memberof PaymentTransaction
     */
    'currency'?: PaymentTransactionCurrencyEnum;
    /**
     * 
     * @type {string}
     * @memberof PaymentTransaction
     */
    'effectiveDate'?: string;
    /**
     * 
     * @type {number}
     * @memberof PaymentTransaction
     */
    'processedAmount'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaymentTransaction
     */
    'processedCurrency'?: PaymentTransactionProcessedCurrencyEnum;
    /**
     * Transaction status, required for state change notifications
     * @type {string}
     * @memberof PaymentTransaction
     */
    'status'?: PaymentTransactionStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof PaymentTransaction
     */
    'gatewayErrorCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentTransaction
     */
    'gatewayErrorMsg'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentTransaction
     */
    'firstPaymentReferenceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentTransaction
     */
    'secondPaymentReferenceId'?: string;
    /**
     * 
     * @type {Array<PluginProperty>}
     * @memberof PaymentTransaction
     */
    'properties'?: Array<PluginProperty>;
    /**
     * 
     * @type {Array<AuditLog>}
     * @memberof PaymentTransaction
     */
    'auditLogs'?: Array<AuditLog>;
}

export const PaymentTransactionTransactionTypeEnum = {
    Authorize: 'AUTHORIZE',
    Capture: 'CAPTURE',
    Chargeback: 'CHARGEBACK',
    Credit: 'CREDIT',
    Purchase: 'PURCHASE',
    Refund: 'REFUND',
    Void: 'VOID'
} as const;

export type PaymentTransactionTransactionTypeEnum = typeof PaymentTransactionTransactionTypeEnum[keyof typeof PaymentTransactionTransactionTypeEnum];
export const PaymentTransactionCurrencyEnum = {
    Aed: 'AED',
    Afn: 'AFN',
    All: 'ALL',
    Amd: 'AMD',
    Ang: 'ANG',
    Aoa: 'AOA',
    Ars: 'ARS',
    Aud: 'AUD',
    Awg: 'AWG',
    Azn: 'AZN',
    Bam: 'BAM',
    Bbd: 'BBD',
    Bdt: 'BDT',
    Bgn: 'BGN',
    Bhd: 'BHD',
    Bif: 'BIF',
    Bmd: 'BMD',
    Bnd: 'BND',
    Bob: 'BOB',
    Brl: 'BRL',
    Bsd: 'BSD',
    Btn: 'BTN',
    Bwp: 'BWP',
    Byr: 'BYR',
    Bzd: 'BZD',
    Cad: 'CAD',
    Cdf: 'CDF',
    Chf: 'CHF',
    Clp: 'CLP',
    Cny: 'CNY',
    Cop: 'COP',
    Crc: 'CRC',
    Cuc: 'CUC',
    Cup: 'CUP',
    Cve: 'CVE',
    Czk: 'CZK',
    Djf: 'DJF',
    Dkk: 'DKK',
    Dop: 'DOP',
    Dzd: 'DZD',
    Egp: 'EGP',
    Ern: 'ERN',
    Etb: 'ETB',
    Eur: 'EUR',
    Fjd: 'FJD',
    Fkp: 'FKP',
    Gbp: 'GBP',
    Gel: 'GEL',
    Ggp: 'GGP',
    Ghs: 'GHS',
    Gip: 'GIP',
    Gmd: 'GMD',
    Gnf: 'GNF',
    Gtq: 'GTQ',
    Gyd: 'GYD',
    Hkd: 'HKD',
    Hnl: 'HNL',
    Hrk: 'HRK',
    Htg: 'HTG',
    Huf: 'HUF',
    Idr: 'IDR',
    Ils: 'ILS',
    Imp: 'IMP',
    Inr: 'INR',
    Iqd: 'IQD',
    Irr: 'IRR',
    Isk: 'ISK',
    Jep: 'JEP',
    Jmd: 'JMD',
    Jod: 'JOD',
    Jpy: 'JPY',
    Kes: 'KES',
    Kgs: 'KGS',
    Khr: 'KHR',
    Kmf: 'KMF',
    Kpw: 'KPW',
    Krw: 'KRW',
    Kwd: 'KWD',
    Kyd: 'KYD',
    Kzt: 'KZT',
    Lak: 'LAK',
    Lbp: 'LBP',
    Lkr: 'LKR',
    Lrd: 'LRD',
    Lsl: 'LSL',
    Ltl: 'LTL',
    Lvl: 'LVL',
    Lyd: 'LYD',
    Mad: 'MAD',
    Mdl: 'MDL',
    Mga: 'MGA',
    Mkd: 'MKD',
    Mmk: 'MMK',
    Mnt: 'MNT',
    Mop: 'MOP',
    Mro: 'MRO',
    Mur: 'MUR',
    Mvr: 'MVR',
    Mwk: 'MWK',
    Mxn: 'MXN',
    Myr: 'MYR',
    Mzn: 'MZN',
    Nad: 'NAD',
    Ngn: 'NGN',
    Nio: 'NIO',
    Nok: 'NOK',
    Npr: 'NPR',
    Nzd: 'NZD',
    Omr: 'OMR',
    Pab: 'PAB',
    Pen: 'PEN',
    Pgk: 'PGK',
    Php: 'PHP',
    Pkr: 'PKR',
    Pln: 'PLN',
    Pyg: 'PYG',
    Qar: 'QAR',
    Ron: 'RON',
    Rsd: 'RSD',
    Rub: 'RUB',
    Rwf: 'RWF',
    Sar: 'SAR',
    Sbd: 'SBD',
    Scr: 'SCR',
    Sdg: 'SDG',
    Sek: 'SEK',
    Sgd: 'SGD',
    Shp: 'SHP',
    Sll: 'SLL',
    Sos: 'SOS',
    Spl: 'SPL',
    Srd: 'SRD',
    Std: 'STD',
    Svc: 'SVC',
    Syp: 'SYP',
    Szl: 'SZL',
    Thb: 'THB',
    Tjs: 'TJS',
    Tmt: 'TMT',
    Tnd: 'TND',
    Top: 'TOP',
    Try: 'TRY',
    Ttd: 'TTD',
    Tvd: 'TVD',
    Twd: 'TWD',
    Tzs: 'TZS',
    Uah: 'UAH',
    Ugx: 'UGX',
    Usd: 'USD',
    Uyu: 'UYU',
    Uzs: 'UZS',
    Vef: 'VEF',
    Vnd: 'VND',
    Vuv: 'VUV',
    Wst: 'WST',
    Xaf: 'XAF',
    Xcd: 'XCD',
    Xdr: 'XDR',
    Xof: 'XOF',
    Xpf: 'XPF',
    Yer: 'YER',
    Zar: 'ZAR',
    Zmw: 'ZMW',
    Zwd: 'ZWD',
    Btc: 'BTC'
} as const;

export type PaymentTransactionCurrencyEnum = typeof PaymentTransactionCurrencyEnum[keyof typeof PaymentTransactionCurrencyEnum];
export const PaymentTransactionProcessedCurrencyEnum = {
    Aed: 'AED',
    Afn: 'AFN',
    All: 'ALL',
    Amd: 'AMD',
    Ang: 'ANG',
    Aoa: 'AOA',
    Ars: 'ARS',
    Aud: 'AUD',
    Awg: 'AWG',
    Azn: 'AZN',
    Bam: 'BAM',
    Bbd: 'BBD',
    Bdt: 'BDT',
    Bgn: 'BGN',
    Bhd: 'BHD',
    Bif: 'BIF',
    Bmd: 'BMD',
    Bnd: 'BND',
    Bob: 'BOB',
    Brl: 'BRL',
    Bsd: 'BSD',
    Btn: 'BTN',
    Bwp: 'BWP',
    Byr: 'BYR',
    Bzd: 'BZD',
    Cad: 'CAD',
    Cdf: 'CDF',
    Chf: 'CHF',
    Clp: 'CLP',
    Cny: 'CNY',
    Cop: 'COP',
    Crc: 'CRC',
    Cuc: 'CUC',
    Cup: 'CUP',
    Cve: 'CVE',
    Czk: 'CZK',
    Djf: 'DJF',
    Dkk: 'DKK',
    Dop: 'DOP',
    Dzd: 'DZD',
    Egp: 'EGP',
    Ern: 'ERN',
    Etb: 'ETB',
    Eur: 'EUR',
    Fjd: 'FJD',
    Fkp: 'FKP',
    Gbp: 'GBP',
    Gel: 'GEL',
    Ggp: 'GGP',
    Ghs: 'GHS',
    Gip: 'GIP',
    Gmd: 'GMD',
    Gnf: 'GNF',
    Gtq: 'GTQ',
    Gyd: 'GYD',
    Hkd: 'HKD',
    Hnl: 'HNL',
    Hrk: 'HRK',
    Htg: 'HTG',
    Huf: 'HUF',
    Idr: 'IDR',
    Ils: 'ILS',
    Imp: 'IMP',
    Inr: 'INR',
    Iqd: 'IQD',
    Irr: 'IRR',
    Isk: 'ISK',
    Jep: 'JEP',
    Jmd: 'JMD',
    Jod: 'JOD',
    Jpy: 'JPY',
    Kes: 'KES',
    Kgs: 'KGS',
    Khr: 'KHR',
    Kmf: 'KMF',
    Kpw: 'KPW',
    Krw: 'KRW',
    Kwd: 'KWD',
    Kyd: 'KYD',
    Kzt: 'KZT',
    Lak: 'LAK',
    Lbp: 'LBP',
    Lkr: 'LKR',
    Lrd: 'LRD',
    Lsl: 'LSL',
    Ltl: 'LTL',
    Lvl: 'LVL',
    Lyd: 'LYD',
    Mad: 'MAD',
    Mdl: 'MDL',
    Mga: 'MGA',
    Mkd: 'MKD',
    Mmk: 'MMK',
    Mnt: 'MNT',
    Mop: 'MOP',
    Mro: 'MRO',
    Mur: 'MUR',
    Mvr: 'MVR',
    Mwk: 'MWK',
    Mxn: 'MXN',
    Myr: 'MYR',
    Mzn: 'MZN',
    Nad: 'NAD',
    Ngn: 'NGN',
    Nio: 'NIO',
    Nok: 'NOK',
    Npr: 'NPR',
    Nzd: 'NZD',
    Omr: 'OMR',
    Pab: 'PAB',
    Pen: 'PEN',
    Pgk: 'PGK',
    Php: 'PHP',
    Pkr: 'PKR',
    Pln: 'PLN',
    Pyg: 'PYG',
    Qar: 'QAR',
    Ron: 'RON',
    Rsd: 'RSD',
    Rub: 'RUB',
    Rwf: 'RWF',
    Sar: 'SAR',
    Sbd: 'SBD',
    Scr: 'SCR',
    Sdg: 'SDG',
    Sek: 'SEK',
    Sgd: 'SGD',
    Shp: 'SHP',
    Sll: 'SLL',
    Sos: 'SOS',
    Spl: 'SPL',
    Srd: 'SRD',
    Std: 'STD',
    Svc: 'SVC',
    Syp: 'SYP',
    Szl: 'SZL',
    Thb: 'THB',
    Tjs: 'TJS',
    Tmt: 'TMT',
    Tnd: 'TND',
    Top: 'TOP',
    Try: 'TRY',
    Ttd: 'TTD',
    Tvd: 'TVD',
    Twd: 'TWD',
    Tzs: 'TZS',
    Uah: 'UAH',
    Ugx: 'UGX',
    Usd: 'USD',
    Uyu: 'UYU',
    Uzs: 'UZS',
    Vef: 'VEF',
    Vnd: 'VND',
    Vuv: 'VUV',
    Wst: 'WST',
    Xaf: 'XAF',
    Xcd: 'XCD',
    Xdr: 'XDR',
    Xof: 'XOF',
    Xpf: 'XPF',
    Yer: 'YER',
    Zar: 'ZAR',
    Zmw: 'ZMW',
    Zwd: 'ZWD',
    Btc: 'BTC'
} as const;

export type PaymentTransactionProcessedCurrencyEnum = typeof PaymentTransactionProcessedCurrencyEnum[keyof typeof PaymentTransactionProcessedCurrencyEnum];
export const PaymentTransactionStatusEnum = {
    Success: 'SUCCESS',
    Unknown: 'UNKNOWN',
    Pending: 'PENDING',
    PaymentFailure: 'PAYMENT_FAILURE',
    PluginFailure: 'PLUGIN_FAILURE',
    PaymentSystemOff: 'PAYMENT_SYSTEM_OFF'
} as const;

export type PaymentTransactionStatusEnum = typeof PaymentTransactionStatusEnum[keyof typeof PaymentTransactionStatusEnum];

/**
 * 
 * @export
 * @interface Phase
 */
export interface Phase {
    /**
     * 
     * @type {string}
     * @memberof Phase
     */
    'type'?: string;
    /**
     * 
     * @type {Array<Price>}
     * @memberof Phase
     */
    'prices'?: Array<Price>;
    /**
     * 
     * @type {Array<Price>}
     * @memberof Phase
     */
    'fixedPrices'?: Array<Price>;
    /**
     * 
     * @type {Duration}
     * @memberof Phase
     */
    'duration'?: Duration;
    /**
     * 
     * @type {Array<Usage>}
     * @memberof Phase
     */
    'usages'?: Array<Usage>;
}
/**
 * 
 * @export
 * @interface PhasePrice
 */
export interface PhasePrice {
    /**
     * 
     * @type {string}
     * @memberof PhasePrice
     */
    'planName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PhasePrice
     */
    'phaseName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PhasePrice
     */
    'phaseType'?: string;
    /**
     * 
     * @type {number}
     * @memberof PhasePrice
     */
    'fixedPrice'?: number;
    /**
     * 
     * @type {number}
     * @memberof PhasePrice
     */
    'recurringPrice'?: number;
    /**
     * 
     * @type {Array<UsagePrice>}
     * @memberof PhasePrice
     */
    'usagePrices'?: Array<UsagePrice>;
}
/**
 * 
 * @export
 * @interface Plan
 */
export interface Plan {
    /**
     * 
     * @type {string}
     * @memberof Plan
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Plan
     */
    'prettyName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Plan
     */
    'recurringBillingMode'?: PlanRecurringBillingModeEnum;
    /**
     * 
     * @type {string}
     * @memberof Plan
     */
    'billingPeriod'?: PlanBillingPeriodEnum;
    /**
     * 
     * @type {Array<Phase>}
     * @memberof Plan
     */
    'phases'?: Array<Phase>;
}

export const PlanRecurringBillingModeEnum = {
    Advance: 'IN_ADVANCE',
    Arrear: 'IN_ARREAR'
} as const;

export type PlanRecurringBillingModeEnum = typeof PlanRecurringBillingModeEnum[keyof typeof PlanRecurringBillingModeEnum];
export const PlanBillingPeriodEnum = {
    Daily: 'DAILY',
    Weekly: 'WEEKLY',
    Biweekly: 'BIWEEKLY',
    ThirtyDays: 'THIRTY_DAYS',
    ThirtyOneDays: 'THIRTY_ONE_DAYS',
    SixtyDays: 'SIXTY_DAYS',
    NinetyDays: 'NINETY_DAYS',
    Monthly: 'MONTHLY',
    Bimestrial: 'BIMESTRIAL',
    Quarterly: 'QUARTERLY',
    Triannual: 'TRIANNUAL',
    Biannual: 'BIANNUAL',
    Annual: 'ANNUAL',
    Sesquiennial: 'SESQUIENNIAL',
    Biennial: 'BIENNIAL',
    Triennial: 'TRIENNIAL',
    NoBillingPeriod: 'NO_BILLING_PERIOD'
} as const;

export type PlanBillingPeriodEnum = typeof PlanBillingPeriodEnum[keyof typeof PlanBillingPeriodEnum];

/**
 * 
 * @export
 * @interface PlanDetail
 */
export interface PlanDetail {
    /**
     * 
     * @type {string}
     * @memberof PlanDetail
     */
    'product'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlanDetail
     */
    'plan'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlanDetail
     */
    'priceList'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlanDetail
     */
    'finalPhaseBillingPeriod'?: PlanDetailFinalPhaseBillingPeriodEnum;
    /**
     * 
     * @type {Array<Price>}
     * @memberof PlanDetail
     */
    'finalPhaseRecurringPrice'?: Array<Price>;
}

export const PlanDetailFinalPhaseBillingPeriodEnum = {
    Daily: 'DAILY',
    Weekly: 'WEEKLY',
    Biweekly: 'BIWEEKLY',
    ThirtyDays: 'THIRTY_DAYS',
    ThirtyOneDays: 'THIRTY_ONE_DAYS',
    SixtyDays: 'SIXTY_DAYS',
    NinetyDays: 'NINETY_DAYS',
    Monthly: 'MONTHLY',
    Bimestrial: 'BIMESTRIAL',
    Quarterly: 'QUARTERLY',
    Triannual: 'TRIANNUAL',
    Biannual: 'BIANNUAL',
    Annual: 'ANNUAL',
    Sesquiennial: 'SESQUIENNIAL',
    Biennial: 'BIENNIAL',
    Triennial: 'TRIENNIAL',
    NoBillingPeriod: 'NO_BILLING_PERIOD'
} as const;

export type PlanDetailFinalPhaseBillingPeriodEnum = typeof PlanDetailFinalPhaseBillingPeriodEnum[keyof typeof PlanDetailFinalPhaseBillingPeriodEnum];

/**
 * 
 * @export
 * @interface PluginInfo
 */
export interface PluginInfo {
    /**
     * 
     * @type {string}
     * @memberof PluginInfo
     */
    'bundleSymbolicName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PluginInfo
     */
    'pluginKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof PluginInfo
     */
    'pluginName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PluginInfo
     */
    'version'?: string;
    /**
     * 
     * @type {string}
     * @memberof PluginInfo
     */
    'state'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PluginInfo
     */
    'isSelectedForStart'?: boolean;
    /**
     * 
     * @type {Set<PluginServiceInfo>}
     * @memberof PluginInfo
     */
    'services'?: Set<PluginServiceInfo>;
}
/**
 * 
 * @export
 * @interface PluginProperty
 */
export interface PluginProperty {
    /**
     * 
     * @type {string}
     * @memberof PluginProperty
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof PluginProperty
     */
    'value'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PluginProperty
     */
    'isUpdatable'?: boolean;
}
/**
 * 
 * @export
 * @interface PluginServiceInfo
 */
export interface PluginServiceInfo {
    /**
     * 
     * @type {string}
     * @memberof PluginServiceInfo
     */
    'serviceTypeName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PluginServiceInfo
     */
    'registrationName'?: string;
}
/**
 * 
 * @export
 * @interface Price
 */
export interface Price {
    /**
     * 
     * @type {string}
     * @memberof Price
     */
    'currency'?: PriceCurrencyEnum;
    /**
     * 
     * @type {number}
     * @memberof Price
     */
    'value'?: number;
}

export const PriceCurrencyEnum = {
    Aed: 'AED',
    Afn: 'AFN',
    All: 'ALL',
    Amd: 'AMD',
    Ang: 'ANG',
    Aoa: 'AOA',
    Ars: 'ARS',
    Aud: 'AUD',
    Awg: 'AWG',
    Azn: 'AZN',
    Bam: 'BAM',
    Bbd: 'BBD',
    Bdt: 'BDT',
    Bgn: 'BGN',
    Bhd: 'BHD',
    Bif: 'BIF',
    Bmd: 'BMD',
    Bnd: 'BND',
    Bob: 'BOB',
    Brl: 'BRL',
    Bsd: 'BSD',
    Btn: 'BTN',
    Bwp: 'BWP',
    Byr: 'BYR',
    Bzd: 'BZD',
    Cad: 'CAD',
    Cdf: 'CDF',
    Chf: 'CHF',
    Clp: 'CLP',
    Cny: 'CNY',
    Cop: 'COP',
    Crc: 'CRC',
    Cuc: 'CUC',
    Cup: 'CUP',
    Cve: 'CVE',
    Czk: 'CZK',
    Djf: 'DJF',
    Dkk: 'DKK',
    Dop: 'DOP',
    Dzd: 'DZD',
    Egp: 'EGP',
    Ern: 'ERN',
    Etb: 'ETB',
    Eur: 'EUR',
    Fjd: 'FJD',
    Fkp: 'FKP',
    Gbp: 'GBP',
    Gel: 'GEL',
    Ggp: 'GGP',
    Ghs: 'GHS',
    Gip: 'GIP',
    Gmd: 'GMD',
    Gnf: 'GNF',
    Gtq: 'GTQ',
    Gyd: 'GYD',
    Hkd: 'HKD',
    Hnl: 'HNL',
    Hrk: 'HRK',
    Htg: 'HTG',
    Huf: 'HUF',
    Idr: 'IDR',
    Ils: 'ILS',
    Imp: 'IMP',
    Inr: 'INR',
    Iqd: 'IQD',
    Irr: 'IRR',
    Isk: 'ISK',
    Jep: 'JEP',
    Jmd: 'JMD',
    Jod: 'JOD',
    Jpy: 'JPY',
    Kes: 'KES',
    Kgs: 'KGS',
    Khr: 'KHR',
    Kmf: 'KMF',
    Kpw: 'KPW',
    Krw: 'KRW',
    Kwd: 'KWD',
    Kyd: 'KYD',
    Kzt: 'KZT',
    Lak: 'LAK',
    Lbp: 'LBP',
    Lkr: 'LKR',
    Lrd: 'LRD',
    Lsl: 'LSL',
    Ltl: 'LTL',
    Lvl: 'LVL',
    Lyd: 'LYD',
    Mad: 'MAD',
    Mdl: 'MDL',
    Mga: 'MGA',
    Mkd: 'MKD',
    Mmk: 'MMK',
    Mnt: 'MNT',
    Mop: 'MOP',
    Mro: 'MRO',
    Mur: 'MUR',
    Mvr: 'MVR',
    Mwk: 'MWK',
    Mxn: 'MXN',
    Myr: 'MYR',
    Mzn: 'MZN',
    Nad: 'NAD',
    Ngn: 'NGN',
    Nio: 'NIO',
    Nok: 'NOK',
    Npr: 'NPR',
    Nzd: 'NZD',
    Omr: 'OMR',
    Pab: 'PAB',
    Pen: 'PEN',
    Pgk: 'PGK',
    Php: 'PHP',
    Pkr: 'PKR',
    Pln: 'PLN',
    Pyg: 'PYG',
    Qar: 'QAR',
    Ron: 'RON',
    Rsd: 'RSD',
    Rub: 'RUB',
    Rwf: 'RWF',
    Sar: 'SAR',
    Sbd: 'SBD',
    Scr: 'SCR',
    Sdg: 'SDG',
    Sek: 'SEK',
    Sgd: 'SGD',
    Shp: 'SHP',
    Sll: 'SLL',
    Sos: 'SOS',
    Spl: 'SPL',
    Srd: 'SRD',
    Std: 'STD',
    Svc: 'SVC',
    Syp: 'SYP',
    Szl: 'SZL',
    Thb: 'THB',
    Tjs: 'TJS',
    Tmt: 'TMT',
    Tnd: 'TND',
    Top: 'TOP',
    Try: 'TRY',
    Ttd: 'TTD',
    Tvd: 'TVD',
    Twd: 'TWD',
    Tzs: 'TZS',
    Uah: 'UAH',
    Ugx: 'UGX',
    Usd: 'USD',
    Uyu: 'UYU',
    Uzs: 'UZS',
    Vef: 'VEF',
    Vnd: 'VND',
    Vuv: 'VUV',
    Wst: 'WST',
    Xaf: 'XAF',
    Xcd: 'XCD',
    Xdr: 'XDR',
    Xof: 'XOF',
    Xpf: 'XPF',
    Yer: 'YER',
    Zar: 'ZAR',
    Zmw: 'ZMW',
    Zwd: 'ZWD',
    Btc: 'BTC'
} as const;

export type PriceCurrencyEnum = typeof PriceCurrencyEnum[keyof typeof PriceCurrencyEnum];

/**
 * 
 * @export
 * @interface PriceList
 */
export interface PriceList {
    /**
     * 
     * @type {string}
     * @memberof PriceList
     */
    'name'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PriceList
     */
    'plans'?: Array<string>;
}
/**
 * 
 * @export
 * @interface Product
 */
export interface Product {
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'prettyName'?: string;
    /**
     * 
     * @type {Array<Plan>}
     * @memberof Product
     */
    'plans'?: Array<Plan>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Product
     */
    'included'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Product
     */
    'available'?: Array<string>;
}
/**
 * 
 * @export
 * @interface RoleDefinition
 */
export interface RoleDefinition {
    /**
     * 
     * @type {string}
     * @memberof RoleDefinition
     */
    'role': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof RoleDefinition
     */
    'permissions': Array<string>;
}
/**
 * 
 * @export
 * @interface RolledUpUnit
 */
export interface RolledUpUnit {
    /**
     * 
     * @type {string}
     * @memberof RolledUpUnit
     */
    'unitType'?: string;
    /**
     * 
     * @type {number}
     * @memberof RolledUpUnit
     */
    'amount'?: number;
}
/**
 * 
 * @export
 * @interface RolledUpUsage
 */
export interface RolledUpUsage {
    /**
     * 
     * @type {string}
     * @memberof RolledUpUsage
     */
    'subscriptionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof RolledUpUsage
     */
    'startDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof RolledUpUsage
     */
    'endDate'?: string;
    /**
     * 
     * @type {Array<RolledUpUnit>}
     * @memberof RolledUpUsage
     */
    'rolledUpUnits'?: Array<RolledUpUnit>;
}
/**
 * 
 * @export
 * @interface Session
 */
export interface Session {
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'startDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'lastAccessDate'?: string;
    /**
     * 
     * @type {number}
     * @memberof Session
     */
    'timeout'?: number;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'host'?: string;
}
/**
 * 
 * @export
 * @interface SimplePlan
 */
export interface SimplePlan {
    /**
     * 
     * @type {string}
     * @memberof SimplePlan
     */
    'planId'?: string;
    /**
     * 
     * @type {string}
     * @memberof SimplePlan
     */
    'productName'?: string;
    /**
     * 
     * @type {string}
     * @memberof SimplePlan
     */
    'productCategory'?: SimplePlanProductCategoryEnum;
    /**
     * 
     * @type {string}
     * @memberof SimplePlan
     */
    'currency'?: SimplePlanCurrencyEnum;
    /**
     * 
     * @type {number}
     * @memberof SimplePlan
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof SimplePlan
     */
    'billingPeriod'?: SimplePlanBillingPeriodEnum;
    /**
     * 
     * @type {number}
     * @memberof SimplePlan
     */
    'trialLength'?: number;
    /**
     * 
     * @type {string}
     * @memberof SimplePlan
     */
    'trialTimeUnit'?: SimplePlanTrialTimeUnitEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof SimplePlan
     */
    'availableBaseProducts'?: Array<string>;
}

export const SimplePlanProductCategoryEnum = {
    Base: 'BASE',
    AddOn: 'ADD_ON',
    Standalone: 'STANDALONE'
} as const;

export type SimplePlanProductCategoryEnum = typeof SimplePlanProductCategoryEnum[keyof typeof SimplePlanProductCategoryEnum];
export const SimplePlanCurrencyEnum = {
    Aed: 'AED',
    Afn: 'AFN',
    All: 'ALL',
    Amd: 'AMD',
    Ang: 'ANG',
    Aoa: 'AOA',
    Ars: 'ARS',
    Aud: 'AUD',
    Awg: 'AWG',
    Azn: 'AZN',
    Bam: 'BAM',
    Bbd: 'BBD',
    Bdt: 'BDT',
    Bgn: 'BGN',
    Bhd: 'BHD',
    Bif: 'BIF',
    Bmd: 'BMD',
    Bnd: 'BND',
    Bob: 'BOB',
    Brl: 'BRL',
    Bsd: 'BSD',
    Btn: 'BTN',
    Bwp: 'BWP',
    Byr: 'BYR',
    Bzd: 'BZD',
    Cad: 'CAD',
    Cdf: 'CDF',
    Chf: 'CHF',
    Clp: 'CLP',
    Cny: 'CNY',
    Cop: 'COP',
    Crc: 'CRC',
    Cuc: 'CUC',
    Cup: 'CUP',
    Cve: 'CVE',
    Czk: 'CZK',
    Djf: 'DJF',
    Dkk: 'DKK',
    Dop: 'DOP',
    Dzd: 'DZD',
    Egp: 'EGP',
    Ern: 'ERN',
    Etb: 'ETB',
    Eur: 'EUR',
    Fjd: 'FJD',
    Fkp: 'FKP',
    Gbp: 'GBP',
    Gel: 'GEL',
    Ggp: 'GGP',
    Ghs: 'GHS',
    Gip: 'GIP',
    Gmd: 'GMD',
    Gnf: 'GNF',
    Gtq: 'GTQ',
    Gyd: 'GYD',
    Hkd: 'HKD',
    Hnl: 'HNL',
    Hrk: 'HRK',
    Htg: 'HTG',
    Huf: 'HUF',
    Idr: 'IDR',
    Ils: 'ILS',
    Imp: 'IMP',
    Inr: 'INR',
    Iqd: 'IQD',
    Irr: 'IRR',
    Isk: 'ISK',
    Jep: 'JEP',
    Jmd: 'JMD',
    Jod: 'JOD',
    Jpy: 'JPY',
    Kes: 'KES',
    Kgs: 'KGS',
    Khr: 'KHR',
    Kmf: 'KMF',
    Kpw: 'KPW',
    Krw: 'KRW',
    Kwd: 'KWD',
    Kyd: 'KYD',
    Kzt: 'KZT',
    Lak: 'LAK',
    Lbp: 'LBP',
    Lkr: 'LKR',
    Lrd: 'LRD',
    Lsl: 'LSL',
    Ltl: 'LTL',
    Lvl: 'LVL',
    Lyd: 'LYD',
    Mad: 'MAD',
    Mdl: 'MDL',
    Mga: 'MGA',
    Mkd: 'MKD',
    Mmk: 'MMK',
    Mnt: 'MNT',
    Mop: 'MOP',
    Mro: 'MRO',
    Mur: 'MUR',
    Mvr: 'MVR',
    Mwk: 'MWK',
    Mxn: 'MXN',
    Myr: 'MYR',
    Mzn: 'MZN',
    Nad: 'NAD',
    Ngn: 'NGN',
    Nio: 'NIO',
    Nok: 'NOK',
    Npr: 'NPR',
    Nzd: 'NZD',
    Omr: 'OMR',
    Pab: 'PAB',
    Pen: 'PEN',
    Pgk: 'PGK',
    Php: 'PHP',
    Pkr: 'PKR',
    Pln: 'PLN',
    Pyg: 'PYG',
    Qar: 'QAR',
    Ron: 'RON',
    Rsd: 'RSD',
    Rub: 'RUB',
    Rwf: 'RWF',
    Sar: 'SAR',
    Sbd: 'SBD',
    Scr: 'SCR',
    Sdg: 'SDG',
    Sek: 'SEK',
    Sgd: 'SGD',
    Shp: 'SHP',
    Sll: 'SLL',
    Sos: 'SOS',
    Spl: 'SPL',
    Srd: 'SRD',
    Std: 'STD',
    Svc: 'SVC',
    Syp: 'SYP',
    Szl: 'SZL',
    Thb: 'THB',
    Tjs: 'TJS',
    Tmt: 'TMT',
    Tnd: 'TND',
    Top: 'TOP',
    Try: 'TRY',
    Ttd: 'TTD',
    Tvd: 'TVD',
    Twd: 'TWD',
    Tzs: 'TZS',
    Uah: 'UAH',
    Ugx: 'UGX',
    Usd: 'USD',
    Uyu: 'UYU',
    Uzs: 'UZS',
    Vef: 'VEF',
    Vnd: 'VND',
    Vuv: 'VUV',
    Wst: 'WST',
    Xaf: 'XAF',
    Xcd: 'XCD',
    Xdr: 'XDR',
    Xof: 'XOF',
    Xpf: 'XPF',
    Yer: 'YER',
    Zar: 'ZAR',
    Zmw: 'ZMW',
    Zwd: 'ZWD',
    Btc: 'BTC'
} as const;

export type SimplePlanCurrencyEnum = typeof SimplePlanCurrencyEnum[keyof typeof SimplePlanCurrencyEnum];
export const SimplePlanBillingPeriodEnum = {
    Daily: 'DAILY',
    Weekly: 'WEEKLY',
    Biweekly: 'BIWEEKLY',
    ThirtyDays: 'THIRTY_DAYS',
    ThirtyOneDays: 'THIRTY_ONE_DAYS',
    SixtyDays: 'SIXTY_DAYS',
    NinetyDays: 'NINETY_DAYS',
    Monthly: 'MONTHLY',
    Bimestrial: 'BIMESTRIAL',
    Quarterly: 'QUARTERLY',
    Triannual: 'TRIANNUAL',
    Biannual: 'BIANNUAL',
    Annual: 'ANNUAL',
    Sesquiennial: 'SESQUIENNIAL',
    Biennial: 'BIENNIAL',
    Triennial: 'TRIENNIAL',
    NoBillingPeriod: 'NO_BILLING_PERIOD'
} as const;

export type SimplePlanBillingPeriodEnum = typeof SimplePlanBillingPeriodEnum[keyof typeof SimplePlanBillingPeriodEnum];
export const SimplePlanTrialTimeUnitEnum = {
    Days: 'DAYS',
    Weeks: 'WEEKS',
    Months: 'MONTHS',
    Years: 'YEARS',
    Unlimited: 'UNLIMITED'
} as const;

export type SimplePlanTrialTimeUnitEnum = typeof SimplePlanTrialTimeUnitEnum[keyof typeof SimplePlanTrialTimeUnitEnum];

/**
 * 
 * @export
 * @interface Subject
 */
export interface Subject {
    /**
     * 
     * @type {string}
     * @memberof Subject
     */
    'principal'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Subject
     */
    'isAuthenticated'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Subject
     */
    'isRemembered'?: boolean;
    /**
     * 
     * @type {Session}
     * @memberof Subject
     */
    'session'?: Session;
}
/**
 * 
 * @export
 * @interface Subscription
 */
export interface Subscription {
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    'accountId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    'bundleId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    'bundleExternalKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    'subscriptionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    'externalKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    'startDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    'productName': string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    'productCategory'?: SubscriptionProductCategoryEnum;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    'billingPeriod': SubscriptionBillingPeriodEnum;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    'phaseType'?: SubscriptionPhaseTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    'priceList': string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    'planName': string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    'state'?: SubscriptionStateEnum;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    'sourceType'?: SubscriptionSourceTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    'cancelledDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    'chargedThroughDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    'billingStartDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    'billingEndDate'?: string;
    /**
     * 
     * @type {number}
     * @memberof Subscription
     */
    'billCycleDayLocal'?: number;
    /**
     * 
     * @type {number}
     * @memberof Subscription
     */
    'quantity'?: number;
    /**
     * 
     * @type {Array<EventSubscription>}
     * @memberof Subscription
     */
    'events'?: Array<EventSubscription>;
    /**
     * 
     * @type {Array<PhasePrice>}
     * @memberof Subscription
     */
    'priceOverrides'?: Array<PhasePrice>;
    /**
     * 
     * @type {Array<PhasePrice>}
     * @memberof Subscription
     */
    'prices'?: Array<PhasePrice>;
    /**
     * 
     * @type {Array<AuditLog>}
     * @memberof Subscription
     */
    'auditLogs'?: Array<AuditLog>;
}

export const SubscriptionProductCategoryEnum = {
    Base: 'BASE',
    AddOn: 'ADD_ON',
    Standalone: 'STANDALONE'
} as const;

export type SubscriptionProductCategoryEnum = typeof SubscriptionProductCategoryEnum[keyof typeof SubscriptionProductCategoryEnum];
export const SubscriptionBillingPeriodEnum = {
    Daily: 'DAILY',
    Weekly: 'WEEKLY',
    Biweekly: 'BIWEEKLY',
    ThirtyDays: 'THIRTY_DAYS',
    ThirtyOneDays: 'THIRTY_ONE_DAYS',
    SixtyDays: 'SIXTY_DAYS',
    NinetyDays: 'NINETY_DAYS',
    Monthly: 'MONTHLY',
    Bimestrial: 'BIMESTRIAL',
    Quarterly: 'QUARTERLY',
    Triannual: 'TRIANNUAL',
    Biannual: 'BIANNUAL',
    Annual: 'ANNUAL',
    Sesquiennial: 'SESQUIENNIAL',
    Biennial: 'BIENNIAL',
    Triennial: 'TRIENNIAL',
    NoBillingPeriod: 'NO_BILLING_PERIOD'
} as const;

export type SubscriptionBillingPeriodEnum = typeof SubscriptionBillingPeriodEnum[keyof typeof SubscriptionBillingPeriodEnum];
export const SubscriptionPhaseTypeEnum = {
    Trial: 'TRIAL',
    Discount: 'DISCOUNT',
    Fixedterm: 'FIXEDTERM',
    Evergreen: 'EVERGREEN'
} as const;

export type SubscriptionPhaseTypeEnum = typeof SubscriptionPhaseTypeEnum[keyof typeof SubscriptionPhaseTypeEnum];
export const SubscriptionStateEnum = {
    Pending: 'PENDING',
    Active: 'ACTIVE',
    Blocked: 'BLOCKED',
    Cancelled: 'CANCELLED',
    Expired: 'EXPIRED'
} as const;

export type SubscriptionStateEnum = typeof SubscriptionStateEnum[keyof typeof SubscriptionStateEnum];
export const SubscriptionSourceTypeEnum = {
    Native: 'NATIVE',
    Migrated: 'MIGRATED',
    Transferred: 'TRANSFERRED'
} as const;

export type SubscriptionSourceTypeEnum = typeof SubscriptionSourceTypeEnum[keyof typeof SubscriptionSourceTypeEnum];

/**
 * 
 * @export
 * @interface SubscriptionUsageRecord
 */
export interface SubscriptionUsageRecord {
    /**
     * 
     * @type {string}
     * @memberof SubscriptionUsageRecord
     */
    'subscriptionId': string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionUsageRecord
     */
    'trackingId'?: string;
    /**
     * 
     * @type {Array<UnitUsageRecord>}
     * @memberof SubscriptionUsageRecord
     */
    'unitUsageRecords': Array<UnitUsageRecord>;
}
/**
 * 
 * @export
 * @interface Tag
 */
export interface Tag {
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    'tagId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    'objectType'?: TagObjectTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    'objectId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    'tagDefinitionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    'tagDefinitionName'?: string;
    /**
     * 
     * @type {Array<AuditLog>}
     * @memberof Tag
     */
    'auditLogs'?: Array<AuditLog>;
}

export const TagObjectTypeEnum = {
    Account: 'ACCOUNT',
    AccountEmail: 'ACCOUNT_EMAIL',
    BlockingStates: 'BLOCKING_STATES',
    Bundle: 'BUNDLE',
    CustomField: 'CUSTOM_FIELD',
    Invoice: 'INVOICE',
    Payment: 'PAYMENT',
    Transaction: 'TRANSACTION',
    InvoiceItem: 'INVOICE_ITEM',
    InvoicePayment: 'INVOICE_PAYMENT',
    Subscription: 'SUBSCRIPTION',
    SubscriptionEvent: 'SUBSCRIPTION_EVENT',
    ServiceBroadcast: 'SERVICE_BROADCAST',
    PaymentAttempt: 'PAYMENT_ATTEMPT',
    PaymentMethod: 'PAYMENT_METHOD',
    Tag: 'TAG',
    TagDefinition: 'TAG_DEFINITION',
    Tenant: 'TENANT',
    TenantKvs: 'TENANT_KVS'
} as const;

export type TagObjectTypeEnum = typeof TagObjectTypeEnum[keyof typeof TagObjectTypeEnum];

/**
 * 
 * @export
 * @interface TagDefinition
 */
export interface TagDefinition {
    /**
     * 
     * @type {string}
     * @memberof TagDefinition
     */
    'id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TagDefinition
     */
    'isControlTag'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TagDefinition
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof TagDefinition
     */
    'description': string;
    /**
     * 
     * @type {Set<string>}
     * @memberof TagDefinition
     */
    'applicableObjectTypes'?: Set<TagDefinitionApplicableObjectTypesEnum>;
    /**
     * 
     * @type {Array<AuditLog>}
     * @memberof TagDefinition
     */
    'auditLogs'?: Array<AuditLog>;
}

export const TagDefinitionApplicableObjectTypesEnum = {
    Account: 'ACCOUNT',
    AccountEmail: 'ACCOUNT_EMAIL',
    BlockingStates: 'BLOCKING_STATES',
    Bundle: 'BUNDLE',
    CustomField: 'CUSTOM_FIELD',
    Invoice: 'INVOICE',
    Payment: 'PAYMENT',
    Transaction: 'TRANSACTION',
    InvoiceItem: 'INVOICE_ITEM',
    InvoicePayment: 'INVOICE_PAYMENT',
    Subscription: 'SUBSCRIPTION',
    SubscriptionEvent: 'SUBSCRIPTION_EVENT',
    ServiceBroadcast: 'SERVICE_BROADCAST',
    PaymentAttempt: 'PAYMENT_ATTEMPT',
    PaymentMethod: 'PAYMENT_METHOD',
    Tag: 'TAG',
    TagDefinition: 'TAG_DEFINITION',
    Tenant: 'TENANT',
    TenantKvs: 'TENANT_KVS'
} as const;

export type TagDefinitionApplicableObjectTypesEnum = typeof TagDefinitionApplicableObjectTypesEnum[keyof typeof TagDefinitionApplicableObjectTypesEnum];

/**
 * 
 * @export
 * @interface Tenant
 */
export interface Tenant {
    /**
     * 
     * @type {string}
     * @memberof Tenant
     */
    'tenantId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Tenant
     */
    'externalKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof Tenant
     */
    'apiKey': string;
    /**
     * 
     * @type {string}
     * @memberof Tenant
     */
    'apiSecret': string;
    /**
     * 
     * @type {Array<AuditLog>}
     * @memberof Tenant
     */
    'auditLogs'?: Array<AuditLog>;
}
/**
 * 
 * @export
 * @interface TenantKeyValue
 */
export interface TenantKeyValue {
    /**
     * 
     * @type {string}
     * @memberof TenantKeyValue
     */
    'key'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof TenantKeyValue
     */
    'values'?: Array<string>;
    /**
     * 
     * @type {Array<AuditLog>}
     * @memberof TenantKeyValue
     */
    'auditLogs'?: Array<AuditLog>;
}
/**
 * 
 * @export
 * @interface Tier
 */
export interface Tier {
    /**
     * 
     * @type {Array<Limit>}
     * @memberof Tier
     */
    'limits'?: Array<Limit>;
    /**
     * 
     * @type {Array<Price>}
     * @memberof Tier
     */
    'fixedPrice'?: Array<Price>;
    /**
     * 
     * @type {Array<Price>}
     * @memberof Tier
     */
    'recurringPrice'?: Array<Price>;
    /**
     * 
     * @type {Array<TieredBlock>}
     * @memberof Tier
     */
    'blocks'?: Array<TieredBlock>;
}
/**
 * 
 * @export
 * @interface TierPrice
 */
export interface TierPrice {
    /**
     * 
     * @type {Array<BlockPrice>}
     * @memberof TierPrice
     */
    'blockPrices'?: Array<BlockPrice>;
}
/**
 * 
 * @export
 * @interface TieredBlock
 */
export interface TieredBlock {
    /**
     * 
     * @type {string}
     * @memberof TieredBlock
     */
    'unit'?: string;
    /**
     * 
     * @type {string}
     * @memberof TieredBlock
     */
    'size'?: string;
    /**
     * 
     * @type {string}
     * @memberof TieredBlock
     */
    'max'?: string;
    /**
     * 
     * @type {Array<Price>}
     * @memberof TieredBlock
     */
    'prices'?: Array<Price>;
}
/**
 * 
 * @export
 * @interface Unit
 */
export interface Unit {
    /**
     * 
     * @type {string}
     * @memberof Unit
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Unit
     */
    'prettyName'?: string;
}
/**
 * 
 * @export
 * @interface UnitUsageRecord
 */
export interface UnitUsageRecord {
    /**
     * 
     * @type {string}
     * @memberof UnitUsageRecord
     */
    'unitType'?: string;
    /**
     * 
     * @type {Array<UsageRecord>}
     * @memberof UnitUsageRecord
     */
    'usageRecords'?: Array<UsageRecord>;
}
/**
 * 
 * @export
 * @interface Usage
 */
export interface Usage {
    /**
     * 
     * @type {string}
     * @memberof Usage
     */
    'billingPeriod'?: string;
    /**
     * 
     * @type {Array<Tier>}
     * @memberof Usage
     */
    'tiers'?: Array<Tier>;
}
/**
 * 
 * @export
 * @interface UsagePrice
 */
export interface UsagePrice {
    /**
     * 
     * @type {string}
     * @memberof UsagePrice
     */
    'usageName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsagePrice
     */
    'usageType'?: UsagePriceUsageTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof UsagePrice
     */
    'billingMode'?: UsagePriceBillingModeEnum;
    /**
     * 
     * @type {string}
     * @memberof UsagePrice
     */
    'tierBlockPolicy'?: UsagePriceTierBlockPolicyEnum;
    /**
     * 
     * @type {Array<TierPrice>}
     * @memberof UsagePrice
     */
    'tierPrices'?: Array<TierPrice>;
}

export const UsagePriceUsageTypeEnum = {
    Capacity: 'CAPACITY',
    Consumable: 'CONSUMABLE'
} as const;

export type UsagePriceUsageTypeEnum = typeof UsagePriceUsageTypeEnum[keyof typeof UsagePriceUsageTypeEnum];
export const UsagePriceBillingModeEnum = {
    Advance: 'IN_ADVANCE',
    Arrear: 'IN_ARREAR'
} as const;

export type UsagePriceBillingModeEnum = typeof UsagePriceBillingModeEnum[keyof typeof UsagePriceBillingModeEnum];
export const UsagePriceTierBlockPolicyEnum = {
    AllTiers: 'ALL_TIERS',
    TopTier: 'TOP_TIER'
} as const;

export type UsagePriceTierBlockPolicyEnum = typeof UsagePriceTierBlockPolicyEnum[keyof typeof UsagePriceTierBlockPolicyEnum];

/**
 * 
 * @export
 * @interface UsageRecord
 */
export interface UsageRecord {
    /**
     * 
     * @type {string}
     * @memberof UsageRecord
     */
    'recordDate'?: string;
    /**
     * 
     * @type {number}
     * @memberof UsageRecord
     */
    'amount'?: number;
}
/**
 * 
 * @export
 * @interface UserRoles
 */
export interface UserRoles {
    /**
     * 
     * @type {string}
     * @memberof UserRoles
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof UserRoles
     */
    'password': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserRoles
     */
    'roles': Array<string>;
}

/**
 * AccountApi - axios parameter creator
 * @export
 */
export const AccountApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Block an account
         * @param {BlockingState} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [requestedDate] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAccountBlockingState: async (body: BlockingState, accountId: string, xKillbillCreatedBy: string, requestedDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('addAccountBlockingState', 'body', body)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('addAccountBlockingState', 'accountId', accountId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('addAccountBlockingState', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/accounts/{accountId}/block`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (requestedDate !== undefined) {
                localVarQueryParameter['requestedDate'] = (requestedDate as any instanceof Date) ?
                    (requestedDate as any).toISOString().substr(0,10) :
                    requestedDate;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add account email
         * @param {AccountEmail} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addEmail: async (body: AccountEmail, accountId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('addEmail', 'body', body)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('addEmail', 'accountId', accountId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('addEmail', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/accounts/{accountId}/emails`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Close account
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [cancelAllSubscriptions] 
         * @param {boolean} [writeOffUnpaidInvoices] 
         * @param {boolean} [itemAdjustUnpaidInvoices] 
         * @param {boolean} [removeFutureNotifications] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        closeAccount: async (accountId: string, xKillbillCreatedBy: string, cancelAllSubscriptions?: boolean, writeOffUnpaidInvoices?: boolean, itemAdjustUnpaidInvoices?: boolean, removeFutureNotifications?: boolean, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('closeAccount', 'accountId', accountId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('closeAccount', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/accounts/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (cancelAllSubscriptions !== undefined) {
                localVarQueryParameter['cancelAllSubscriptions'] = cancelAllSubscriptions;
            }

            if (writeOffUnpaidInvoices !== undefined) {
                localVarQueryParameter['writeOffUnpaidInvoices'] = writeOffUnpaidInvoices;
            }

            if (itemAdjustUnpaidInvoices !== undefined) {
                localVarQueryParameter['itemAdjustUnpaidInvoices'] = itemAdjustUnpaidInvoices;
            }

            if (removeFutureNotifications !== undefined) {
                localVarQueryParameter['removeFutureNotifications'] = removeFutureNotifications;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create account
         * @param {Account} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccount: async (body: Account, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createAccount', 'body', body)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('createAccount', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add custom fields to account
         * @param {Array<CustomField>} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccountCustomFields: async (body: Array<CustomField>, accountId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createAccountCustomFields', 'body', body)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('createAccountCustomFields', 'accountId', accountId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('createAccountCustomFields', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/accounts/{accountId}/customFields`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add tags to account
         * @param {Array<string>} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccountTags: async (body: Array<string>, accountId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createAccountTags', 'body', body)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('createAccountTags', 'accountId', accountId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('createAccountTags', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/accounts/{accountId}/tags`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a payment method
         * @param {PaymentMethod} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [isDefault] 
         * @param {boolean} [payAllUnpaidInvoices] 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentMethod: async (body: PaymentMethod, accountId: string, xKillbillCreatedBy: string, isDefault?: boolean, payAllUnpaidInvoices?: boolean, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createPaymentMethod', 'body', body)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('createPaymentMethod', 'accountId', accountId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('createPaymentMethod', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/accounts/{accountId}/paymentMethods`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (isDefault !== undefined) {
                localVarQueryParameter['isDefault'] = isDefault;
            }

            if (payAllUnpaidInvoices !== undefined) {
                localVarQueryParameter['payAllUnpaidInvoices'] = payAllUnpaidInvoices;
            }

            if (controlPluginName) {
                localVarQueryParameter['controlPluginName'] = controlPluginName;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove custom fields from account
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [customField] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccountCustomFields: async (accountId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('deleteAccountCustomFields', 'accountId', accountId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('deleteAccountCustomFields', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/accounts/{accountId}/customFields`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (customField) {
                localVarQueryParameter['customField'] = customField;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove tags from account
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [tagDef] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccountTags: async (accountId: string, xKillbillCreatedBy: string, tagDef?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('deleteAccountTags', 'accountId', accountId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('deleteAccountTags', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/accounts/{accountId}/tags`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (tagDef) {
                localVarQueryParameter['tagDef'] = tagDef;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an account by id
         * @param {string} accountId 
         * @param {boolean} [accountWithBalance] 
         * @param {boolean} [accountWithBalanceAndCBA] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount: async (accountId: string, accountWithBalance?: boolean, accountWithBalanceAndCBA?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAccount', 'accountId', accountId)
            const localVarPath = `/1.0/kb/accounts/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (accountWithBalance !== undefined) {
                localVarQueryParameter['accountWithBalance'] = accountWithBalance;
            }

            if (accountWithBalanceAndCBA !== undefined) {
                localVarQueryParameter['accountWithBalanceAndCBA'] = accountWithBalanceAndCBA;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve audit logs by account id
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountAuditLogs: async (accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAccountAuditLogs', 'accountId', accountId)
            const localVarPath = `/1.0/kb/accounts/{accountId}/auditLogs`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve account audit logs with history by account id
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountAuditLogsWithHistory: async (accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAccountAuditLogsWithHistory', 'accountId', accountId)
            const localVarPath = `/1.0/kb/accounts/{accountId}/auditLogsWithHistory`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve bundles for account
         * @param {string} accountId 
         * @param {string} [externalKey] 
         * @param {string} [bundlesFilter] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountBundles: async (accountId: string, externalKey?: string, bundlesFilter?: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAccountBundles', 'accountId', accountId)
            const localVarPath = `/1.0/kb/accounts/{accountId}/bundles`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (externalKey !== undefined) {
                localVarQueryParameter['externalKey'] = externalKey;
            }

            if (bundlesFilter !== undefined) {
                localVarQueryParameter['bundlesFilter'] = bundlesFilter;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve paginated bundles for account
         * @param {string} accountId 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountBundlesPaginated: async (accountId: string, offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAccountBundlesPaginated', 'accountId', accountId)
            const localVarPath = `/1.0/kb/accounts/{accountId}/bundles/pagination`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an account by external key
         * @param {string} externalKey 
         * @param {boolean} [accountWithBalance] 
         * @param {boolean} [accountWithBalanceAndCBA] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountByKey: async (externalKey: string, accountWithBalance?: boolean, accountWithBalanceAndCBA?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'externalKey' is not null or undefined
            assertParamExists('getAccountByKey', 'externalKey', externalKey)
            const localVarPath = `/1.0/kb/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (externalKey !== undefined) {
                localVarQueryParameter['externalKey'] = externalKey;
            }

            if (accountWithBalance !== undefined) {
                localVarQueryParameter['accountWithBalance'] = accountWithBalance;
            }

            if (accountWithBalanceAndCBA !== undefined) {
                localVarQueryParameter['accountWithBalanceAndCBA'] = accountWithBalanceAndCBA;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve account custom fields
         * @param {string} accountId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountCustomFields: async (accountId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAccountCustomFields', 'accountId', accountId)
            const localVarPath = `/1.0/kb/accounts/{accountId}/customFields`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve account email audit logs with history by id
         * @param {string} accountId 
         * @param {string} accountEmailId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountEmailAuditLogsWithHistory: async (accountId: string, accountEmailId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAccountEmailAuditLogsWithHistory', 'accountId', accountId)
            // verify required parameter 'accountEmailId' is not null or undefined
            assertParamExists('getAccountEmailAuditLogsWithHistory', 'accountEmailId', accountEmailId)
            const localVarPath = `/1.0/kb/accounts/{accountId}/emails/{accountEmailId}/auditLogsWithHistory`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"accountEmailId"}}`, encodeURIComponent(String(accountEmailId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve account tags
         * @param {string} accountId 
         * @param {boolean} [includedDeleted] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountTags: async (accountId: string, includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAccountTags', 'accountId', accountId)
            const localVarPath = `/1.0/kb/accounts/{accountId}/tags`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (includedDeleted !== undefined) {
                localVarQueryParameter['includedDeleted'] = includedDeleted;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve account timeline
         * @param {string} accountId 
         * @param {boolean} [parallel] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountTimeline: async (accountId: string, parallel?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAccountTimeline', 'accountId', accountId)
            const localVarPath = `/1.0/kb/accounts/{accountId}/timeline`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (parallel !== undefined) {
                localVarQueryParameter['parallel'] = parallel;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List accounts
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {boolean} [accountWithBalance] 
         * @param {boolean} [accountWithBalanceAndCBA] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccounts: async (offset?: number, limit?: number, accountWithBalance?: boolean, accountWithBalanceAndCBA?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/1.0/kb/accounts/pagination`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (accountWithBalance !== undefined) {
                localVarQueryParameter['accountWithBalance'] = accountWithBalance;
            }

            if (accountWithBalanceAndCBA !== undefined) {
                localVarQueryParameter['accountWithBalanceAndCBA'] = accountWithBalanceAndCBA;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve account customFields
         * @param {string} accountId 
         * @param {'ACCOUNT' | 'ACCOUNT_EMAIL' | 'BLOCKING_STATES' | 'BUNDLE' | 'CUSTOM_FIELD' | 'INVOICE' | 'PAYMENT' | 'TRANSACTION' | 'INVOICE_ITEM' | 'INVOICE_PAYMENT' | 'SUBSCRIPTION' | 'SUBSCRIPTION_EVENT' | 'SERVICE_BROADCAST' | 'PAYMENT_ATTEMPT' | 'PAYMENT_METHOD' | 'TAG' | 'TAG_DEFINITION' | 'TENANT' | 'TENANT_KVS'} [objectType] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCustomFields: async (accountId: string, objectType?: 'ACCOUNT' | 'ACCOUNT_EMAIL' | 'BLOCKING_STATES' | 'BUNDLE' | 'CUSTOM_FIELD' | 'INVOICE' | 'PAYMENT' | 'TRANSACTION' | 'INVOICE_ITEM' | 'INVOICE_PAYMENT' | 'SUBSCRIPTION' | 'SUBSCRIPTION_EVENT' | 'SERVICE_BROADCAST' | 'PAYMENT_ATTEMPT' | 'PAYMENT_METHOD' | 'TAG' | 'TAG_DEFINITION' | 'TENANT' | 'TENANT_KVS', audit?: 'FULL' | 'MINIMAL' | 'NONE', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAllCustomFields', 'accountId', accountId)
            const localVarPath = `/1.0/kb/accounts/{accountId}/allCustomFields`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (objectType !== undefined) {
                localVarQueryParameter['objectType'] = objectType;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve account tags
         * @param {string} accountId 
         * @param {'ACCOUNT' | 'ACCOUNT_EMAIL' | 'BLOCKING_STATES' | 'BUNDLE' | 'CUSTOM_FIELD' | 'INVOICE' | 'PAYMENT' | 'TRANSACTION' | 'INVOICE_ITEM' | 'INVOICE_PAYMENT' | 'SUBSCRIPTION' | 'SUBSCRIPTION_EVENT' | 'SERVICE_BROADCAST' | 'PAYMENT_ATTEMPT' | 'PAYMENT_METHOD' | 'TAG' | 'TAG_DEFINITION' | 'TENANT' | 'TENANT_KVS'} [objectType] 
         * @param {boolean} [includedDeleted] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTags: async (accountId: string, objectType?: 'ACCOUNT' | 'ACCOUNT_EMAIL' | 'BLOCKING_STATES' | 'BUNDLE' | 'CUSTOM_FIELD' | 'INVOICE' | 'PAYMENT' | 'TRANSACTION' | 'INVOICE_ITEM' | 'INVOICE_PAYMENT' | 'SUBSCRIPTION' | 'SUBSCRIPTION_EVENT' | 'SERVICE_BROADCAST' | 'PAYMENT_ATTEMPT' | 'PAYMENT_METHOD' | 'TAG' | 'TAG_DEFINITION' | 'TENANT' | 'TENANT_KVS', includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAllTags', 'accountId', accountId)
            const localVarPath = `/1.0/kb/accounts/{accountId}/allTags`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (objectType !== undefined) {
                localVarQueryParameter['objectType'] = objectType;
            }

            if (includedDeleted !== undefined) {
                localVarQueryParameter['includedDeleted'] = includedDeleted;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve blocking state audit logs with history by id
         * @param {string} blockingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockingStateAuditLogsWithHistory: async (blockingId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'blockingId' is not null or undefined
            assertParamExists('getBlockingStateAuditLogsWithHistory', 'blockingId', blockingId)
            const localVarPath = `/1.0/kb/accounts/block/{blockingId}/auditLogsWithHistory`
                .replace(`{${"blockingId"}}`, encodeURIComponent(String(blockingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve blocking states for account
         * @param {string} accountId 
         * @param {Array<'SUBSCRIPTION' | 'SUBSCRIPTION_BUNDLE' | 'ACCOUNT'>} [blockingStateTypes] 
         * @param {Array<string>} [blockingStateSvcs] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockingStates: async (accountId: string, blockingStateTypes?: Array<'SUBSCRIPTION' | 'SUBSCRIPTION_BUNDLE' | 'ACCOUNT'>, blockingStateSvcs?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getBlockingStates', 'accountId', accountId)
            const localVarPath = `/1.0/kb/accounts/{accountId}/block`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (blockingStateTypes) {
                localVarQueryParameter['blockingStateTypes'] = blockingStateTypes;
            }

            if (blockingStateSvcs) {
                localVarQueryParameter['blockingStateSvcs'] = blockingStateSvcs;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List children accounts
         * @param {string} accountId 
         * @param {boolean} [accountWithBalance] 
         * @param {boolean} [accountWithBalanceAndCBA] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChildrenAccounts: async (accountId: string, accountWithBalance?: boolean, accountWithBalanceAndCBA?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getChildrenAccounts', 'accountId', accountId)
            const localVarPath = `/1.0/kb/accounts/{accountId}/children`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (accountWithBalance !== undefined) {
                localVarQueryParameter['accountWithBalance'] = accountWithBalance;
            }

            if (accountWithBalanceAndCBA !== undefined) {
                localVarQueryParameter['accountWithBalanceAndCBA'] = accountWithBalanceAndCBA;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an account emails
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmails: async (accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getEmails', 'accountId', accountId)
            const localVarPath = `/1.0/kb/accounts/{accountId}/emails`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve account invoice payments
         * @param {string} accountId 
         * @param {boolean} [withPluginInfo] 
         * @param {boolean} [withAttempts] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoicePayments: async (accountId: string, withPluginInfo?: boolean, withAttempts?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getInvoicePayments', 'accountId', accountId)
            const localVarPath = `/1.0/kb/accounts/{accountId}/invoicePayments`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (withPluginInfo !== undefined) {
                localVarQueryParameter['withPluginInfo'] = withPluginInfo;
            }

            if (withAttempts !== undefined) {
                localVarQueryParameter['withAttempts'] = withAttempts;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve account invoices
         * @param {string} accountId 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {boolean} [withMigrationInvoices] 
         * @param {boolean} [unpaidInvoicesOnly] 
         * @param {boolean} [includeVoidedInvoices] 
         * @param {boolean} [includeInvoiceComponents] 
         * @param {string} [invoicesFilter] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoicesForAccount: async (accountId: string, startDate?: string, endDate?: string, withMigrationInvoices?: boolean, unpaidInvoicesOnly?: boolean, includeVoidedInvoices?: boolean, includeInvoiceComponents?: boolean, invoicesFilter?: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getInvoicesForAccount', 'accountId', accountId)
            const localVarPath = `/1.0/kb/accounts/{accountId}/invoices`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString().substr(0,10) :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString().substr(0,10) :
                    endDate;
            }

            if (withMigrationInvoices !== undefined) {
                localVarQueryParameter['withMigrationInvoices'] = withMigrationInvoices;
            }

            if (unpaidInvoicesOnly !== undefined) {
                localVarQueryParameter['unpaidInvoicesOnly'] = unpaidInvoicesOnly;
            }

            if (includeVoidedInvoices !== undefined) {
                localVarQueryParameter['includeVoidedInvoices'] = includeVoidedInvoices;
            }

            if (includeInvoiceComponents !== undefined) {
                localVarQueryParameter['includeInvoiceComponents'] = includeInvoiceComponents;
            }

            if (invoicesFilter !== undefined) {
                localVarQueryParameter['invoicesFilter'] = invoicesFilter;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve paginated invoices for account
         * @param {string} accountId 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoicesForAccountPaginated: async (accountId: string, offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getInvoicesForAccountPaginated', 'accountId', accountId)
            const localVarPath = `/1.0/kb/accounts/{accountId}/invoices/pagination`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve overdue state for account
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOverdueAccount: async (accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getOverdueAccount', 'accountId', accountId)
            const localVarPath = `/1.0/kb/accounts/{accountId}/overdue`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve account payment methods
         * @param {string} accountId 
         * @param {boolean} [withPluginInfo] 
         * @param {boolean} [includedDeleted] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethodsForAccount: async (accountId: string, withPluginInfo?: boolean, includedDeleted?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getPaymentMethodsForAccount', 'accountId', accountId)
            const localVarPath = `/1.0/kb/accounts/{accountId}/paymentMethods`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (withPluginInfo !== undefined) {
                localVarQueryParameter['withPluginInfo'] = withPluginInfo;
            }

            if (includedDeleted !== undefined) {
                localVarQueryParameter['includedDeleted'] = includedDeleted;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve account payments
         * @param {string} accountId 
         * @param {boolean} [withAttempts] 
         * @param {boolean} [withPluginInfo] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentsForAccount: async (accountId: string, withAttempts?: boolean, withPluginInfo?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getPaymentsForAccount', 'accountId', accountId)
            const localVarPath = `/1.0/kb/accounts/{accountId}/payments`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (withAttempts !== undefined) {
                localVarQueryParameter['withAttempts'] = withAttempts;
            }

            if (withPluginInfo !== undefined) {
                localVarQueryParameter['withPluginInfo'] = withPluginInfo;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modify custom fields to account
         * @param {Array<CustomField>} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyAccountCustomFields: async (body: Array<CustomField>, accountId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('modifyAccountCustomFields', 'body', body)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('modifyAccountCustomFields', 'accountId', accountId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('modifyAccountCustomFields', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/accounts/{accountId}/customFields`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Trigger a payment for all unpaid invoices
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [paymentMethodId] 
         * @param {boolean} [externalPayment] 
         * @param {number} [paymentAmount] 
         * @param {string} [targetDate] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payAllInvoices: async (accountId: string, xKillbillCreatedBy: string, paymentMethodId?: string, externalPayment?: boolean, paymentAmount?: number, targetDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('payAllInvoices', 'accountId', accountId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('payAllInvoices', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/accounts/{accountId}/invoicePayments`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (paymentMethodId !== undefined) {
                localVarQueryParameter['paymentMethodId'] = paymentMethodId;
            }

            if (externalPayment !== undefined) {
                localVarQueryParameter['externalPayment'] = externalPayment;
            }

            if (paymentAmount !== undefined) {
                localVarQueryParameter['paymentAmount'] = paymentAmount;
            }

            if (targetDate !== undefined) {
                localVarQueryParameter['targetDate'] = (targetDate as any instanceof Date) ?
                    (targetDate as any).toISOString().substr(0,10) :
                    targetDate;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Trigger a payment (authorization, purchase or credit)
         * @param {PaymentTransaction} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [paymentMethodId] 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processPayment: async (body: PaymentTransaction, accountId: string, xKillbillCreatedBy: string, paymentMethodId?: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('processPayment', 'body', body)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('processPayment', 'accountId', accountId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('processPayment', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/accounts/{accountId}/payments`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (paymentMethodId !== undefined) {
                localVarQueryParameter['paymentMethodId'] = paymentMethodId;
            }

            if (controlPluginName) {
                localVarQueryParameter['controlPluginName'] = controlPluginName;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Trigger a payment using the account external key (authorization, purchase or credit)
         * @param {PaymentTransaction} body 
         * @param {string} externalKey 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [paymentMethodId] 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processPaymentByExternalKey: async (body: PaymentTransaction, externalKey: string, xKillbillCreatedBy: string, paymentMethodId?: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('processPaymentByExternalKey', 'body', body)
            // verify required parameter 'externalKey' is not null or undefined
            assertParamExists('processPaymentByExternalKey', 'externalKey', externalKey)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('processPaymentByExternalKey', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/accounts/payments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (externalKey !== undefined) {
                localVarQueryParameter['externalKey'] = externalKey;
            }

            if (paymentMethodId !== undefined) {
                localVarQueryParameter['paymentMethodId'] = paymentMethodId;
            }

            if (controlPluginName) {
                localVarQueryParameter['controlPluginName'] = controlPluginName;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Rebalance account CBA
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rebalanceExistingCBAOnAccount: async (accountId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('rebalanceExistingCBAOnAccount', 'accountId', accountId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('rebalanceExistingCBAOnAccount', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/accounts/{accountId}/cbaRebalancing`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Refresh account payment methods
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [pluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshPaymentMethods: async (accountId: string, xKillbillCreatedBy: string, pluginName?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('refreshPaymentMethods', 'accountId', accountId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('refreshPaymentMethods', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/accounts/{accountId}/paymentMethods/refresh`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (pluginName !== undefined) {
                localVarQueryParameter['pluginName'] = pluginName;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete email from account
         * @param {string} accountId 
         * @param {string} email 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeEmail: async (accountId: string, email: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('removeEmail', 'accountId', accountId)
            // verify required parameter 'email' is not null or undefined
            assertParamExists('removeEmail', 'email', email)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('removeEmail', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/accounts/{accountId}/emails/{email}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"email"}}`, encodeURIComponent(String(email)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search accounts
         * @param {string} searchKey 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {boolean} [accountWithBalance] 
         * @param {boolean} [accountWithBalanceAndCBA] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchAccounts: async (searchKey: string, offset?: number, limit?: number, accountWithBalance?: boolean, accountWithBalanceAndCBA?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchKey' is not null or undefined
            assertParamExists('searchAccounts', 'searchKey', searchKey)
            const localVarPath = `/1.0/kb/accounts/search/{searchKey}`
                .replace(`{${"searchKey"}}`, encodeURIComponent(String(searchKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (accountWithBalance !== undefined) {
                localVarQueryParameter['accountWithBalance'] = accountWithBalance;
            }

            if (accountWithBalanceAndCBA !== undefined) {
                localVarQueryParameter['accountWithBalanceAndCBA'] = accountWithBalanceAndCBA;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set the default payment method
         * @param {string} accountId 
         * @param {string} paymentMethodId 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [payAllUnpaidInvoices] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDefaultPaymentMethod: async (accountId: string, paymentMethodId: string, xKillbillCreatedBy: string, payAllUnpaidInvoices?: boolean, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('setDefaultPaymentMethod', 'accountId', accountId)
            // verify required parameter 'paymentMethodId' is not null or undefined
            assertParamExists('setDefaultPaymentMethod', 'paymentMethodId', paymentMethodId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('setDefaultPaymentMethod', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/accounts/{accountId}/paymentMethods/{paymentMethodId}/setDefault`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"paymentMethodId"}}`, encodeURIComponent(String(paymentMethodId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (payAllUnpaidInvoices !== undefined) {
                localVarQueryParameter['payAllUnpaidInvoices'] = payAllUnpaidInvoices;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Move a given child credit to the parent level
         * @param {string} childAccountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transferChildCreditToParent: async (childAccountId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'childAccountId' is not null or undefined
            assertParamExists('transferChildCreditToParent', 'childAccountId', childAccountId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('transferChildCreditToParent', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/accounts/{childAccountId}/transferCredit`
                .replace(`{${"childAccountId"}}`, encodeURIComponent(String(childAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update account
         * @param {Account} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [treatNullAsReset] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount: async (body: Account, accountId: string, xKillbillCreatedBy: string, treatNullAsReset?: boolean, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateAccount', 'body', body)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('updateAccount', 'accountId', accountId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('updateAccount', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/accounts/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (treatNullAsReset !== undefined) {
                localVarQueryParameter['treatNullAsReset'] = treatNullAsReset;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountApi - functional programming interface
 * @export
 */
export const AccountApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Block an account
         * @param {BlockingState} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [requestedDate] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addAccountBlockingState(body: BlockingState, accountId: string, xKillbillCreatedBy: string, requestedDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BlockingState>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addAccountBlockingState(body, accountId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add account email
         * @param {AccountEmail} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addEmail(body: AccountEmail, accountId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccountEmail>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addEmail(body, accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Close account
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [cancelAllSubscriptions] 
         * @param {boolean} [writeOffUnpaidInvoices] 
         * @param {boolean} [itemAdjustUnpaidInvoices] 
         * @param {boolean} [removeFutureNotifications] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async closeAccount(accountId: string, xKillbillCreatedBy: string, cancelAllSubscriptions?: boolean, writeOffUnpaidInvoices?: boolean, itemAdjustUnpaidInvoices?: boolean, removeFutureNotifications?: boolean, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.closeAccount(accountId, xKillbillCreatedBy, cancelAllSubscriptions, writeOffUnpaidInvoices, itemAdjustUnpaidInvoices, removeFutureNotifications, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create account
         * @param {Account} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAccount(body: Account, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAccount(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add custom fields to account
         * @param {Array<CustomField>} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAccountCustomFields(body: Array<CustomField>, accountId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CustomField>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAccountCustomFields(body, accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add tags to account
         * @param {Array<string>} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAccountTags(body: Array<string>, accountId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAccountTags(body, accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add a payment method
         * @param {PaymentMethod} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [isDefault] 
         * @param {boolean} [payAllUnpaidInvoices] 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPaymentMethod(body: PaymentMethod, accountId: string, xKillbillCreatedBy: string, isDefault?: boolean, payAllUnpaidInvoices?: boolean, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentMethod>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPaymentMethod(body, accountId, xKillbillCreatedBy, isDefault, payAllUnpaidInvoices, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove custom fields from account
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [customField] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAccountCustomFields(accountId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAccountCustomFields(accountId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove tags from account
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [tagDef] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAccountTags(accountId: string, xKillbillCreatedBy: string, tagDef?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAccountTags(accountId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve an account by id
         * @param {string} accountId 
         * @param {boolean} [accountWithBalance] 
         * @param {boolean} [accountWithBalanceAndCBA] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccount(accountId: string, accountWithBalance?: boolean, accountWithBalanceAndCBA?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccount(accountId, accountWithBalance, accountWithBalanceAndCBA, audit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve audit logs by account id
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountAuditLogs(accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AuditLog>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountAuditLogs(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve account audit logs with history by account id
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountAuditLogsWithHistory(accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AuditLog>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountAuditLogsWithHistory(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve bundles for account
         * @param {string} accountId 
         * @param {string} [externalKey] 
         * @param {string} [bundlesFilter] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountBundles(accountId: string, externalKey?: string, bundlesFilter?: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Bundle>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountBundles(accountId, externalKey, bundlesFilter, audit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve paginated bundles for account
         * @param {string} accountId 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountBundlesPaginated(accountId: string, offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Bundle>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountBundlesPaginated(accountId, offset, limit, audit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve an account by external key
         * @param {string} externalKey 
         * @param {boolean} [accountWithBalance] 
         * @param {boolean} [accountWithBalanceAndCBA] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountByKey(externalKey: string, accountWithBalance?: boolean, accountWithBalanceAndCBA?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountByKey(externalKey, accountWithBalance, accountWithBalanceAndCBA, audit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve account custom fields
         * @param {string} accountId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountCustomFields(accountId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CustomField>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountCustomFields(accountId, audit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve account email audit logs with history by id
         * @param {string} accountId 
         * @param {string} accountEmailId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountEmailAuditLogsWithHistory(accountId: string, accountEmailId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AuditLog>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountEmailAuditLogsWithHistory(accountId, accountEmailId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve account tags
         * @param {string} accountId 
         * @param {boolean} [includedDeleted] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountTags(accountId: string, includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountTags(accountId, includedDeleted, audit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve account timeline
         * @param {string} accountId 
         * @param {boolean} [parallel] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountTimeline(accountId: string, parallel?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountTimeline>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountTimeline(accountId, parallel, audit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List accounts
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {boolean} [accountWithBalance] 
         * @param {boolean} [accountWithBalanceAndCBA] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccounts(offset?: number, limit?: number, accountWithBalance?: boolean, accountWithBalanceAndCBA?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Account>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccounts(offset, limit, accountWithBalance, accountWithBalanceAndCBA, audit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve account customFields
         * @param {string} accountId 
         * @param {'ACCOUNT' | 'ACCOUNT_EMAIL' | 'BLOCKING_STATES' | 'BUNDLE' | 'CUSTOM_FIELD' | 'INVOICE' | 'PAYMENT' | 'TRANSACTION' | 'INVOICE_ITEM' | 'INVOICE_PAYMENT' | 'SUBSCRIPTION' | 'SUBSCRIPTION_EVENT' | 'SERVICE_BROADCAST' | 'PAYMENT_ATTEMPT' | 'PAYMENT_METHOD' | 'TAG' | 'TAG_DEFINITION' | 'TENANT' | 'TENANT_KVS'} [objectType] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllCustomFields(accountId: string, objectType?: 'ACCOUNT' | 'ACCOUNT_EMAIL' | 'BLOCKING_STATES' | 'BUNDLE' | 'CUSTOM_FIELD' | 'INVOICE' | 'PAYMENT' | 'TRANSACTION' | 'INVOICE_ITEM' | 'INVOICE_PAYMENT' | 'SUBSCRIPTION' | 'SUBSCRIPTION_EVENT' | 'SERVICE_BROADCAST' | 'PAYMENT_ATTEMPT' | 'PAYMENT_METHOD' | 'TAG' | 'TAG_DEFINITION' | 'TENANT' | 'TENANT_KVS', audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CustomField>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllCustomFields(accountId, objectType, audit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve account tags
         * @param {string} accountId 
         * @param {'ACCOUNT' | 'ACCOUNT_EMAIL' | 'BLOCKING_STATES' | 'BUNDLE' | 'CUSTOM_FIELD' | 'INVOICE' | 'PAYMENT' | 'TRANSACTION' | 'INVOICE_ITEM' | 'INVOICE_PAYMENT' | 'SUBSCRIPTION' | 'SUBSCRIPTION_EVENT' | 'SERVICE_BROADCAST' | 'PAYMENT_ATTEMPT' | 'PAYMENT_METHOD' | 'TAG' | 'TAG_DEFINITION' | 'TENANT' | 'TENANT_KVS'} [objectType] 
         * @param {boolean} [includedDeleted] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllTags(accountId: string, objectType?: 'ACCOUNT' | 'ACCOUNT_EMAIL' | 'BLOCKING_STATES' | 'BUNDLE' | 'CUSTOM_FIELD' | 'INVOICE' | 'PAYMENT' | 'TRANSACTION' | 'INVOICE_ITEM' | 'INVOICE_PAYMENT' | 'SUBSCRIPTION' | 'SUBSCRIPTION_EVENT' | 'SERVICE_BROADCAST' | 'PAYMENT_ATTEMPT' | 'PAYMENT_METHOD' | 'TAG' | 'TAG_DEFINITION' | 'TENANT' | 'TENANT_KVS', includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllTags(accountId, objectType, includedDeleted, audit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve blocking state audit logs with history by id
         * @param {string} blockingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlockingStateAuditLogsWithHistory(blockingId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AuditLog>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBlockingStateAuditLogsWithHistory(blockingId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve blocking states for account
         * @param {string} accountId 
         * @param {Array<'SUBSCRIPTION' | 'SUBSCRIPTION_BUNDLE' | 'ACCOUNT'>} [blockingStateTypes] 
         * @param {Array<string>} [blockingStateSvcs] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlockingStates(accountId: string, blockingStateTypes?: Array<'SUBSCRIPTION' | 'SUBSCRIPTION_BUNDLE' | 'ACCOUNT'>, blockingStateSvcs?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BlockingState>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBlockingStates(accountId, blockingStateTypes, blockingStateSvcs, audit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List children accounts
         * @param {string} accountId 
         * @param {boolean} [accountWithBalance] 
         * @param {boolean} [accountWithBalanceAndCBA] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChildrenAccounts(accountId: string, accountWithBalance?: boolean, accountWithBalanceAndCBA?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Account>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChildrenAccounts(accountId, accountWithBalance, accountWithBalanceAndCBA, audit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve an account emails
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEmails(accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccountEmail>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEmails(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve account invoice payments
         * @param {string} accountId 
         * @param {boolean} [withPluginInfo] 
         * @param {boolean} [withAttempts] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvoicePayments(accountId: string, withPluginInfo?: boolean, withAttempts?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InvoicePayment>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInvoicePayments(accountId, withPluginInfo, withAttempts, pluginProperty, audit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve account invoices
         * @param {string} accountId 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {boolean} [withMigrationInvoices] 
         * @param {boolean} [unpaidInvoicesOnly] 
         * @param {boolean} [includeVoidedInvoices] 
         * @param {boolean} [includeInvoiceComponents] 
         * @param {string} [invoicesFilter] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvoicesForAccount(accountId: string, startDate?: string, endDate?: string, withMigrationInvoices?: boolean, unpaidInvoicesOnly?: boolean, includeVoidedInvoices?: boolean, includeInvoiceComponents?: boolean, invoicesFilter?: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Invoice>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInvoicesForAccount(accountId, startDate, endDate, withMigrationInvoices, unpaidInvoicesOnly, includeVoidedInvoices, includeInvoiceComponents, invoicesFilter, audit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve paginated invoices for account
         * @param {string} accountId 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvoicesForAccountPaginated(accountId: string, offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Invoice>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInvoicesForAccountPaginated(accountId, offset, limit, audit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve overdue state for account
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOverdueAccount(accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OverdueState>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOverdueAccount(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve account payment methods
         * @param {string} accountId 
         * @param {boolean} [withPluginInfo] 
         * @param {boolean} [includedDeleted] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentMethodsForAccount(accountId: string, withPluginInfo?: boolean, includedDeleted?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PaymentMethod>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPaymentMethodsForAccount(accountId, withPluginInfo, includedDeleted, pluginProperty, audit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve account payments
         * @param {string} accountId 
         * @param {boolean} [withAttempts] 
         * @param {boolean} [withPluginInfo] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentsForAccount(accountId: string, withAttempts?: boolean, withPluginInfo?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Payment>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPaymentsForAccount(accountId, withAttempts, withPluginInfo, pluginProperty, audit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Modify custom fields to account
         * @param {Array<CustomField>} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyAccountCustomFields(body: Array<CustomField>, accountId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifyAccountCustomFields(body, accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Trigger a payment for all unpaid invoices
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [paymentMethodId] 
         * @param {boolean} [externalPayment] 
         * @param {number} [paymentAmount] 
         * @param {string} [targetDate] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payAllInvoices(accountId: string, xKillbillCreatedBy: string, paymentMethodId?: string, externalPayment?: boolean, paymentAmount?: number, targetDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Invoice>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payAllInvoices(accountId, xKillbillCreatedBy, paymentMethodId, externalPayment, paymentAmount, targetDate, pluginProperty, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Trigger a payment (authorization, purchase or credit)
         * @param {PaymentTransaction} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [paymentMethodId] 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async processPayment(body: PaymentTransaction, accountId: string, xKillbillCreatedBy: string, paymentMethodId?: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.processPayment(body, accountId, xKillbillCreatedBy, paymentMethodId, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Trigger a payment using the account external key (authorization, purchase or credit)
         * @param {PaymentTransaction} body 
         * @param {string} externalKey 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [paymentMethodId] 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async processPaymentByExternalKey(body: PaymentTransaction, externalKey: string, xKillbillCreatedBy: string, paymentMethodId?: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.processPaymentByExternalKey(body, externalKey, xKillbillCreatedBy, paymentMethodId, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Rebalance account CBA
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rebalanceExistingCBAOnAccount(accountId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rebalanceExistingCBAOnAccount(accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Refresh account payment methods
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [pluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshPaymentMethods(accountId: string, xKillbillCreatedBy: string, pluginName?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshPaymentMethods(accountId, xKillbillCreatedBy, pluginName, pluginProperty, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete email from account
         * @param {string} accountId 
         * @param {string} email 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeEmail(accountId: string, email: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeEmail(accountId, email, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Search accounts
         * @param {string} searchKey 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {boolean} [accountWithBalance] 
         * @param {boolean} [accountWithBalanceAndCBA] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchAccounts(searchKey: string, offset?: number, limit?: number, accountWithBalance?: boolean, accountWithBalanceAndCBA?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Account>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchAccounts(searchKey, offset, limit, accountWithBalance, accountWithBalanceAndCBA, audit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Set the default payment method
         * @param {string} accountId 
         * @param {string} paymentMethodId 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [payAllUnpaidInvoices] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setDefaultPaymentMethod(accountId: string, paymentMethodId: string, xKillbillCreatedBy: string, payAllUnpaidInvoices?: boolean, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setDefaultPaymentMethod(accountId, paymentMethodId, xKillbillCreatedBy, payAllUnpaidInvoices, pluginProperty, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Move a given child credit to the parent level
         * @param {string} childAccountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transferChildCreditToParent(childAccountId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transferChildCreditToParent(childAccountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update account
         * @param {Account} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [treatNullAsReset] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAccount(body: Account, accountId: string, xKillbillCreatedBy: string, treatNullAsReset?: boolean, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAccount(body, accountId, xKillbillCreatedBy, treatNullAsReset, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountApi - factory interface
 * @export
 */
export const AccountApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountApiFp(configuration)
    return {
        /**
         * 
         * @summary Block an account
         * @param {BlockingState} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [requestedDate] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAccountBlockingState(body: BlockingState, accountId: string, xKillbillCreatedBy: string, requestedDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Array<BlockingState>> {
            return localVarFp.addAccountBlockingState(body, accountId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add account email
         * @param {AccountEmail} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addEmail(body: AccountEmail, accountId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Array<AccountEmail>> {
            return localVarFp.addEmail(body, accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Close account
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [cancelAllSubscriptions] 
         * @param {boolean} [writeOffUnpaidInvoices] 
         * @param {boolean} [itemAdjustUnpaidInvoices] 
         * @param {boolean} [removeFutureNotifications] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        closeAccount(accountId: string, xKillbillCreatedBy: string, cancelAllSubscriptions?: boolean, writeOffUnpaidInvoices?: boolean, itemAdjustUnpaidInvoices?: boolean, removeFutureNotifications?: boolean, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.closeAccount(accountId, xKillbillCreatedBy, cancelAllSubscriptions, writeOffUnpaidInvoices, itemAdjustUnpaidInvoices, removeFutureNotifications, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create account
         * @param {Account} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccount(body: Account, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Account> {
            return localVarFp.createAccount(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add custom fields to account
         * @param {Array<CustomField>} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccountCustomFields(body: Array<CustomField>, accountId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Array<CustomField>> {
            return localVarFp.createAccountCustomFields(body, accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add tags to account
         * @param {Array<string>} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccountTags(body: Array<string>, accountId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.createAccountTags(body, accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a payment method
         * @param {PaymentMethod} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [isDefault] 
         * @param {boolean} [payAllUnpaidInvoices] 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentMethod(body: PaymentMethod, accountId: string, xKillbillCreatedBy: string, isDefault?: boolean, payAllUnpaidInvoices?: boolean, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<PaymentMethod> {
            return localVarFp.createPaymentMethod(body, accountId, xKillbillCreatedBy, isDefault, payAllUnpaidInvoices, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove custom fields from account
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [customField] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccountCustomFields(accountId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAccountCustomFields(accountId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove tags from account
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [tagDef] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccountTags(accountId: string, xKillbillCreatedBy: string, tagDef?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAccountTags(accountId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an account by id
         * @param {string} accountId 
         * @param {boolean} [accountWithBalance] 
         * @param {boolean} [accountWithBalanceAndCBA] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount(accountId: string, accountWithBalance?: boolean, accountWithBalanceAndCBA?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Account> {
            return localVarFp.getAccount(accountId, accountWithBalance, accountWithBalanceAndCBA, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve audit logs by account id
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountAuditLogs(accountId: string, options?: any): AxiosPromise<Array<AuditLog>> {
            return localVarFp.getAccountAuditLogs(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve account audit logs with history by account id
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountAuditLogsWithHistory(accountId: string, options?: any): AxiosPromise<Array<AuditLog>> {
            return localVarFp.getAccountAuditLogsWithHistory(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve bundles for account
         * @param {string} accountId 
         * @param {string} [externalKey] 
         * @param {string} [bundlesFilter] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountBundles(accountId: string, externalKey?: string, bundlesFilter?: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<Bundle>> {
            return localVarFp.getAccountBundles(accountId, externalKey, bundlesFilter, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve paginated bundles for account
         * @param {string} accountId 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountBundlesPaginated(accountId: string, offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<Bundle>> {
            return localVarFp.getAccountBundlesPaginated(accountId, offset, limit, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an account by external key
         * @param {string} externalKey 
         * @param {boolean} [accountWithBalance] 
         * @param {boolean} [accountWithBalanceAndCBA] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountByKey(externalKey: string, accountWithBalance?: boolean, accountWithBalanceAndCBA?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Account> {
            return localVarFp.getAccountByKey(externalKey, accountWithBalance, accountWithBalanceAndCBA, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve account custom fields
         * @param {string} accountId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountCustomFields(accountId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<CustomField>> {
            return localVarFp.getAccountCustomFields(accountId, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve account email audit logs with history by id
         * @param {string} accountId 
         * @param {string} accountEmailId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountEmailAuditLogsWithHistory(accountId: string, accountEmailId: string, options?: any): AxiosPromise<Array<AuditLog>> {
            return localVarFp.getAccountEmailAuditLogsWithHistory(accountId, accountEmailId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve account tags
         * @param {string} accountId 
         * @param {boolean} [includedDeleted] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountTags(accountId: string, includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.getAccountTags(accountId, includedDeleted, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve account timeline
         * @param {string} accountId 
         * @param {boolean} [parallel] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountTimeline(accountId: string, parallel?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<AccountTimeline> {
            return localVarFp.getAccountTimeline(accountId, parallel, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List accounts
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {boolean} [accountWithBalance] 
         * @param {boolean} [accountWithBalanceAndCBA] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccounts(offset?: number, limit?: number, accountWithBalance?: boolean, accountWithBalanceAndCBA?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<Account>> {
            return localVarFp.getAccounts(offset, limit, accountWithBalance, accountWithBalanceAndCBA, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve account customFields
         * @param {string} accountId 
         * @param {'ACCOUNT' | 'ACCOUNT_EMAIL' | 'BLOCKING_STATES' | 'BUNDLE' | 'CUSTOM_FIELD' | 'INVOICE' | 'PAYMENT' | 'TRANSACTION' | 'INVOICE_ITEM' | 'INVOICE_PAYMENT' | 'SUBSCRIPTION' | 'SUBSCRIPTION_EVENT' | 'SERVICE_BROADCAST' | 'PAYMENT_ATTEMPT' | 'PAYMENT_METHOD' | 'TAG' | 'TAG_DEFINITION' | 'TENANT' | 'TENANT_KVS'} [objectType] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCustomFields(accountId: string, objectType?: 'ACCOUNT' | 'ACCOUNT_EMAIL' | 'BLOCKING_STATES' | 'BUNDLE' | 'CUSTOM_FIELD' | 'INVOICE' | 'PAYMENT' | 'TRANSACTION' | 'INVOICE_ITEM' | 'INVOICE_PAYMENT' | 'SUBSCRIPTION' | 'SUBSCRIPTION_EVENT' | 'SERVICE_BROADCAST' | 'PAYMENT_ATTEMPT' | 'PAYMENT_METHOD' | 'TAG' | 'TAG_DEFINITION' | 'TENANT' | 'TENANT_KVS', audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<CustomField>> {
            return localVarFp.getAllCustomFields(accountId, objectType, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve account tags
         * @param {string} accountId 
         * @param {'ACCOUNT' | 'ACCOUNT_EMAIL' | 'BLOCKING_STATES' | 'BUNDLE' | 'CUSTOM_FIELD' | 'INVOICE' | 'PAYMENT' | 'TRANSACTION' | 'INVOICE_ITEM' | 'INVOICE_PAYMENT' | 'SUBSCRIPTION' | 'SUBSCRIPTION_EVENT' | 'SERVICE_BROADCAST' | 'PAYMENT_ATTEMPT' | 'PAYMENT_METHOD' | 'TAG' | 'TAG_DEFINITION' | 'TENANT' | 'TENANT_KVS'} [objectType] 
         * @param {boolean} [includedDeleted] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTags(accountId: string, objectType?: 'ACCOUNT' | 'ACCOUNT_EMAIL' | 'BLOCKING_STATES' | 'BUNDLE' | 'CUSTOM_FIELD' | 'INVOICE' | 'PAYMENT' | 'TRANSACTION' | 'INVOICE_ITEM' | 'INVOICE_PAYMENT' | 'SUBSCRIPTION' | 'SUBSCRIPTION_EVENT' | 'SERVICE_BROADCAST' | 'PAYMENT_ATTEMPT' | 'PAYMENT_METHOD' | 'TAG' | 'TAG_DEFINITION' | 'TENANT' | 'TENANT_KVS', includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.getAllTags(accountId, objectType, includedDeleted, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve blocking state audit logs with history by id
         * @param {string} blockingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockingStateAuditLogsWithHistory(blockingId: string, options?: any): AxiosPromise<Array<AuditLog>> {
            return localVarFp.getBlockingStateAuditLogsWithHistory(blockingId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve blocking states for account
         * @param {string} accountId 
         * @param {Array<'SUBSCRIPTION' | 'SUBSCRIPTION_BUNDLE' | 'ACCOUNT'>} [blockingStateTypes] 
         * @param {Array<string>} [blockingStateSvcs] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockingStates(accountId: string, blockingStateTypes?: Array<'SUBSCRIPTION' | 'SUBSCRIPTION_BUNDLE' | 'ACCOUNT'>, blockingStateSvcs?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<BlockingState>> {
            return localVarFp.getBlockingStates(accountId, blockingStateTypes, blockingStateSvcs, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List children accounts
         * @param {string} accountId 
         * @param {boolean} [accountWithBalance] 
         * @param {boolean} [accountWithBalanceAndCBA] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChildrenAccounts(accountId: string, accountWithBalance?: boolean, accountWithBalanceAndCBA?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<Account>> {
            return localVarFp.getChildrenAccounts(accountId, accountWithBalance, accountWithBalanceAndCBA, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an account emails
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmails(accountId: string, options?: any): AxiosPromise<Array<AccountEmail>> {
            return localVarFp.getEmails(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve account invoice payments
         * @param {string} accountId 
         * @param {boolean} [withPluginInfo] 
         * @param {boolean} [withAttempts] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoicePayments(accountId: string, withPluginInfo?: boolean, withAttempts?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<InvoicePayment>> {
            return localVarFp.getInvoicePayments(accountId, withPluginInfo, withAttempts, pluginProperty, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve account invoices
         * @param {string} accountId 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {boolean} [withMigrationInvoices] 
         * @param {boolean} [unpaidInvoicesOnly] 
         * @param {boolean} [includeVoidedInvoices] 
         * @param {boolean} [includeInvoiceComponents] 
         * @param {string} [invoicesFilter] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoicesForAccount(accountId: string, startDate?: string, endDate?: string, withMigrationInvoices?: boolean, unpaidInvoicesOnly?: boolean, includeVoidedInvoices?: boolean, includeInvoiceComponents?: boolean, invoicesFilter?: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<Invoice>> {
            return localVarFp.getInvoicesForAccount(accountId, startDate, endDate, withMigrationInvoices, unpaidInvoicesOnly, includeVoidedInvoices, includeInvoiceComponents, invoicesFilter, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve paginated invoices for account
         * @param {string} accountId 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoicesForAccountPaginated(accountId: string, offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<Invoice>> {
            return localVarFp.getInvoicesForAccountPaginated(accountId, offset, limit, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve overdue state for account
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOverdueAccount(accountId: string, options?: any): AxiosPromise<OverdueState> {
            return localVarFp.getOverdueAccount(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve account payment methods
         * @param {string} accountId 
         * @param {boolean} [withPluginInfo] 
         * @param {boolean} [includedDeleted] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethodsForAccount(accountId: string, withPluginInfo?: boolean, includedDeleted?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<PaymentMethod>> {
            return localVarFp.getPaymentMethodsForAccount(accountId, withPluginInfo, includedDeleted, pluginProperty, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve account payments
         * @param {string} accountId 
         * @param {boolean} [withAttempts] 
         * @param {boolean} [withPluginInfo] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentsForAccount(accountId: string, withAttempts?: boolean, withPluginInfo?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<Payment>> {
            return localVarFp.getPaymentsForAccount(accountId, withAttempts, withPluginInfo, pluginProperty, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Modify custom fields to account
         * @param {Array<CustomField>} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyAccountCustomFields(body: Array<CustomField>, accountId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.modifyAccountCustomFields(body, accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Trigger a payment for all unpaid invoices
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [paymentMethodId] 
         * @param {boolean} [externalPayment] 
         * @param {number} [paymentAmount] 
         * @param {string} [targetDate] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payAllInvoices(accountId: string, xKillbillCreatedBy: string, paymentMethodId?: string, externalPayment?: boolean, paymentAmount?: number, targetDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Array<Invoice>> {
            return localVarFp.payAllInvoices(accountId, xKillbillCreatedBy, paymentMethodId, externalPayment, paymentAmount, targetDate, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Trigger a payment (authorization, purchase or credit)
         * @param {PaymentTransaction} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [paymentMethodId] 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processPayment(body: PaymentTransaction, accountId: string, xKillbillCreatedBy: string, paymentMethodId?: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Payment> {
            return localVarFp.processPayment(body, accountId, xKillbillCreatedBy, paymentMethodId, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Trigger a payment using the account external key (authorization, purchase or credit)
         * @param {PaymentTransaction} body 
         * @param {string} externalKey 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [paymentMethodId] 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processPaymentByExternalKey(body: PaymentTransaction, externalKey: string, xKillbillCreatedBy: string, paymentMethodId?: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Payment> {
            return localVarFp.processPaymentByExternalKey(body, externalKey, xKillbillCreatedBy, paymentMethodId, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Rebalance account CBA
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rebalanceExistingCBAOnAccount(accountId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.rebalanceExistingCBAOnAccount(accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Refresh account payment methods
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [pluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshPaymentMethods(accountId: string, xKillbillCreatedBy: string, pluginName?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.refreshPaymentMethods(accountId, xKillbillCreatedBy, pluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete email from account
         * @param {string} accountId 
         * @param {string} email 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeEmail(accountId: string, email: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeEmail(accountId, email, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search accounts
         * @param {string} searchKey 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {boolean} [accountWithBalance] 
         * @param {boolean} [accountWithBalanceAndCBA] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchAccounts(searchKey: string, offset?: number, limit?: number, accountWithBalance?: boolean, accountWithBalanceAndCBA?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<Account>> {
            return localVarFp.searchAccounts(searchKey, offset, limit, accountWithBalance, accountWithBalanceAndCBA, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set the default payment method
         * @param {string} accountId 
         * @param {string} paymentMethodId 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [payAllUnpaidInvoices] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDefaultPaymentMethod(accountId: string, paymentMethodId: string, xKillbillCreatedBy: string, payAllUnpaidInvoices?: boolean, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.setDefaultPaymentMethod(accountId, paymentMethodId, xKillbillCreatedBy, payAllUnpaidInvoices, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Move a given child credit to the parent level
         * @param {string} childAccountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transferChildCreditToParent(childAccountId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.transferChildCreditToParent(childAccountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update account
         * @param {Account} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [treatNullAsReset] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount(body: Account, accountId: string, xKillbillCreatedBy: string, treatNullAsReset?: boolean, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.updateAccount(body, accountId, xKillbillCreatedBy, treatNullAsReset, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountApi - object-oriented interface
 * @export
 * @class AccountApi
 * @extends {BaseAPI}
 */
export class AccountApi extends BaseAPI {
    /**
     * 
     * @summary Block an account
     * @param {BlockingState} body 
     * @param {string} accountId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [requestedDate] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public addAccountBlockingState(body: BlockingState, accountId: string, xKillbillCreatedBy: string, requestedDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).addAccountBlockingState(body, accountId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add account email
     * @param {AccountEmail} body 
     * @param {string} accountId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public addEmail(body: AccountEmail, accountId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).addEmail(body, accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Close account
     * @param {string} accountId 
     * @param {string} xKillbillCreatedBy 
     * @param {boolean} [cancelAllSubscriptions] 
     * @param {boolean} [writeOffUnpaidInvoices] 
     * @param {boolean} [itemAdjustUnpaidInvoices] 
     * @param {boolean} [removeFutureNotifications] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public closeAccount(accountId: string, xKillbillCreatedBy: string, cancelAllSubscriptions?: boolean, writeOffUnpaidInvoices?: boolean, itemAdjustUnpaidInvoices?: boolean, removeFutureNotifications?: boolean, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).closeAccount(accountId, xKillbillCreatedBy, cancelAllSubscriptions, writeOffUnpaidInvoices, itemAdjustUnpaidInvoices, removeFutureNotifications, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create account
     * @param {Account} body 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public createAccount(body: Account, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).createAccount(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add custom fields to account
     * @param {Array<CustomField>} body 
     * @param {string} accountId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public createAccountCustomFields(body: Array<CustomField>, accountId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).createAccountCustomFields(body, accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add tags to account
     * @param {Array<string>} body 
     * @param {string} accountId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public createAccountTags(body: Array<string>, accountId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).createAccountTags(body, accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a payment method
     * @param {PaymentMethod} body 
     * @param {string} accountId 
     * @param {string} xKillbillCreatedBy 
     * @param {boolean} [isDefault] 
     * @param {boolean} [payAllUnpaidInvoices] 
     * @param {Array<string>} [controlPluginName] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public createPaymentMethod(body: PaymentMethod, accountId: string, xKillbillCreatedBy: string, isDefault?: boolean, payAllUnpaidInvoices?: boolean, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).createPaymentMethod(body, accountId, xKillbillCreatedBy, isDefault, payAllUnpaidInvoices, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove custom fields from account
     * @param {string} accountId 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [customField] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public deleteAccountCustomFields(accountId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).deleteAccountCustomFields(accountId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove tags from account
     * @param {string} accountId 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [tagDef] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public deleteAccountTags(accountId: string, xKillbillCreatedBy: string, tagDef?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).deleteAccountTags(accountId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an account by id
     * @param {string} accountId 
     * @param {boolean} [accountWithBalance] 
     * @param {boolean} [accountWithBalanceAndCBA] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public getAccount(accountId: string, accountWithBalance?: boolean, accountWithBalanceAndCBA?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).getAccount(accountId, accountWithBalance, accountWithBalanceAndCBA, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve audit logs by account id
     * @param {string} accountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public getAccountAuditLogs(accountId: string, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).getAccountAuditLogs(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve account audit logs with history by account id
     * @param {string} accountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public getAccountAuditLogsWithHistory(accountId: string, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).getAccountAuditLogsWithHistory(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve bundles for account
     * @param {string} accountId 
     * @param {string} [externalKey] 
     * @param {string} [bundlesFilter] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public getAccountBundles(accountId: string, externalKey?: string, bundlesFilter?: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).getAccountBundles(accountId, externalKey, bundlesFilter, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve paginated bundles for account
     * @param {string} accountId 
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public getAccountBundlesPaginated(accountId: string, offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).getAccountBundlesPaginated(accountId, offset, limit, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an account by external key
     * @param {string} externalKey 
     * @param {boolean} [accountWithBalance] 
     * @param {boolean} [accountWithBalanceAndCBA] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public getAccountByKey(externalKey: string, accountWithBalance?: boolean, accountWithBalanceAndCBA?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).getAccountByKey(externalKey, accountWithBalance, accountWithBalanceAndCBA, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve account custom fields
     * @param {string} accountId 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public getAccountCustomFields(accountId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).getAccountCustomFields(accountId, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve account email audit logs with history by id
     * @param {string} accountId 
     * @param {string} accountEmailId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public getAccountEmailAuditLogsWithHistory(accountId: string, accountEmailId: string, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).getAccountEmailAuditLogsWithHistory(accountId, accountEmailId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve account tags
     * @param {string} accountId 
     * @param {boolean} [includedDeleted] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public getAccountTags(accountId: string, includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).getAccountTags(accountId, includedDeleted, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve account timeline
     * @param {string} accountId 
     * @param {boolean} [parallel] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public getAccountTimeline(accountId: string, parallel?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).getAccountTimeline(accountId, parallel, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List accounts
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {boolean} [accountWithBalance] 
     * @param {boolean} [accountWithBalanceAndCBA] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public getAccounts(offset?: number, limit?: number, accountWithBalance?: boolean, accountWithBalanceAndCBA?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).getAccounts(offset, limit, accountWithBalance, accountWithBalanceAndCBA, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve account customFields
     * @param {string} accountId 
     * @param {'ACCOUNT' | 'ACCOUNT_EMAIL' | 'BLOCKING_STATES' | 'BUNDLE' | 'CUSTOM_FIELD' | 'INVOICE' | 'PAYMENT' | 'TRANSACTION' | 'INVOICE_ITEM' | 'INVOICE_PAYMENT' | 'SUBSCRIPTION' | 'SUBSCRIPTION_EVENT' | 'SERVICE_BROADCAST' | 'PAYMENT_ATTEMPT' | 'PAYMENT_METHOD' | 'TAG' | 'TAG_DEFINITION' | 'TENANT' | 'TENANT_KVS'} [objectType] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public getAllCustomFields(accountId: string, objectType?: 'ACCOUNT' | 'ACCOUNT_EMAIL' | 'BLOCKING_STATES' | 'BUNDLE' | 'CUSTOM_FIELD' | 'INVOICE' | 'PAYMENT' | 'TRANSACTION' | 'INVOICE_ITEM' | 'INVOICE_PAYMENT' | 'SUBSCRIPTION' | 'SUBSCRIPTION_EVENT' | 'SERVICE_BROADCAST' | 'PAYMENT_ATTEMPT' | 'PAYMENT_METHOD' | 'TAG' | 'TAG_DEFINITION' | 'TENANT' | 'TENANT_KVS', audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).getAllCustomFields(accountId, objectType, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve account tags
     * @param {string} accountId 
     * @param {'ACCOUNT' | 'ACCOUNT_EMAIL' | 'BLOCKING_STATES' | 'BUNDLE' | 'CUSTOM_FIELD' | 'INVOICE' | 'PAYMENT' | 'TRANSACTION' | 'INVOICE_ITEM' | 'INVOICE_PAYMENT' | 'SUBSCRIPTION' | 'SUBSCRIPTION_EVENT' | 'SERVICE_BROADCAST' | 'PAYMENT_ATTEMPT' | 'PAYMENT_METHOD' | 'TAG' | 'TAG_DEFINITION' | 'TENANT' | 'TENANT_KVS'} [objectType] 
     * @param {boolean} [includedDeleted] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public getAllTags(accountId: string, objectType?: 'ACCOUNT' | 'ACCOUNT_EMAIL' | 'BLOCKING_STATES' | 'BUNDLE' | 'CUSTOM_FIELD' | 'INVOICE' | 'PAYMENT' | 'TRANSACTION' | 'INVOICE_ITEM' | 'INVOICE_PAYMENT' | 'SUBSCRIPTION' | 'SUBSCRIPTION_EVENT' | 'SERVICE_BROADCAST' | 'PAYMENT_ATTEMPT' | 'PAYMENT_METHOD' | 'TAG' | 'TAG_DEFINITION' | 'TENANT' | 'TENANT_KVS', includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).getAllTags(accountId, objectType, includedDeleted, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve blocking state audit logs with history by id
     * @param {string} blockingId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public getBlockingStateAuditLogsWithHistory(blockingId: string, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).getBlockingStateAuditLogsWithHistory(blockingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve blocking states for account
     * @param {string} accountId 
     * @param {Array<'SUBSCRIPTION' | 'SUBSCRIPTION_BUNDLE' | 'ACCOUNT'>} [blockingStateTypes] 
     * @param {Array<string>} [blockingStateSvcs] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public getBlockingStates(accountId: string, blockingStateTypes?: Array<'SUBSCRIPTION' | 'SUBSCRIPTION_BUNDLE' | 'ACCOUNT'>, blockingStateSvcs?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).getBlockingStates(accountId, blockingStateTypes, blockingStateSvcs, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List children accounts
     * @param {string} accountId 
     * @param {boolean} [accountWithBalance] 
     * @param {boolean} [accountWithBalanceAndCBA] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public getChildrenAccounts(accountId: string, accountWithBalance?: boolean, accountWithBalanceAndCBA?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).getChildrenAccounts(accountId, accountWithBalance, accountWithBalanceAndCBA, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an account emails
     * @param {string} accountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public getEmails(accountId: string, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).getEmails(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve account invoice payments
     * @param {string} accountId 
     * @param {boolean} [withPluginInfo] 
     * @param {boolean} [withAttempts] 
     * @param {Array<string>} [pluginProperty] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public getInvoicePayments(accountId: string, withPluginInfo?: boolean, withAttempts?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).getInvoicePayments(accountId, withPluginInfo, withAttempts, pluginProperty, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve account invoices
     * @param {string} accountId 
     * @param {string} [startDate] 
     * @param {string} [endDate] 
     * @param {boolean} [withMigrationInvoices] 
     * @param {boolean} [unpaidInvoicesOnly] 
     * @param {boolean} [includeVoidedInvoices] 
     * @param {boolean} [includeInvoiceComponents] 
     * @param {string} [invoicesFilter] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public getInvoicesForAccount(accountId: string, startDate?: string, endDate?: string, withMigrationInvoices?: boolean, unpaidInvoicesOnly?: boolean, includeVoidedInvoices?: boolean, includeInvoiceComponents?: boolean, invoicesFilter?: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).getInvoicesForAccount(accountId, startDate, endDate, withMigrationInvoices, unpaidInvoicesOnly, includeVoidedInvoices, includeInvoiceComponents, invoicesFilter, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve paginated invoices for account
     * @param {string} accountId 
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public getInvoicesForAccountPaginated(accountId: string, offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).getInvoicesForAccountPaginated(accountId, offset, limit, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve overdue state for account
     * @param {string} accountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public getOverdueAccount(accountId: string, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).getOverdueAccount(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve account payment methods
     * @param {string} accountId 
     * @param {boolean} [withPluginInfo] 
     * @param {boolean} [includedDeleted] 
     * @param {Array<string>} [pluginProperty] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public getPaymentMethodsForAccount(accountId: string, withPluginInfo?: boolean, includedDeleted?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).getPaymentMethodsForAccount(accountId, withPluginInfo, includedDeleted, pluginProperty, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve account payments
     * @param {string} accountId 
     * @param {boolean} [withAttempts] 
     * @param {boolean} [withPluginInfo] 
     * @param {Array<string>} [pluginProperty] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public getPaymentsForAccount(accountId: string, withAttempts?: boolean, withPluginInfo?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).getPaymentsForAccount(accountId, withAttempts, withPluginInfo, pluginProperty, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Modify custom fields to account
     * @param {Array<CustomField>} body 
     * @param {string} accountId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public modifyAccountCustomFields(body: Array<CustomField>, accountId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).modifyAccountCustomFields(body, accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Trigger a payment for all unpaid invoices
     * @param {string} accountId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [paymentMethodId] 
     * @param {boolean} [externalPayment] 
     * @param {number} [paymentAmount] 
     * @param {string} [targetDate] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public payAllInvoices(accountId: string, xKillbillCreatedBy: string, paymentMethodId?: string, externalPayment?: boolean, paymentAmount?: number, targetDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).payAllInvoices(accountId, xKillbillCreatedBy, paymentMethodId, externalPayment, paymentAmount, targetDate, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Trigger a payment (authorization, purchase or credit)
     * @param {PaymentTransaction} body 
     * @param {string} accountId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [paymentMethodId] 
     * @param {Array<string>} [controlPluginName] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public processPayment(body: PaymentTransaction, accountId: string, xKillbillCreatedBy: string, paymentMethodId?: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).processPayment(body, accountId, xKillbillCreatedBy, paymentMethodId, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Trigger a payment using the account external key (authorization, purchase or credit)
     * @param {PaymentTransaction} body 
     * @param {string} externalKey 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [paymentMethodId] 
     * @param {Array<string>} [controlPluginName] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public processPaymentByExternalKey(body: PaymentTransaction, externalKey: string, xKillbillCreatedBy: string, paymentMethodId?: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).processPaymentByExternalKey(body, externalKey, xKillbillCreatedBy, paymentMethodId, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Rebalance account CBA
     * @param {string} accountId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public rebalanceExistingCBAOnAccount(accountId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).rebalanceExistingCBAOnAccount(accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Refresh account payment methods
     * @param {string} accountId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [pluginName] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public refreshPaymentMethods(accountId: string, xKillbillCreatedBy: string, pluginName?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).refreshPaymentMethods(accountId, xKillbillCreatedBy, pluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete email from account
     * @param {string} accountId 
     * @param {string} email 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public removeEmail(accountId: string, email: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).removeEmail(accountId, email, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search accounts
     * @param {string} searchKey 
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {boolean} [accountWithBalance] 
     * @param {boolean} [accountWithBalanceAndCBA] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public searchAccounts(searchKey: string, offset?: number, limit?: number, accountWithBalance?: boolean, accountWithBalanceAndCBA?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).searchAccounts(searchKey, offset, limit, accountWithBalance, accountWithBalanceAndCBA, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set the default payment method
     * @param {string} accountId 
     * @param {string} paymentMethodId 
     * @param {string} xKillbillCreatedBy 
     * @param {boolean} [payAllUnpaidInvoices] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public setDefaultPaymentMethod(accountId: string, paymentMethodId: string, xKillbillCreatedBy: string, payAllUnpaidInvoices?: boolean, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).setDefaultPaymentMethod(accountId, paymentMethodId, xKillbillCreatedBy, payAllUnpaidInvoices, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Move a given child credit to the parent level
     * @param {string} childAccountId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public transferChildCreditToParent(childAccountId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).transferChildCreditToParent(childAccountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update account
     * @param {Account} body 
     * @param {string} accountId 
     * @param {string} xKillbillCreatedBy 
     * @param {boolean} [treatNullAsReset] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public updateAccount(body: Account, accountId: string, xKillbillCreatedBy: string, treatNullAsReset?: boolean, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).updateAccount(body, accountId, xKillbillCreatedBy, treatNullAsReset, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AdminApi - axios parameter creator
 * @export
 */
export const AdminApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get queues entries
         * @param {string} [accountId] 
         * @param {string} [queueName] 
         * @param {string} [serviceName] 
         * @param {boolean} [withHistory] 
         * @param {string} [minDate] 
         * @param {string} [maxDate] 
         * @param {boolean} [withInProcessing] 
         * @param {boolean} [withBusEvents] 
         * @param {boolean} [withNotifications] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueueEntries: async (accountId?: string, queueName?: string, serviceName?: string, withHistory?: boolean, minDate?: string, maxDate?: string, withInProcessing?: boolean, withBusEvents?: boolean, withNotifications?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/1.0/kb/admin/queues`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (queueName !== undefined) {
                localVarQueryParameter['queueName'] = queueName;
            }

            if (serviceName !== undefined) {
                localVarQueryParameter['serviceName'] = serviceName;
            }

            if (withHistory !== undefined) {
                localVarQueryParameter['withHistory'] = withHistory;
            }

            if (minDate !== undefined) {
                localVarQueryParameter['minDate'] = minDate;
            }

            if (maxDate !== undefined) {
                localVarQueryParameter['maxDate'] = maxDate;
            }

            if (withInProcessing !== undefined) {
                localVarQueryParameter['withInProcessing'] = withInProcessing;
            }

            if (withBusEvents !== undefined) {
                localVarQueryParameter['withBusEvents'] = withBusEvents;
            }

            if (withNotifications !== undefined) {
                localVarQueryParameter['withNotifications'] = withNotifications;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invalidates the given Cache if specified, otherwise invalidates all caches
         * @param {string} [cacheName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidatesCache: async (cacheName?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/1.0/kb/admin/cache`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (cacheName !== undefined) {
                localVarQueryParameter['cacheName'] = cacheName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invalidates Caches per account level
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidatesCacheByAccount: async (accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('invalidatesCacheByAccount', 'accountId', accountId)
            const localVarPath = `/1.0/kb/admin/cache/accounts/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invalidates Caches per tenant level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidatesCacheByTenant: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/1.0/kb/admin/cache/tenants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Put the host back into rotation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putInRotation: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/1.0/kb/admin/healthcheck`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Put the host out of rotation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putOutOfRotation: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/1.0/kb/admin/healthcheck`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Trigger an invoice generation for all parked accounts
         * @param {string} xKillbillCreatedBy 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerInvoiceGenerationForParkedAccounts: async (xKillbillCreatedBy: string, offset?: number, limit?: number, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('triggerInvoiceGenerationForParkedAccounts', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/admin/invoices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update existing paymentTransaction and associated payment state
         * @param {AdminPayment} body 
         * @param {string} paymentId 
         * @param {string} paymentTransactionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaymentTransactionState: async (body: AdminPayment, paymentId: string, paymentTransactionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updatePaymentTransactionState', 'body', body)
            // verify required parameter 'paymentId' is not null or undefined
            assertParamExists('updatePaymentTransactionState', 'paymentId', paymentId)
            // verify required parameter 'paymentTransactionId' is not null or undefined
            assertParamExists('updatePaymentTransactionState', 'paymentTransactionId', paymentTransactionId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('updatePaymentTransactionState', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/admin/payments/{paymentId}/transactions/{paymentTransactionId}`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)))
                .replace(`{${"paymentTransactionId"}}`, encodeURIComponent(String(paymentTransactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminApi - functional programming interface
 * @export
 */
export const AdminApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get queues entries
         * @param {string} [accountId] 
         * @param {string} [queueName] 
         * @param {string} [serviceName] 
         * @param {boolean} [withHistory] 
         * @param {string} [minDate] 
         * @param {string} [maxDate] 
         * @param {boolean} [withInProcessing] 
         * @param {boolean} [withBusEvents] 
         * @param {boolean} [withNotifications] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQueueEntries(accountId?: string, queueName?: string, serviceName?: string, withHistory?: boolean, minDate?: string, maxDate?: string, withInProcessing?: boolean, withBusEvents?: boolean, withNotifications?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getQueueEntries(accountId, queueName, serviceName, withHistory, minDate, maxDate, withInProcessing, withBusEvents, withNotifications, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Invalidates the given Cache if specified, otherwise invalidates all caches
         * @param {string} [cacheName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async invalidatesCache(cacheName?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.invalidatesCache(cacheName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Invalidates Caches per account level
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async invalidatesCacheByAccount(accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.invalidatesCacheByAccount(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Invalidates Caches per tenant level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async invalidatesCacheByTenant(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.invalidatesCacheByTenant(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Put the host back into rotation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putInRotation(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putInRotation(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Put the host out of rotation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putOutOfRotation(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putOutOfRotation(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Trigger an invoice generation for all parked accounts
         * @param {string} xKillbillCreatedBy 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async triggerInvoiceGenerationForParkedAccounts(xKillbillCreatedBy: string, offset?: number, limit?: number, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.triggerInvoiceGenerationForParkedAccounts(xKillbillCreatedBy, offset, limit, pluginProperty, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update existing paymentTransaction and associated payment state
         * @param {AdminPayment} body 
         * @param {string} paymentId 
         * @param {string} paymentTransactionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePaymentTransactionState(body: AdminPayment, paymentId: string, paymentTransactionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePaymentTransactionState(body, paymentId, paymentTransactionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AdminApi - factory interface
 * @export
 */
export const AdminApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminApiFp(configuration)
    return {
        /**
         * 
         * @summary Get queues entries
         * @param {string} [accountId] 
         * @param {string} [queueName] 
         * @param {string} [serviceName] 
         * @param {boolean} [withHistory] 
         * @param {string} [minDate] 
         * @param {string} [maxDate] 
         * @param {boolean} [withInProcessing] 
         * @param {boolean} [withBusEvents] 
         * @param {boolean} [withNotifications] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueueEntries(accountId?: string, queueName?: string, serviceName?: string, withHistory?: boolean, minDate?: string, maxDate?: string, withInProcessing?: boolean, withBusEvents?: boolean, withNotifications?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.getQueueEntries(accountId, queueName, serviceName, withHistory, minDate, maxDate, withInProcessing, withBusEvents, withNotifications, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invalidates the given Cache if specified, otherwise invalidates all caches
         * @param {string} [cacheName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidatesCache(cacheName?: string, options?: any): AxiosPromise<void> {
            return localVarFp.invalidatesCache(cacheName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invalidates Caches per account level
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidatesCacheByAccount(accountId: string, options?: any): AxiosPromise<void> {
            return localVarFp.invalidatesCacheByAccount(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invalidates Caches per tenant level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidatesCacheByTenant(options?: any): AxiosPromise<void> {
            return localVarFp.invalidatesCacheByTenant(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Put the host back into rotation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putInRotation(options?: any): AxiosPromise<void> {
            return localVarFp.putInRotation(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Put the host out of rotation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putOutOfRotation(options?: any): AxiosPromise<void> {
            return localVarFp.putOutOfRotation(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Trigger an invoice generation for all parked accounts
         * @param {string} xKillbillCreatedBy 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerInvoiceGenerationForParkedAccounts(xKillbillCreatedBy: string, offset?: number, limit?: number, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.triggerInvoiceGenerationForParkedAccounts(xKillbillCreatedBy, offset, limit, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update existing paymentTransaction and associated payment state
         * @param {AdminPayment} body 
         * @param {string} paymentId 
         * @param {string} paymentTransactionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaymentTransactionState(body: AdminPayment, paymentId: string, paymentTransactionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.updatePaymentTransactionState(body, paymentId, paymentTransactionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminApi - object-oriented interface
 * @export
 * @class AdminApi
 * @extends {BaseAPI}
 */
export class AdminApi extends BaseAPI {
    /**
     * 
     * @summary Get queues entries
     * @param {string} [accountId] 
     * @param {string} [queueName] 
     * @param {string} [serviceName] 
     * @param {boolean} [withHistory] 
     * @param {string} [minDate] 
     * @param {string} [maxDate] 
     * @param {boolean} [withInProcessing] 
     * @param {boolean} [withBusEvents] 
     * @param {boolean} [withNotifications] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getQueueEntries(accountId?: string, queueName?: string, serviceName?: string, withHistory?: boolean, minDate?: string, maxDate?: string, withInProcessing?: boolean, withBusEvents?: boolean, withNotifications?: boolean, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).getQueueEntries(accountId, queueName, serviceName, withHistory, minDate, maxDate, withInProcessing, withBusEvents, withNotifications, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invalidates the given Cache if specified, otherwise invalidates all caches
     * @param {string} [cacheName] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public invalidatesCache(cacheName?: string, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).invalidatesCache(cacheName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invalidates Caches per account level
     * @param {string} accountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public invalidatesCacheByAccount(accountId: string, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).invalidatesCacheByAccount(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invalidates Caches per tenant level
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public invalidatesCacheByTenant(options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).invalidatesCacheByTenant(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Put the host back into rotation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public putInRotation(options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).putInRotation(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Put the host out of rotation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public putOutOfRotation(options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).putOutOfRotation(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Trigger an invoice generation for all parked accounts
     * @param {string} xKillbillCreatedBy 
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public triggerInvoiceGenerationForParkedAccounts(xKillbillCreatedBy: string, offset?: number, limit?: number, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).triggerInvoiceGenerationForParkedAccounts(xKillbillCreatedBy, offset, limit, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update existing paymentTransaction and associated payment state
     * @param {AdminPayment} body 
     * @param {string} paymentId 
     * @param {string} paymentTransactionId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public updatePaymentTransactionState(body: AdminPayment, paymentId: string, paymentTransactionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).updatePaymentTransactionState(body, paymentId, paymentTransactionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BundleApi - axios parameter creator
 * @export
 */
export const BundleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Block a bundle
         * @param {BlockingState} body 
         * @param {string} bundleId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [requestedDate] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addBundleBlockingState: async (body: BlockingState, bundleId: string, xKillbillCreatedBy: string, requestedDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('addBundleBlockingState', 'body', body)
            // verify required parameter 'bundleId' is not null or undefined
            assertParamExists('addBundleBlockingState', 'bundleId', bundleId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('addBundleBlockingState', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/bundles/{bundleId}/block`
                .replace(`{${"bundleId"}}`, encodeURIComponent(String(bundleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (requestedDate !== undefined) {
                localVarQueryParameter['requestedDate'] = (requestedDate as any instanceof Date) ?
                    (requestedDate as any).toISOString().substr(0,10) :
                    requestedDate;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add custom fields to bundle
         * @param {Array<CustomField>} body 
         * @param {string} bundleId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBundleCustomFields: async (body: Array<CustomField>, bundleId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createBundleCustomFields', 'body', body)
            // verify required parameter 'bundleId' is not null or undefined
            assertParamExists('createBundleCustomFields', 'bundleId', bundleId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('createBundleCustomFields', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/bundles/{bundleId}/customFields`
                .replace(`{${"bundleId"}}`, encodeURIComponent(String(bundleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add tags to bundle
         * @param {Array<string>} body 
         * @param {string} bundleId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBundleTags: async (body: Array<string>, bundleId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createBundleTags', 'body', body)
            // verify required parameter 'bundleId' is not null or undefined
            assertParamExists('createBundleTags', 'bundleId', bundleId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('createBundleTags', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/bundles/{bundleId}/tags`
                .replace(`{${"bundleId"}}`, encodeURIComponent(String(bundleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove custom fields from bundle
         * @param {string} bundleId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [customField] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBundleCustomFields: async (bundleId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bundleId' is not null or undefined
            assertParamExists('deleteBundleCustomFields', 'bundleId', bundleId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('deleteBundleCustomFields', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/bundles/{bundleId}/customFields`
                .replace(`{${"bundleId"}}`, encodeURIComponent(String(bundleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (customField) {
                localVarQueryParameter['customField'] = customField;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove tags from bundle
         * @param {string} bundleId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [tagDef] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBundleTags: async (bundleId: string, xKillbillCreatedBy: string, tagDef?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bundleId' is not null or undefined
            assertParamExists('deleteBundleTags', 'bundleId', bundleId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('deleteBundleTags', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/bundles/{bundleId}/tags`
                .replace(`{${"bundleId"}}`, encodeURIComponent(String(bundleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (tagDef) {
                localVarQueryParameter['tagDef'] = tagDef;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a bundle by id
         * @param {string} bundleId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundle: async (bundleId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bundleId' is not null or undefined
            assertParamExists('getBundle', 'bundleId', bundleId)
            const localVarPath = `/1.0/kb/bundles/{bundleId}`
                .replace(`{${"bundleId"}}`, encodeURIComponent(String(bundleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve bundle audit logs with history by id
         * @param {string} bundleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundleAuditLogsWithHistory: async (bundleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bundleId' is not null or undefined
            assertParamExists('getBundleAuditLogsWithHistory', 'bundleId', bundleId)
            const localVarPath = `/1.0/kb/bundles/{bundleId}/auditLogsWithHistory`
                .replace(`{${"bundleId"}}`, encodeURIComponent(String(bundleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a bundle by external key
         * @param {string} externalKey 
         * @param {boolean} [includedDeleted] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundleByKey: async (externalKey: string, includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'externalKey' is not null or undefined
            assertParamExists('getBundleByKey', 'externalKey', externalKey)
            const localVarPath = `/1.0/kb/bundles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (externalKey !== undefined) {
                localVarQueryParameter['externalKey'] = externalKey;
            }

            if (includedDeleted !== undefined) {
                localVarQueryParameter['includedDeleted'] = includedDeleted;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve bundle custom fields
         * @param {string} bundleId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundleCustomFields: async (bundleId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bundleId' is not null or undefined
            assertParamExists('getBundleCustomFields', 'bundleId', bundleId)
            const localVarPath = `/1.0/kb/bundles/{bundleId}/customFields`
                .replace(`{${"bundleId"}}`, encodeURIComponent(String(bundleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve bundle tags
         * @param {string} bundleId 
         * @param {boolean} [includedDeleted] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundleTags: async (bundleId: string, includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bundleId' is not null or undefined
            assertParamExists('getBundleTags', 'bundleId', bundleId)
            const localVarPath = `/1.0/kb/bundles/{bundleId}/tags`
                .replace(`{${"bundleId"}}`, encodeURIComponent(String(bundleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (includedDeleted !== undefined) {
                localVarQueryParameter['includedDeleted'] = includedDeleted;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List bundles
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundles: async (offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/1.0/kb/bundles/pagination`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modify custom fields to bundle
         * @param {Array<CustomField>} body 
         * @param {string} bundleId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyBundleCustomFields: async (body: Array<CustomField>, bundleId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('modifyBundleCustomFields', 'body', body)
            // verify required parameter 'bundleId' is not null or undefined
            assertParamExists('modifyBundleCustomFields', 'bundleId', bundleId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('modifyBundleCustomFields', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/bundles/{bundleId}/customFields`
                .replace(`{${"bundleId"}}`, encodeURIComponent(String(bundleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Pause a bundle
         * @param {string} bundleId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [requestedDate] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pauseBundle: async (bundleId: string, xKillbillCreatedBy: string, requestedDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bundleId' is not null or undefined
            assertParamExists('pauseBundle', 'bundleId', bundleId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('pauseBundle', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/bundles/{bundleId}/pause`
                .replace(`{${"bundleId"}}`, encodeURIComponent(String(bundleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (requestedDate !== undefined) {
                localVarQueryParameter['requestedDate'] = (requestedDate as any instanceof Date) ?
                    (requestedDate as any).toISOString().substr(0,10) :
                    requestedDate;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a bundle externalKey
         * @param {Bundle} body 
         * @param {string} bundleId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renameExternalKey: async (body: Bundle, bundleId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('renameExternalKey', 'body', body)
            // verify required parameter 'bundleId' is not null or undefined
            assertParamExists('renameExternalKey', 'bundleId', bundleId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('renameExternalKey', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/bundles/{bundleId}/renameKey`
                .replace(`{${"bundleId"}}`, encodeURIComponent(String(bundleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Resume a bundle
         * @param {string} bundleId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [requestedDate] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeBundle: async (bundleId: string, xKillbillCreatedBy: string, requestedDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bundleId' is not null or undefined
            assertParamExists('resumeBundle', 'bundleId', bundleId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('resumeBundle', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/bundles/{bundleId}/resume`
                .replace(`{${"bundleId"}}`, encodeURIComponent(String(bundleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (requestedDate !== undefined) {
                localVarQueryParameter['requestedDate'] = (requestedDate as any instanceof Date) ?
                    (requestedDate as any).toISOString().substr(0,10) :
                    requestedDate;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search bundles
         * @param {string} searchKey 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchBundles: async (searchKey: string, offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchKey' is not null or undefined
            assertParamExists('searchBundles', 'searchKey', searchKey)
            const localVarPath = `/1.0/kb/bundles/search/{searchKey}`
                .replace(`{${"searchKey"}}`, encodeURIComponent(String(searchKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Transfer a bundle to another account
         * @param {Bundle} body 
         * @param {string} bundleId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [requestedDate] 
         * @param {'START_OF_TERM' | 'END_OF_TERM' | 'IMMEDIATE' | 'ILLEGAL'} [billingPolicy] 
         * @param {'NONE' | 'USE_EXISTING' | 'ALIGN_WITH_EFF_DT'} [bcdTransfer] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transferBundle: async (body: Bundle, bundleId: string, xKillbillCreatedBy: string, requestedDate?: string, billingPolicy?: 'START_OF_TERM' | 'END_OF_TERM' | 'IMMEDIATE' | 'ILLEGAL', bcdTransfer?: 'NONE' | 'USE_EXISTING' | 'ALIGN_WITH_EFF_DT', pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('transferBundle', 'body', body)
            // verify required parameter 'bundleId' is not null or undefined
            assertParamExists('transferBundle', 'bundleId', bundleId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('transferBundle', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/bundles/{bundleId}`
                .replace(`{${"bundleId"}}`, encodeURIComponent(String(bundleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (requestedDate !== undefined) {
                localVarQueryParameter['requestedDate'] = (requestedDate as any instanceof Date) ?
                    (requestedDate as any).toISOString().substr(0,10) :
                    requestedDate;
            }

            if (billingPolicy !== undefined) {
                localVarQueryParameter['billingPolicy'] = billingPolicy;
            }

            if (bcdTransfer !== undefined) {
                localVarQueryParameter['bcdTransfer'] = bcdTransfer;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BundleApi - functional programming interface
 * @export
 */
export const BundleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BundleApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Block a bundle
         * @param {BlockingState} body 
         * @param {string} bundleId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [requestedDate] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addBundleBlockingState(body: BlockingState, bundleId: string, xKillbillCreatedBy: string, requestedDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BlockingState>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addBundleBlockingState(body, bundleId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add custom fields to bundle
         * @param {Array<CustomField>} body 
         * @param {string} bundleId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBundleCustomFields(body: Array<CustomField>, bundleId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CustomField>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBundleCustomFields(body, bundleId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add tags to bundle
         * @param {Array<string>} body 
         * @param {string} bundleId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBundleTags(body: Array<string>, bundleId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBundleTags(body, bundleId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove custom fields from bundle
         * @param {string} bundleId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [customField] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBundleCustomFields(bundleId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBundleCustomFields(bundleId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove tags from bundle
         * @param {string} bundleId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [tagDef] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBundleTags(bundleId: string, xKillbillCreatedBy: string, tagDef?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBundleTags(bundleId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a bundle by id
         * @param {string} bundleId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBundle(bundleId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Bundle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBundle(bundleId, audit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve bundle audit logs with history by id
         * @param {string} bundleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBundleAuditLogsWithHistory(bundleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AuditLog>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBundleAuditLogsWithHistory(bundleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a bundle by external key
         * @param {string} externalKey 
         * @param {boolean} [includedDeleted] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBundleByKey(externalKey: string, includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Bundle>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBundleByKey(externalKey, includedDeleted, audit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve bundle custom fields
         * @param {string} bundleId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBundleCustomFields(bundleId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CustomField>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBundleCustomFields(bundleId, audit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve bundle tags
         * @param {string} bundleId 
         * @param {boolean} [includedDeleted] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBundleTags(bundleId: string, includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBundleTags(bundleId, includedDeleted, audit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List bundles
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBundles(offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Bundle>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBundles(offset, limit, audit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Modify custom fields to bundle
         * @param {Array<CustomField>} body 
         * @param {string} bundleId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyBundleCustomFields(body: Array<CustomField>, bundleId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifyBundleCustomFields(body, bundleId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Pause a bundle
         * @param {string} bundleId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [requestedDate] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pauseBundle(bundleId: string, xKillbillCreatedBy: string, requestedDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pauseBundle(bundleId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a bundle externalKey
         * @param {Bundle} body 
         * @param {string} bundleId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async renameExternalKey(body: Bundle, bundleId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.renameExternalKey(body, bundleId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Resume a bundle
         * @param {string} bundleId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [requestedDate] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resumeBundle(bundleId: string, xKillbillCreatedBy: string, requestedDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resumeBundle(bundleId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Search bundles
         * @param {string} searchKey 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchBundles(searchKey: string, offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Bundle>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchBundles(searchKey, offset, limit, audit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Transfer a bundle to another account
         * @param {Bundle} body 
         * @param {string} bundleId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [requestedDate] 
         * @param {'START_OF_TERM' | 'END_OF_TERM' | 'IMMEDIATE' | 'ILLEGAL'} [billingPolicy] 
         * @param {'NONE' | 'USE_EXISTING' | 'ALIGN_WITH_EFF_DT'} [bcdTransfer] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transferBundle(body: Bundle, bundleId: string, xKillbillCreatedBy: string, requestedDate?: string, billingPolicy?: 'START_OF_TERM' | 'END_OF_TERM' | 'IMMEDIATE' | 'ILLEGAL', bcdTransfer?: 'NONE' | 'USE_EXISTING' | 'ALIGN_WITH_EFF_DT', pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Bundle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transferBundle(body, bundleId, xKillbillCreatedBy, requestedDate, billingPolicy, bcdTransfer, pluginProperty, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BundleApi - factory interface
 * @export
 */
export const BundleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BundleApiFp(configuration)
    return {
        /**
         * 
         * @summary Block a bundle
         * @param {BlockingState} body 
         * @param {string} bundleId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [requestedDate] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addBundleBlockingState(body: BlockingState, bundleId: string, xKillbillCreatedBy: string, requestedDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Array<BlockingState>> {
            return localVarFp.addBundleBlockingState(body, bundleId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add custom fields to bundle
         * @param {Array<CustomField>} body 
         * @param {string} bundleId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBundleCustomFields(body: Array<CustomField>, bundleId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Array<CustomField>> {
            return localVarFp.createBundleCustomFields(body, bundleId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add tags to bundle
         * @param {Array<string>} body 
         * @param {string} bundleId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBundleTags(body: Array<string>, bundleId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.createBundleTags(body, bundleId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove custom fields from bundle
         * @param {string} bundleId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [customField] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBundleCustomFields(bundleId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteBundleCustomFields(bundleId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove tags from bundle
         * @param {string} bundleId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [tagDef] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBundleTags(bundleId: string, xKillbillCreatedBy: string, tagDef?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteBundleTags(bundleId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a bundle by id
         * @param {string} bundleId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundle(bundleId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Bundle> {
            return localVarFp.getBundle(bundleId, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve bundle audit logs with history by id
         * @param {string} bundleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundleAuditLogsWithHistory(bundleId: string, options?: any): AxiosPromise<Array<AuditLog>> {
            return localVarFp.getBundleAuditLogsWithHistory(bundleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a bundle by external key
         * @param {string} externalKey 
         * @param {boolean} [includedDeleted] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundleByKey(externalKey: string, includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<Bundle>> {
            return localVarFp.getBundleByKey(externalKey, includedDeleted, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve bundle custom fields
         * @param {string} bundleId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundleCustomFields(bundleId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<CustomField>> {
            return localVarFp.getBundleCustomFields(bundleId, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve bundle tags
         * @param {string} bundleId 
         * @param {boolean} [includedDeleted] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundleTags(bundleId: string, includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.getBundleTags(bundleId, includedDeleted, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List bundles
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundles(offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<Bundle>> {
            return localVarFp.getBundles(offset, limit, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Modify custom fields to bundle
         * @param {Array<CustomField>} body 
         * @param {string} bundleId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyBundleCustomFields(body: Array<CustomField>, bundleId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.modifyBundleCustomFields(body, bundleId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Pause a bundle
         * @param {string} bundleId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [requestedDate] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pauseBundle(bundleId: string, xKillbillCreatedBy: string, requestedDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.pauseBundle(bundleId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a bundle externalKey
         * @param {Bundle} body 
         * @param {string} bundleId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renameExternalKey(body: Bundle, bundleId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.renameExternalKey(body, bundleId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Resume a bundle
         * @param {string} bundleId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [requestedDate] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeBundle(bundleId: string, xKillbillCreatedBy: string, requestedDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.resumeBundle(bundleId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search bundles
         * @param {string} searchKey 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchBundles(searchKey: string, offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<Bundle>> {
            return localVarFp.searchBundles(searchKey, offset, limit, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Transfer a bundle to another account
         * @param {Bundle} body 
         * @param {string} bundleId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [requestedDate] 
         * @param {'START_OF_TERM' | 'END_OF_TERM' | 'IMMEDIATE' | 'ILLEGAL'} [billingPolicy] 
         * @param {'NONE' | 'USE_EXISTING' | 'ALIGN_WITH_EFF_DT'} [bcdTransfer] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transferBundle(body: Bundle, bundleId: string, xKillbillCreatedBy: string, requestedDate?: string, billingPolicy?: 'START_OF_TERM' | 'END_OF_TERM' | 'IMMEDIATE' | 'ILLEGAL', bcdTransfer?: 'NONE' | 'USE_EXISTING' | 'ALIGN_WITH_EFF_DT', pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Bundle> {
            return localVarFp.transferBundle(body, bundleId, xKillbillCreatedBy, requestedDate, billingPolicy, bcdTransfer, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BundleApi - object-oriented interface
 * @export
 * @class BundleApi
 * @extends {BaseAPI}
 */
export class BundleApi extends BaseAPI {
    /**
     * 
     * @summary Block a bundle
     * @param {BlockingState} body 
     * @param {string} bundleId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [requestedDate] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleApi
     */
    public addBundleBlockingState(body: BlockingState, bundleId: string, xKillbillCreatedBy: string, requestedDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return BundleApiFp(this.configuration).addBundleBlockingState(body, bundleId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add custom fields to bundle
     * @param {Array<CustomField>} body 
     * @param {string} bundleId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleApi
     */
    public createBundleCustomFields(body: Array<CustomField>, bundleId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return BundleApiFp(this.configuration).createBundleCustomFields(body, bundleId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add tags to bundle
     * @param {Array<string>} body 
     * @param {string} bundleId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleApi
     */
    public createBundleTags(body: Array<string>, bundleId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return BundleApiFp(this.configuration).createBundleTags(body, bundleId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove custom fields from bundle
     * @param {string} bundleId 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [customField] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleApi
     */
    public deleteBundleCustomFields(bundleId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return BundleApiFp(this.configuration).deleteBundleCustomFields(bundleId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove tags from bundle
     * @param {string} bundleId 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [tagDef] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleApi
     */
    public deleteBundleTags(bundleId: string, xKillbillCreatedBy: string, tagDef?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return BundleApiFp(this.configuration).deleteBundleTags(bundleId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a bundle by id
     * @param {string} bundleId 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleApi
     */
    public getBundle(bundleId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig) {
        return BundleApiFp(this.configuration).getBundle(bundleId, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve bundle audit logs with history by id
     * @param {string} bundleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleApi
     */
    public getBundleAuditLogsWithHistory(bundleId: string, options?: AxiosRequestConfig) {
        return BundleApiFp(this.configuration).getBundleAuditLogsWithHistory(bundleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a bundle by external key
     * @param {string} externalKey 
     * @param {boolean} [includedDeleted] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleApi
     */
    public getBundleByKey(externalKey: string, includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig) {
        return BundleApiFp(this.configuration).getBundleByKey(externalKey, includedDeleted, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve bundle custom fields
     * @param {string} bundleId 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleApi
     */
    public getBundleCustomFields(bundleId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig) {
        return BundleApiFp(this.configuration).getBundleCustomFields(bundleId, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve bundle tags
     * @param {string} bundleId 
     * @param {boolean} [includedDeleted] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleApi
     */
    public getBundleTags(bundleId: string, includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig) {
        return BundleApiFp(this.configuration).getBundleTags(bundleId, includedDeleted, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List bundles
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleApi
     */
    public getBundles(offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig) {
        return BundleApiFp(this.configuration).getBundles(offset, limit, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Modify custom fields to bundle
     * @param {Array<CustomField>} body 
     * @param {string} bundleId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleApi
     */
    public modifyBundleCustomFields(body: Array<CustomField>, bundleId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return BundleApiFp(this.configuration).modifyBundleCustomFields(body, bundleId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Pause a bundle
     * @param {string} bundleId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [requestedDate] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleApi
     */
    public pauseBundle(bundleId: string, xKillbillCreatedBy: string, requestedDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return BundleApiFp(this.configuration).pauseBundle(bundleId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a bundle externalKey
     * @param {Bundle} body 
     * @param {string} bundleId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleApi
     */
    public renameExternalKey(body: Bundle, bundleId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return BundleApiFp(this.configuration).renameExternalKey(body, bundleId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Resume a bundle
     * @param {string} bundleId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [requestedDate] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleApi
     */
    public resumeBundle(bundleId: string, xKillbillCreatedBy: string, requestedDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return BundleApiFp(this.configuration).resumeBundle(bundleId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search bundles
     * @param {string} searchKey 
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleApi
     */
    public searchBundles(searchKey: string, offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig) {
        return BundleApiFp(this.configuration).searchBundles(searchKey, offset, limit, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Transfer a bundle to another account
     * @param {Bundle} body 
     * @param {string} bundleId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [requestedDate] 
     * @param {'START_OF_TERM' | 'END_OF_TERM' | 'IMMEDIATE' | 'ILLEGAL'} [billingPolicy] 
     * @param {'NONE' | 'USE_EXISTING' | 'ALIGN_WITH_EFF_DT'} [bcdTransfer] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleApi
     */
    public transferBundle(body: Bundle, bundleId: string, xKillbillCreatedBy: string, requestedDate?: string, billingPolicy?: 'START_OF_TERM' | 'END_OF_TERM' | 'IMMEDIATE' | 'ILLEGAL', bcdTransfer?: 'NONE' | 'USE_EXISTING' | 'ALIGN_WITH_EFF_DT', pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return BundleApiFp(this.configuration).transferBundle(body, bundleId, xKillbillCreatedBy, requestedDate, billingPolicy, bcdTransfer, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CatalogApi - axios parameter creator
 * @export
 */
export const CatalogApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a simple plan entry in the current version of the catalog
         * @param {SimplePlan} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSimplePlan: async (body: SimplePlan, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('addSimplePlan', 'body', body)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('addSimplePlan', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/catalog/simplePlan`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete all versions for a per tenant catalog
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCatalog: async (xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('deleteCatalog', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/catalog`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve available add-ons for a given product
         * @param {string} [baseProductName] 
         * @param {string} [priceListName] 
         * @param {string} [accountId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableAddons: async (baseProductName?: string, priceListName?: string, accountId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/1.0/kb/catalog/availableAddons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (baseProductName !== undefined) {
                localVarQueryParameter['baseProductName'] = baseProductName;
            }

            if (priceListName !== undefined) {
                localVarQueryParameter['priceListName'] = priceListName;
            }

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve available base plans
         * @param {string} [accountId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableBasePlans: async (accountId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/1.0/kb/catalog/availableBasePlans`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the catalog as JSON
         * @param {string} [requestedDate] 
         * @param {string} [accountId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCatalogJson: async (requestedDate?: string, accountId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/1.0/kb/catalog`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (requestedDate !== undefined) {
                localVarQueryParameter['requestedDate'] = (requestedDate as any instanceof Date) ?
                    (requestedDate as any).toISOString() :
                    requestedDate;
            }

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a list of catalog versions
         * @param {string} [accountId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCatalogVersions: async (accountId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/1.0/kb/catalog/versions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the full catalog as XML
         * @param {string} [requestedDate] 
         * @param {string} [accountId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCatalogXml: async (requestedDate?: string, accountId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/1.0/kb/catalog/xml`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (requestedDate !== undefined) {
                localVarQueryParameter['requestedDate'] = (requestedDate as any instanceof Date) ?
                    (requestedDate as any).toISOString() :
                    requestedDate;
            }

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve phase for a given subscription and date
         * @param {string} [subscriptionId] 
         * @param {string} [requestedDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhaseForSubscriptionAndDate: async (subscriptionId?: string, requestedDate?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/1.0/kb/catalog/phase`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (subscriptionId !== undefined) {
                localVarQueryParameter['subscriptionId'] = subscriptionId;
            }

            if (requestedDate !== undefined) {
                localVarQueryParameter['requestedDate'] = (requestedDate as any instanceof Date) ?
                    (requestedDate as any).toISOString().substr(0,10) :
                    requestedDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve plan for a given subscription and date
         * @param {string} [subscriptionId] 
         * @param {string} [requestedDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlanForSubscriptionAndDate: async (subscriptionId?: string, requestedDate?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/1.0/kb/catalog/plan`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (subscriptionId !== undefined) {
                localVarQueryParameter['subscriptionId'] = subscriptionId;
            }

            if (requestedDate !== undefined) {
                localVarQueryParameter['requestedDate'] = (requestedDate as any instanceof Date) ?
                    (requestedDate as any).toISOString().substr(0,10) :
                    requestedDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve priceList for a given subscription and date
         * @param {string} [subscriptionId] 
         * @param {string} [requestedDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPriceListForSubscriptionAndDate: async (subscriptionId?: string, requestedDate?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/1.0/kb/catalog/priceList`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (subscriptionId !== undefined) {
                localVarQueryParameter['subscriptionId'] = subscriptionId;
            }

            if (requestedDate !== undefined) {
                localVarQueryParameter['requestedDate'] = (requestedDate as any instanceof Date) ?
                    (requestedDate as any).toISOString().substr(0,10) :
                    requestedDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve product for a given subscription and date
         * @param {string} [subscriptionId] 
         * @param {string} [requestedDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductForSubscriptionAndDate: async (subscriptionId?: string, requestedDate?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/1.0/kb/catalog/product`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (subscriptionId !== undefined) {
                localVarQueryParameter['subscriptionId'] = subscriptionId;
            }

            if (requestedDate !== undefined) {
                localVarQueryParameter['requestedDate'] = (requestedDate as any instanceof Date) ?
                    (requestedDate as any).toISOString().substr(0,10) :
                    requestedDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload the full catalog as XML
         * @param {string} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadCatalogXml: async (body: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('uploadCatalogXml', 'body', body)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('uploadCatalogXml', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/catalog/xml`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'text/xml';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Validate a XML catalog
         * @param {string} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateCatalogXml: async (body: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('validateCatalogXml', 'body', body)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('validateCatalogXml', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/catalog/xml/validate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'text/xml';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CatalogApi - functional programming interface
 * @export
 */
export const CatalogApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CatalogApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add a simple plan entry in the current version of the catalog
         * @param {SimplePlan} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addSimplePlan(body: SimplePlan, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addSimplePlan(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete all versions for a per tenant catalog
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCatalog(xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCatalog(xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve available add-ons for a given product
         * @param {string} [baseProductName] 
         * @param {string} [priceListName] 
         * @param {string} [accountId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAvailableAddons(baseProductName?: string, priceListName?: string, accountId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PlanDetail>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAvailableAddons(baseProductName, priceListName, accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve available base plans
         * @param {string} [accountId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAvailableBasePlans(accountId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PlanDetail>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAvailableBasePlans(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve the catalog as JSON
         * @param {string} [requestedDate] 
         * @param {string} [accountId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCatalogJson(requestedDate?: string, accountId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Catalog>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCatalogJson(requestedDate, accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a list of catalog versions
         * @param {string} [accountId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCatalogVersions(accountId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCatalogVersions(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve the full catalog as XML
         * @param {string} [requestedDate] 
         * @param {string} [accountId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCatalogXml(requestedDate?: string, accountId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCatalogXml(requestedDate, accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve phase for a given subscription and date
         * @param {string} [subscriptionId] 
         * @param {string} [requestedDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPhaseForSubscriptionAndDate(subscriptionId?: string, requestedDate?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Phase>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPhaseForSubscriptionAndDate(subscriptionId, requestedDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve plan for a given subscription and date
         * @param {string} [subscriptionId] 
         * @param {string} [requestedDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlanForSubscriptionAndDate(subscriptionId?: string, requestedDate?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Plan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlanForSubscriptionAndDate(subscriptionId, requestedDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve priceList for a given subscription and date
         * @param {string} [subscriptionId] 
         * @param {string} [requestedDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPriceListForSubscriptionAndDate(subscriptionId?: string, requestedDate?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PriceList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPriceListForSubscriptionAndDate(subscriptionId, requestedDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve product for a given subscription and date
         * @param {string} [subscriptionId] 
         * @param {string} [requestedDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductForSubscriptionAndDate(subscriptionId?: string, requestedDate?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProductForSubscriptionAndDate(subscriptionId, requestedDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Upload the full catalog as XML
         * @param {string} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadCatalogXml(body: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadCatalogXml(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Validate a XML catalog
         * @param {string} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateCatalogXml(body: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CatalogValidation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateCatalogXml(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CatalogApi - factory interface
 * @export
 */
export const CatalogApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CatalogApiFp(configuration)
    return {
        /**
         * 
         * @summary Add a simple plan entry in the current version of the catalog
         * @param {SimplePlan} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSimplePlan(body: SimplePlan, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<string> {
            return localVarFp.addSimplePlan(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete all versions for a per tenant catalog
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCatalog(xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCatalog(xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve available add-ons for a given product
         * @param {string} [baseProductName] 
         * @param {string} [priceListName] 
         * @param {string} [accountId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableAddons(baseProductName?: string, priceListName?: string, accountId?: string, options?: any): AxiosPromise<Array<PlanDetail>> {
            return localVarFp.getAvailableAddons(baseProductName, priceListName, accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve available base plans
         * @param {string} [accountId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableBasePlans(accountId?: string, options?: any): AxiosPromise<Array<PlanDetail>> {
            return localVarFp.getAvailableBasePlans(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve the catalog as JSON
         * @param {string} [requestedDate] 
         * @param {string} [accountId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCatalogJson(requestedDate?: string, accountId?: string, options?: any): AxiosPromise<Array<Catalog>> {
            return localVarFp.getCatalogJson(requestedDate, accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a list of catalog versions
         * @param {string} [accountId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCatalogVersions(accountId?: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getCatalogVersions(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve the full catalog as XML
         * @param {string} [requestedDate] 
         * @param {string} [accountId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCatalogXml(requestedDate?: string, accountId?: string, options?: any): AxiosPromise<string> {
            return localVarFp.getCatalogXml(requestedDate, accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve phase for a given subscription and date
         * @param {string} [subscriptionId] 
         * @param {string} [requestedDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhaseForSubscriptionAndDate(subscriptionId?: string, requestedDate?: string, options?: any): AxiosPromise<Phase> {
            return localVarFp.getPhaseForSubscriptionAndDate(subscriptionId, requestedDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve plan for a given subscription and date
         * @param {string} [subscriptionId] 
         * @param {string} [requestedDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlanForSubscriptionAndDate(subscriptionId?: string, requestedDate?: string, options?: any): AxiosPromise<Plan> {
            return localVarFp.getPlanForSubscriptionAndDate(subscriptionId, requestedDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve priceList for a given subscription and date
         * @param {string} [subscriptionId] 
         * @param {string} [requestedDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPriceListForSubscriptionAndDate(subscriptionId?: string, requestedDate?: string, options?: any): AxiosPromise<PriceList> {
            return localVarFp.getPriceListForSubscriptionAndDate(subscriptionId, requestedDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve product for a given subscription and date
         * @param {string} [subscriptionId] 
         * @param {string} [requestedDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductForSubscriptionAndDate(subscriptionId?: string, requestedDate?: string, options?: any): AxiosPromise<Product> {
            return localVarFp.getProductForSubscriptionAndDate(subscriptionId, requestedDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload the full catalog as XML
         * @param {string} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadCatalogXml(body: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<string> {
            return localVarFp.uploadCatalogXml(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Validate a XML catalog
         * @param {string} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateCatalogXml(body: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<CatalogValidation> {
            return localVarFp.validateCatalogXml(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CatalogApi - object-oriented interface
 * @export
 * @class CatalogApi
 * @extends {BaseAPI}
 */
export class CatalogApi extends BaseAPI {
    /**
     * 
     * @summary Add a simple plan entry in the current version of the catalog
     * @param {SimplePlan} body 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogApi
     */
    public addSimplePlan(body: SimplePlan, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return CatalogApiFp(this.configuration).addSimplePlan(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete all versions for a per tenant catalog
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogApi
     */
    public deleteCatalog(xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return CatalogApiFp(this.configuration).deleteCatalog(xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve available add-ons for a given product
     * @param {string} [baseProductName] 
     * @param {string} [priceListName] 
     * @param {string} [accountId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogApi
     */
    public getAvailableAddons(baseProductName?: string, priceListName?: string, accountId?: string, options?: AxiosRequestConfig) {
        return CatalogApiFp(this.configuration).getAvailableAddons(baseProductName, priceListName, accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve available base plans
     * @param {string} [accountId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogApi
     */
    public getAvailableBasePlans(accountId?: string, options?: AxiosRequestConfig) {
        return CatalogApiFp(this.configuration).getAvailableBasePlans(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve the catalog as JSON
     * @param {string} [requestedDate] 
     * @param {string} [accountId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogApi
     */
    public getCatalogJson(requestedDate?: string, accountId?: string, options?: AxiosRequestConfig) {
        return CatalogApiFp(this.configuration).getCatalogJson(requestedDate, accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a list of catalog versions
     * @param {string} [accountId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogApi
     */
    public getCatalogVersions(accountId?: string, options?: AxiosRequestConfig) {
        return CatalogApiFp(this.configuration).getCatalogVersions(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve the full catalog as XML
     * @param {string} [requestedDate] 
     * @param {string} [accountId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogApi
     */
    public getCatalogXml(requestedDate?: string, accountId?: string, options?: AxiosRequestConfig) {
        return CatalogApiFp(this.configuration).getCatalogXml(requestedDate, accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve phase for a given subscription and date
     * @param {string} [subscriptionId] 
     * @param {string} [requestedDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogApi
     */
    public getPhaseForSubscriptionAndDate(subscriptionId?: string, requestedDate?: string, options?: AxiosRequestConfig) {
        return CatalogApiFp(this.configuration).getPhaseForSubscriptionAndDate(subscriptionId, requestedDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve plan for a given subscription and date
     * @param {string} [subscriptionId] 
     * @param {string} [requestedDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogApi
     */
    public getPlanForSubscriptionAndDate(subscriptionId?: string, requestedDate?: string, options?: AxiosRequestConfig) {
        return CatalogApiFp(this.configuration).getPlanForSubscriptionAndDate(subscriptionId, requestedDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve priceList for a given subscription and date
     * @param {string} [subscriptionId] 
     * @param {string} [requestedDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogApi
     */
    public getPriceListForSubscriptionAndDate(subscriptionId?: string, requestedDate?: string, options?: AxiosRequestConfig) {
        return CatalogApiFp(this.configuration).getPriceListForSubscriptionAndDate(subscriptionId, requestedDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve product for a given subscription and date
     * @param {string} [subscriptionId] 
     * @param {string} [requestedDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogApi
     */
    public getProductForSubscriptionAndDate(subscriptionId?: string, requestedDate?: string, options?: AxiosRequestConfig) {
        return CatalogApiFp(this.configuration).getProductForSubscriptionAndDate(subscriptionId, requestedDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload the full catalog as XML
     * @param {string} body 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogApi
     */
    public uploadCatalogXml(body: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return CatalogApiFp(this.configuration).uploadCatalogXml(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Validate a XML catalog
     * @param {string} body 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogApi
     */
    public validateCatalogXml(body: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return CatalogApiFp(this.configuration).validateCatalogXml(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CreditApi - axios parameter creator
 * @export
 */
export const CreditApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a credit
         * @param {Array<InvoiceItem>} body 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [autoCommit] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCredits: async (body: Array<InvoiceItem>, xKillbillCreatedBy: string, autoCommit?: boolean, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createCredits', 'body', body)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('createCredits', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/credits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (autoCommit !== undefined) {
                localVarQueryParameter['autoCommit'] = autoCommit;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a credit by id
         * @param {string} creditId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCredit: async (creditId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'creditId' is not null or undefined
            assertParamExists('getCredit', 'creditId', creditId)
            const localVarPath = `/1.0/kb/credits/{creditId}`
                .replace(`{${"creditId"}}`, encodeURIComponent(String(creditId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CreditApi - functional programming interface
 * @export
 */
export const CreditApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CreditApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a credit
         * @param {Array<InvoiceItem>} body 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [autoCommit] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCredits(body: Array<InvoiceItem>, xKillbillCreatedBy: string, autoCommit?: boolean, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InvoiceItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCredits(body, xKillbillCreatedBy, autoCommit, pluginProperty, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a credit by id
         * @param {string} creditId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCredit(creditId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoiceItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCredit(creditId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CreditApi - factory interface
 * @export
 */
export const CreditApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CreditApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a credit
         * @param {Array<InvoiceItem>} body 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [autoCommit] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCredits(body: Array<InvoiceItem>, xKillbillCreatedBy: string, autoCommit?: boolean, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Array<InvoiceItem>> {
            return localVarFp.createCredits(body, xKillbillCreatedBy, autoCommit, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a credit by id
         * @param {string} creditId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCredit(creditId: string, options?: any): AxiosPromise<InvoiceItem> {
            return localVarFp.getCredit(creditId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CreditApi - object-oriented interface
 * @export
 * @class CreditApi
 * @extends {BaseAPI}
 */
export class CreditApi extends BaseAPI {
    /**
     * 
     * @summary Create a credit
     * @param {Array<InvoiceItem>} body 
     * @param {string} xKillbillCreatedBy 
     * @param {boolean} [autoCommit] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditApi
     */
    public createCredits(body: Array<InvoiceItem>, xKillbillCreatedBy: string, autoCommit?: boolean, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return CreditApiFp(this.configuration).createCredits(body, xKillbillCreatedBy, autoCommit, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a credit by id
     * @param {string} creditId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditApi
     */
    public getCredit(creditId: string, options?: AxiosRequestConfig) {
        return CreditApiFp(this.configuration).getCredit(creditId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CustomFieldApi - axios parameter creator
 * @export
 */
export const CustomFieldApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve custom field audit logs with history by id
         * @param {string} customFieldId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomFieldAuditLogsWithHistory: async (customFieldId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customFieldId' is not null or undefined
            assertParamExists('getCustomFieldAuditLogsWithHistory', 'customFieldId', customFieldId)
            const localVarPath = `/1.0/kb/customFields/{customFieldId}/auditLogsWithHistory`
                .replace(`{${"customFieldId"}}`, encodeURIComponent(String(customFieldId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List custom fields
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomFields: async (offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/1.0/kb/customFields/pagination`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search custom fields
         * @param {string} searchKey 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchCustomFields: async (searchKey: string, offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchKey' is not null or undefined
            assertParamExists('searchCustomFields', 'searchKey', searchKey)
            const localVarPath = `/1.0/kb/customFields/search/{searchKey}`
                .replace(`{${"searchKey"}}`, encodeURIComponent(String(searchKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search custom fields by type, name and optional value
         * @param {string} [objectType] 
         * @param {string} [fieldName] 
         * @param {string} [fieldValue] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchCustomFieldsByTypeName: async (objectType?: string, fieldName?: string, fieldValue?: string, offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/1.0/kb/customFields/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (objectType !== undefined) {
                localVarQueryParameter['objectType'] = objectType;
            }

            if (fieldName !== undefined) {
                localVarQueryParameter['fieldName'] = fieldName;
            }

            if (fieldValue !== undefined) {
                localVarQueryParameter['fieldValue'] = fieldValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomFieldApi - functional programming interface
 * @export
 */
export const CustomFieldApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CustomFieldApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Retrieve custom field audit logs with history by id
         * @param {string} customFieldId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomFieldAuditLogsWithHistory(customFieldId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AuditLog>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomFieldAuditLogsWithHistory(customFieldId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List custom fields
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomFields(offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CustomField>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomFields(offset, limit, audit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Search custom fields
         * @param {string} searchKey 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchCustomFields(searchKey: string, offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CustomField>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchCustomFields(searchKey, offset, limit, audit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Search custom fields by type, name and optional value
         * @param {string} [objectType] 
         * @param {string} [fieldName] 
         * @param {string} [fieldValue] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchCustomFieldsByTypeName(objectType?: string, fieldName?: string, fieldValue?: string, offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CustomField>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchCustomFieldsByTypeName(objectType, fieldName, fieldValue, offset, limit, audit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CustomFieldApi - factory interface
 * @export
 */
export const CustomFieldApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CustomFieldApiFp(configuration)
    return {
        /**
         * 
         * @summary Retrieve custom field audit logs with history by id
         * @param {string} customFieldId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomFieldAuditLogsWithHistory(customFieldId: string, options?: any): AxiosPromise<Array<AuditLog>> {
            return localVarFp.getCustomFieldAuditLogsWithHistory(customFieldId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List custom fields
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomFields(offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<CustomField>> {
            return localVarFp.getCustomFields(offset, limit, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search custom fields
         * @param {string} searchKey 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchCustomFields(searchKey: string, offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<CustomField>> {
            return localVarFp.searchCustomFields(searchKey, offset, limit, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search custom fields by type, name and optional value
         * @param {string} [objectType] 
         * @param {string} [fieldName] 
         * @param {string} [fieldValue] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchCustomFieldsByTypeName(objectType?: string, fieldName?: string, fieldValue?: string, offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<CustomField>> {
            return localVarFp.searchCustomFieldsByTypeName(objectType, fieldName, fieldValue, offset, limit, audit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CustomFieldApi - object-oriented interface
 * @export
 * @class CustomFieldApi
 * @extends {BaseAPI}
 */
export class CustomFieldApi extends BaseAPI {
    /**
     * 
     * @summary Retrieve custom field audit logs with history by id
     * @param {string} customFieldId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomFieldApi
     */
    public getCustomFieldAuditLogsWithHistory(customFieldId: string, options?: AxiosRequestConfig) {
        return CustomFieldApiFp(this.configuration).getCustomFieldAuditLogsWithHistory(customFieldId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List custom fields
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomFieldApi
     */
    public getCustomFields(offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig) {
        return CustomFieldApiFp(this.configuration).getCustomFields(offset, limit, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search custom fields
     * @param {string} searchKey 
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomFieldApi
     */
    public searchCustomFields(searchKey: string, offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig) {
        return CustomFieldApiFp(this.configuration).searchCustomFields(searchKey, offset, limit, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search custom fields by type, name and optional value
     * @param {string} [objectType] 
     * @param {string} [fieldName] 
     * @param {string} [fieldValue] 
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomFieldApi
     */
    public searchCustomFieldsByTypeName(objectType?: string, fieldName?: string, fieldValue?: string, offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig) {
        return CustomFieldApiFp(this.configuration).searchCustomFieldsByTypeName(objectType, fieldName, fieldValue, offset, limit, audit, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ExportApi - axios parameter creator
 * @export
 */
export const ExportApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Export account data
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportDataForAccount: async (accountId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('exportDataForAccount', 'accountId', accountId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('exportDataForAccount', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/export/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExportApi - functional programming interface
 * @export
 */
export const ExportApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExportApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Export account data
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportDataForAccount(accountId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportDataForAccount(accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ExportApi - factory interface
 * @export
 */
export const ExportApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExportApiFp(configuration)
    return {
        /**
         * 
         * @summary Export account data
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportDataForAccount(accountId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.exportDataForAccount(accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExportApi - object-oriented interface
 * @export
 * @class ExportApi
 * @extends {BaseAPI}
 */
export class ExportApi extends BaseAPI {
    /**
     * 
     * @summary Export account data
     * @param {string} accountId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportApi
     */
    public exportDataForAccount(accountId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return ExportApiFp(this.configuration).exportDataForAccount(accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * InvoiceApi - axios parameter creator
 * @export
 */
export const InvoiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adjust an invoice item
         * @param {InvoiceItem} body 
         * @param {string} invoiceId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [requestedDate] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adjustInvoiceItem: async (body: InvoiceItem, invoiceId: string, xKillbillCreatedBy: string, requestedDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('adjustInvoiceItem', 'body', body)
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('adjustInvoiceItem', 'invoiceId', invoiceId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('adjustInvoiceItem', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/invoices/{invoiceId}`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (requestedDate !== undefined) {
                localVarQueryParameter['requestedDate'] = (requestedDate as any instanceof Date) ?
                    (requestedDate as any).toISOString().substr(0,10) :
                    requestedDate;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Perform the invoice status transition from DRAFT to COMMITTED
         * @param {string} invoiceId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commitInvoice: async (invoiceId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('commitInvoice', 'invoiceId', invoiceId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('commitInvoice', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/invoices/{invoiceId}/commitInvoice`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create external charge(s)
         * @param {Array<InvoiceItem>} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [requestedDate] 
         * @param {boolean} [autoCommit] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExternalCharges: async (body: Array<InvoiceItem>, accountId: string, xKillbillCreatedBy: string, requestedDate?: string, autoCommit?: boolean, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createExternalCharges', 'body', body)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('createExternalCharges', 'accountId', accountId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('createExternalCharges', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/invoices/charges/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (requestedDate !== undefined) {
                localVarQueryParameter['requestedDate'] = (requestedDate as any instanceof Date) ?
                    (requestedDate as any).toISOString().substr(0,10) :
                    requestedDate;
            }

            if (autoCommit !== undefined) {
                localVarQueryParameter['autoCommit'] = autoCommit;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Trigger an invoice generation
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [targetDate] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFutureInvoice: async (accountId: string, xKillbillCreatedBy: string, targetDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('createFutureInvoice', 'accountId', accountId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('createFutureInvoice', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/invoices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (targetDate !== undefined) {
                localVarQueryParameter['targetDate'] = (targetDate as any instanceof Date) ?
                    (targetDate as any).toISOString().substr(0,10) :
                    targetDate;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Trigger an invoice generation
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [targetDate] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFutureInvoiceGroup: async (accountId: string, xKillbillCreatedBy: string, targetDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('createFutureInvoiceGroup', 'accountId', accountId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('createFutureInvoiceGroup', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/invoices/group`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (targetDate !== undefined) {
                localVarQueryParameter['targetDate'] = (targetDate as any instanceof Date) ?
                    (targetDate as any).toISOString().substr(0,10) :
                    targetDate;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Trigger a payment for invoice
         * @param {InvoicePayment} body 
         * @param {string} invoiceId 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [externalPayment] 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInstantPayment: async (body: InvoicePayment, invoiceId: string, xKillbillCreatedBy: string, externalPayment?: boolean, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createInstantPayment', 'body', body)
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('createInstantPayment', 'invoiceId', invoiceId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('createInstantPayment', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/invoices/{invoiceId}/payments`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (externalPayment !== undefined) {
                localVarQueryParameter['externalPayment'] = externalPayment;
            }

            if (controlPluginName) {
                localVarQueryParameter['controlPluginName'] = controlPluginName;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add custom fields to invoice
         * @param {Array<CustomField>} body 
         * @param {string} invoiceId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoiceCustomFields: async (body: Array<CustomField>, invoiceId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createInvoiceCustomFields', 'body', body)
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('createInvoiceCustomFields', 'invoiceId', invoiceId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('createInvoiceCustomFields', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/invoices/{invoiceId}/customFields`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add tags to invoice
         * @param {Array<string>} body 
         * @param {string} invoiceId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoiceTags: async (body: Array<string>, invoiceId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createInvoiceTags', 'body', body)
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('createInvoiceTags', 'invoiceId', invoiceId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('createInvoiceTags', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/invoices/{invoiceId}/tags`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a migration invoice
         * @param {Array<InvoiceItem>} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [targetDate] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMigrationInvoice: async (body: Array<InvoiceItem>, accountId: string, xKillbillCreatedBy: string, targetDate?: string, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createMigrationInvoice', 'body', body)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('createMigrationInvoice', 'accountId', accountId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('createMigrationInvoice', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/invoices/migration/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (targetDate !== undefined) {
                localVarQueryParameter['targetDate'] = (targetDate as any instanceof Date) ?
                    (targetDate as any).toISOString().substr(0,10) :
                    targetDate;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create tax items
         * @param {Array<InvoiceItem>} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [autoCommit] 
         * @param {string} [requestedDate] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTaxItems: async (body: Array<InvoiceItem>, accountId: string, xKillbillCreatedBy: string, autoCommit?: boolean, requestedDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createTaxItems', 'body', body)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('createTaxItems', 'accountId', accountId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('createTaxItems', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/invoices/taxes/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (autoCommit !== undefined) {
                localVarQueryParameter['autoCommit'] = autoCommit;
            }

            if (requestedDate !== undefined) {
                localVarQueryParameter['requestedDate'] = (requestedDate as any instanceof Date) ?
                    (requestedDate as any).toISOString().substr(0,10) :
                    requestedDate;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a CBA item
         * @param {string} invoiceId 
         * @param {string} invoiceItemId 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCBA: async (invoiceId: string, invoiceItemId: string, accountId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('deleteCBA', 'invoiceId', invoiceId)
            // verify required parameter 'invoiceItemId' is not null or undefined
            assertParamExists('deleteCBA', 'invoiceItemId', invoiceItemId)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('deleteCBA', 'accountId', accountId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('deleteCBA', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/invoices/{invoiceId}/{invoiceItemId}/cba`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)))
                .replace(`{${"invoiceItemId"}}`, encodeURIComponent(String(invoiceItemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove custom fields from invoice
         * @param {string} invoiceId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [customField] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoiceCustomFields: async (invoiceId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('deleteInvoiceCustomFields', 'invoiceId', invoiceId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('deleteInvoiceCustomFields', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/invoices/{invoiceId}/customFields`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (customField) {
                localVarQueryParameter['customField'] = customField;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove tags from invoice
         * @param {string} invoiceId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [tagDef] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoiceTags: async (invoiceId: string, xKillbillCreatedBy: string, tagDef?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('deleteInvoiceTags', 'invoiceId', invoiceId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('deleteInvoiceTags', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/invoices/{invoiceId}/tags`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (tagDef) {
                localVarQueryParameter['tagDef'] = tagDef;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Generate a dryRun invoice
         * @param {InvoiceDryRun} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [targetDate] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateDryRunInvoice: async (body: InvoiceDryRun, accountId: string, xKillbillCreatedBy: string, targetDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('generateDryRunInvoice', 'body', body)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('generateDryRunInvoice', 'accountId', accountId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('generateDryRunInvoice', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/invoices/dryRun`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (targetDate !== undefined) {
                localVarQueryParameter['targetDate'] = (targetDate as any instanceof Date) ?
                    (targetDate as any).toISOString().substr(0,10) :
                    targetDate;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves the catalog translation for the tenant
         * @param {string} locale 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCatalogTranslation: async (locale: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locale' is not null or undefined
            assertParamExists('getCatalogTranslation', 'locale', locale)
            const localVarPath = `/1.0/kb/invoices/catalogTranslation/{locale}`
                .replace(`{${"locale"}}`, encodeURIComponent(String(locale)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an invoice by id
         * @param {string} invoiceId 
         * @param {boolean} [withChildrenItems] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoice: async (invoiceId: string, withChildrenItems?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('getInvoice', 'invoiceId', invoiceId)
            const localVarPath = `/1.0/kb/invoices/{invoiceId}`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (withChildrenItems !== undefined) {
                localVarQueryParameter['withChildrenItems'] = withChildrenItems;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Render an invoice as HTML
         * @param {string} invoiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceAsHTML: async (invoiceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('getInvoiceAsHTML', 'invoiceId', invoiceId)
            const localVarPath = `/1.0/kb/invoices/{invoiceId}/html`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve invoice audit logs with history by id
         * @param {string} invoiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceAuditLogsWithHistory: async (invoiceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('getInvoiceAuditLogsWithHistory', 'invoiceId', invoiceId)
            const localVarPath = `/1.0/kb/invoices/{invoiceId}/auditLogsWithHistory`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an invoice by invoice item id
         * @param {string} itemId 
         * @param {boolean} [withChildrenItems] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceByItemId: async (itemId: string, withChildrenItems?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('getInvoiceByItemId', 'itemId', itemId)
            const localVarPath = `/1.0/kb/invoices/byItemId/{itemId}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (withChildrenItems !== undefined) {
                localVarQueryParameter['withChildrenItems'] = withChildrenItems;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an invoice by number
         * @param {number} invoiceNumber 
         * @param {boolean} [withChildrenItems] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceByNumber: async (invoiceNumber: number, withChildrenItems?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceNumber' is not null or undefined
            assertParamExists('getInvoiceByNumber', 'invoiceNumber', invoiceNumber)
            const localVarPath = `/1.0/kb/invoices/byNumber/{invoiceNumber}`
                .replace(`{${"invoiceNumber"}}`, encodeURIComponent(String(invoiceNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (withChildrenItems !== undefined) {
                localVarQueryParameter['withChildrenItems'] = withChildrenItems;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve invoice custom fields
         * @param {string} invoiceId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceCustomFields: async (invoiceId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('getInvoiceCustomFields', 'invoiceId', invoiceId)
            const localVarPath = `/1.0/kb/invoices/{invoiceId}/customFields`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves the manualPay invoice template for the tenant
         * @param {string} locale 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceMPTemplate: async (locale: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locale' is not null or undefined
            assertParamExists('getInvoiceMPTemplate', 'locale', locale)
            const localVarPath = `/1.0/kb/invoices/manualPayTemplate/{locale}`
                .replace(`{${"locale"}}`, encodeURIComponent(String(locale)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve invoice tags
         * @param {string} invoiceId 
         * @param {boolean} [includedDeleted] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceTags: async (invoiceId: string, includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('getInvoiceTags', 'invoiceId', invoiceId)
            const localVarPath = `/1.0/kb/invoices/{invoiceId}/tags`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (includedDeleted !== undefined) {
                localVarQueryParameter['includedDeleted'] = includedDeleted;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves the invoice template for the tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceTemplate: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/1.0/kb/invoices/template`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves the invoice translation for the tenant
         * @param {string} locale 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceTranslation: async (locale: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locale' is not null or undefined
            assertParamExists('getInvoiceTranslation', 'locale', locale)
            const localVarPath = `/1.0/kb/invoices/translation/{locale}`
                .replace(`{${"locale"}}`, encodeURIComponent(String(locale)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List invoices
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoices: async (offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/1.0/kb/invoices/pagination`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a set of invoices by group id
         * @param {string} groupId 
         * @param {string} accountId 
         * @param {boolean} [withChildrenItems] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoicesGroup: async (groupId: string, accountId: string, withChildrenItems?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getInvoicesGroup', 'groupId', groupId)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getInvoicesGroup', 'accountId', accountId)
            const localVarPath = `/1.0/kb/invoices/{groupId}/group`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (withChildrenItems !== undefined) {
                localVarQueryParameter['withChildrenItems'] = withChildrenItems;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve payments associated with an invoice
         * @param {string} invoiceId 
         * @param {boolean} [withPluginInfo] 
         * @param {boolean} [withAttempts] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentsForInvoice: async (invoiceId: string, withPluginInfo?: boolean, withAttempts?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('getPaymentsForInvoice', 'invoiceId', invoiceId)
            const localVarPath = `/1.0/kb/invoices/{invoiceId}/payments`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (withPluginInfo !== undefined) {
                localVarQueryParameter['withPluginInfo'] = withPluginInfo;
            }

            if (withAttempts !== undefined) {
                localVarQueryParameter['withAttempts'] = withAttempts;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modify custom fields to invoice
         * @param {Array<CustomField>} body 
         * @param {string} invoiceId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyInvoiceCustomFields: async (body: Array<CustomField>, invoiceId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('modifyInvoiceCustomFields', 'body', body)
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('modifyInvoiceCustomFields', 'invoiceId', invoiceId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('modifyInvoiceCustomFields', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/invoices/{invoiceId}/customFields`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search invoices
         * @param {string} searchKey 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchInvoices: async (searchKey: string, offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchKey' is not null or undefined
            assertParamExists('searchInvoices', 'searchKey', searchKey)
            const localVarPath = `/1.0/kb/invoices/search/{searchKey}`
                .replace(`{${"searchKey"}}`, encodeURIComponent(String(searchKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload the catalog translation for the tenant
         * @param {string} body 
         * @param {string} locale 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [deleteIfExists] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadCatalogTranslation: async (body: string, locale: string, xKillbillCreatedBy: string, deleteIfExists?: boolean, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('uploadCatalogTranslation', 'body', body)
            // verify required parameter 'locale' is not null or undefined
            assertParamExists('uploadCatalogTranslation', 'locale', locale)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('uploadCatalogTranslation', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/invoices/catalogTranslation/{locale}`
                .replace(`{${"locale"}}`, encodeURIComponent(String(locale)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (deleteIfExists !== undefined) {
                localVarQueryParameter['deleteIfExists'] = deleteIfExists;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'text/plain';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload the manualPay invoice template for the tenant
         * @param {string} body 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [deleteIfExists] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadInvoiceMPTemplate: async (body: string, xKillbillCreatedBy: string, deleteIfExists?: boolean, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('uploadInvoiceMPTemplate', 'body', body)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('uploadInvoiceMPTemplate', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/invoices/manualPayTemplate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (deleteIfExists !== undefined) {
                localVarQueryParameter['deleteIfExists'] = deleteIfExists;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'text/html';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload the invoice template for the tenant
         * @param {string} body 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [deleteIfExists] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadInvoiceTemplate: async (body: string, xKillbillCreatedBy: string, deleteIfExists?: boolean, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('uploadInvoiceTemplate', 'body', body)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('uploadInvoiceTemplate', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/invoices/template`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (deleteIfExists !== undefined) {
                localVarQueryParameter['deleteIfExists'] = deleteIfExists;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'text/html';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload the invoice translation for the tenant
         * @param {string} body 
         * @param {string} locale 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [deleteIfExists] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadInvoiceTranslation: async (body: string, locale: string, xKillbillCreatedBy: string, deleteIfExists?: boolean, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('uploadInvoiceTranslation', 'body', body)
            // verify required parameter 'locale' is not null or undefined
            assertParamExists('uploadInvoiceTranslation', 'locale', locale)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('uploadInvoiceTranslation', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/invoices/translation/{locale}`
                .replace(`{${"locale"}}`, encodeURIComponent(String(locale)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (deleteIfExists !== undefined) {
                localVarQueryParameter['deleteIfExists'] = deleteIfExists;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'text/plain';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Perform the action of voiding an invoice
         * @param {string} invoiceId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voidInvoice: async (invoiceId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('voidInvoice', 'invoiceId', invoiceId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('voidInvoice', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/invoices/{invoiceId}/voidInvoice`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InvoiceApi - functional programming interface
 * @export
 */
export const InvoiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InvoiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Adjust an invoice item
         * @param {InvoiceItem} body 
         * @param {string} invoiceId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [requestedDate] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adjustInvoiceItem(body: InvoiceItem, invoiceId: string, xKillbillCreatedBy: string, requestedDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Invoice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adjustInvoiceItem(body, invoiceId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Perform the invoice status transition from DRAFT to COMMITTED
         * @param {string} invoiceId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async commitInvoice(invoiceId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.commitInvoice(invoiceId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create external charge(s)
         * @param {Array<InvoiceItem>} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [requestedDate] 
         * @param {boolean} [autoCommit] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createExternalCharges(body: Array<InvoiceItem>, accountId: string, xKillbillCreatedBy: string, requestedDate?: string, autoCommit?: boolean, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InvoiceItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createExternalCharges(body, accountId, xKillbillCreatedBy, requestedDate, autoCommit, pluginProperty, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Trigger an invoice generation
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [targetDate] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFutureInvoice(accountId: string, xKillbillCreatedBy: string, targetDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Invoice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFutureInvoice(accountId, xKillbillCreatedBy, targetDate, pluginProperty, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Trigger an invoice generation
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [targetDate] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFutureInvoiceGroup(accountId: string, xKillbillCreatedBy: string, targetDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Invoice>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFutureInvoiceGroup(accountId, xKillbillCreatedBy, targetDate, pluginProperty, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Trigger a payment for invoice
         * @param {InvoicePayment} body 
         * @param {string} invoiceId 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [externalPayment] 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createInstantPayment(body: InvoicePayment, invoiceId: string, xKillbillCreatedBy: string, externalPayment?: boolean, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoicePayment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createInstantPayment(body, invoiceId, xKillbillCreatedBy, externalPayment, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add custom fields to invoice
         * @param {Array<CustomField>} body 
         * @param {string} invoiceId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createInvoiceCustomFields(body: Array<CustomField>, invoiceId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CustomField>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createInvoiceCustomFields(body, invoiceId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add tags to invoice
         * @param {Array<string>} body 
         * @param {string} invoiceId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createInvoiceTags(body: Array<string>, invoiceId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createInvoiceTags(body, invoiceId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a migration invoice
         * @param {Array<InvoiceItem>} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [targetDate] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMigrationInvoice(body: Array<InvoiceItem>, accountId: string, xKillbillCreatedBy: string, targetDate?: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Invoice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMigrationInvoice(body, accountId, xKillbillCreatedBy, targetDate, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create tax items
         * @param {Array<InvoiceItem>} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [autoCommit] 
         * @param {string} [requestedDate] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTaxItems(body: Array<InvoiceItem>, accountId: string, xKillbillCreatedBy: string, autoCommit?: boolean, requestedDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InvoiceItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTaxItems(body, accountId, xKillbillCreatedBy, autoCommit, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a CBA item
         * @param {string} invoiceId 
         * @param {string} invoiceItemId 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCBA(invoiceId: string, invoiceItemId: string, accountId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCBA(invoiceId, invoiceItemId, accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove custom fields from invoice
         * @param {string} invoiceId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [customField] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteInvoiceCustomFields(invoiceId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteInvoiceCustomFields(invoiceId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove tags from invoice
         * @param {string} invoiceId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [tagDef] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteInvoiceTags(invoiceId: string, xKillbillCreatedBy: string, tagDef?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteInvoiceTags(invoiceId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Generate a dryRun invoice
         * @param {InvoiceDryRun} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [targetDate] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateDryRunInvoice(body: InvoiceDryRun, accountId: string, xKillbillCreatedBy: string, targetDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Invoice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateDryRunInvoice(body, accountId, xKillbillCreatedBy, targetDate, pluginProperty, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieves the catalog translation for the tenant
         * @param {string} locale 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCatalogTranslation(locale: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCatalogTranslation(locale, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve an invoice by id
         * @param {string} invoiceId 
         * @param {boolean} [withChildrenItems] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvoice(invoiceId: string, withChildrenItems?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Invoice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInvoice(invoiceId, withChildrenItems, audit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Render an invoice as HTML
         * @param {string} invoiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvoiceAsHTML(invoiceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInvoiceAsHTML(invoiceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve invoice audit logs with history by id
         * @param {string} invoiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvoiceAuditLogsWithHistory(invoiceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AuditLog>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInvoiceAuditLogsWithHistory(invoiceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve an invoice by invoice item id
         * @param {string} itemId 
         * @param {boolean} [withChildrenItems] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvoiceByItemId(itemId: string, withChildrenItems?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Invoice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInvoiceByItemId(itemId, withChildrenItems, audit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve an invoice by number
         * @param {number} invoiceNumber 
         * @param {boolean} [withChildrenItems] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvoiceByNumber(invoiceNumber: number, withChildrenItems?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Invoice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInvoiceByNumber(invoiceNumber, withChildrenItems, audit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve invoice custom fields
         * @param {string} invoiceId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvoiceCustomFields(invoiceId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CustomField>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInvoiceCustomFields(invoiceId, audit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieves the manualPay invoice template for the tenant
         * @param {string} locale 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvoiceMPTemplate(locale: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInvoiceMPTemplate(locale, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve invoice tags
         * @param {string} invoiceId 
         * @param {boolean} [includedDeleted] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvoiceTags(invoiceId: string, includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInvoiceTags(invoiceId, includedDeleted, audit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieves the invoice template for the tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvoiceTemplate(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInvoiceTemplate(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieves the invoice translation for the tenant
         * @param {string} locale 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvoiceTranslation(locale: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInvoiceTranslation(locale, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List invoices
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvoices(offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Invoice>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInvoices(offset, limit, audit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a set of invoices by group id
         * @param {string} groupId 
         * @param {string} accountId 
         * @param {boolean} [withChildrenItems] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvoicesGroup(groupId: string, accountId: string, withChildrenItems?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Invoice>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInvoicesGroup(groupId, accountId, withChildrenItems, audit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve payments associated with an invoice
         * @param {string} invoiceId 
         * @param {boolean} [withPluginInfo] 
         * @param {boolean} [withAttempts] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentsForInvoice(invoiceId: string, withPluginInfo?: boolean, withAttempts?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InvoicePayment>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPaymentsForInvoice(invoiceId, withPluginInfo, withAttempts, audit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Modify custom fields to invoice
         * @param {Array<CustomField>} body 
         * @param {string} invoiceId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyInvoiceCustomFields(body: Array<CustomField>, invoiceId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifyInvoiceCustomFields(body, invoiceId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Search invoices
         * @param {string} searchKey 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchInvoices(searchKey: string, offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Invoice>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchInvoices(searchKey, offset, limit, audit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Upload the catalog translation for the tenant
         * @param {string} body 
         * @param {string} locale 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [deleteIfExists] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadCatalogTranslation(body: string, locale: string, xKillbillCreatedBy: string, deleteIfExists?: boolean, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadCatalogTranslation(body, locale, xKillbillCreatedBy, deleteIfExists, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Upload the manualPay invoice template for the tenant
         * @param {string} body 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [deleteIfExists] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadInvoiceMPTemplate(body: string, xKillbillCreatedBy: string, deleteIfExists?: boolean, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadInvoiceMPTemplate(body, xKillbillCreatedBy, deleteIfExists, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Upload the invoice template for the tenant
         * @param {string} body 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [deleteIfExists] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadInvoiceTemplate(body: string, xKillbillCreatedBy: string, deleteIfExists?: boolean, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadInvoiceTemplate(body, xKillbillCreatedBy, deleteIfExists, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Upload the invoice translation for the tenant
         * @param {string} body 
         * @param {string} locale 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [deleteIfExists] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadInvoiceTranslation(body: string, locale: string, xKillbillCreatedBy: string, deleteIfExists?: boolean, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadInvoiceTranslation(body, locale, xKillbillCreatedBy, deleteIfExists, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Perform the action of voiding an invoice
         * @param {string} invoiceId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async voidInvoice(invoiceId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.voidInvoice(invoiceId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InvoiceApi - factory interface
 * @export
 */
export const InvoiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InvoiceApiFp(configuration)
    return {
        /**
         * 
         * @summary Adjust an invoice item
         * @param {InvoiceItem} body 
         * @param {string} invoiceId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [requestedDate] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adjustInvoiceItem(body: InvoiceItem, invoiceId: string, xKillbillCreatedBy: string, requestedDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Invoice> {
            return localVarFp.adjustInvoiceItem(body, invoiceId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Perform the invoice status transition from DRAFT to COMMITTED
         * @param {string} invoiceId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commitInvoice(invoiceId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.commitInvoice(invoiceId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create external charge(s)
         * @param {Array<InvoiceItem>} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [requestedDate] 
         * @param {boolean} [autoCommit] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExternalCharges(body: Array<InvoiceItem>, accountId: string, xKillbillCreatedBy: string, requestedDate?: string, autoCommit?: boolean, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Array<InvoiceItem>> {
            return localVarFp.createExternalCharges(body, accountId, xKillbillCreatedBy, requestedDate, autoCommit, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Trigger an invoice generation
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [targetDate] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFutureInvoice(accountId: string, xKillbillCreatedBy: string, targetDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Invoice> {
            return localVarFp.createFutureInvoice(accountId, xKillbillCreatedBy, targetDate, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Trigger an invoice generation
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [targetDate] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFutureInvoiceGroup(accountId: string, xKillbillCreatedBy: string, targetDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Array<Invoice>> {
            return localVarFp.createFutureInvoiceGroup(accountId, xKillbillCreatedBy, targetDate, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Trigger a payment for invoice
         * @param {InvoicePayment} body 
         * @param {string} invoiceId 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [externalPayment] 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInstantPayment(body: InvoicePayment, invoiceId: string, xKillbillCreatedBy: string, externalPayment?: boolean, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<InvoicePayment> {
            return localVarFp.createInstantPayment(body, invoiceId, xKillbillCreatedBy, externalPayment, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add custom fields to invoice
         * @param {Array<CustomField>} body 
         * @param {string} invoiceId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoiceCustomFields(body: Array<CustomField>, invoiceId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Array<CustomField>> {
            return localVarFp.createInvoiceCustomFields(body, invoiceId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add tags to invoice
         * @param {Array<string>} body 
         * @param {string} invoiceId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoiceTags(body: Array<string>, invoiceId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.createInvoiceTags(body, invoiceId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a migration invoice
         * @param {Array<InvoiceItem>} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [targetDate] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMigrationInvoice(body: Array<InvoiceItem>, accountId: string, xKillbillCreatedBy: string, targetDate?: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Invoice> {
            return localVarFp.createMigrationInvoice(body, accountId, xKillbillCreatedBy, targetDate, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create tax items
         * @param {Array<InvoiceItem>} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [autoCommit] 
         * @param {string} [requestedDate] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTaxItems(body: Array<InvoiceItem>, accountId: string, xKillbillCreatedBy: string, autoCommit?: boolean, requestedDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Array<InvoiceItem>> {
            return localVarFp.createTaxItems(body, accountId, xKillbillCreatedBy, autoCommit, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a CBA item
         * @param {string} invoiceId 
         * @param {string} invoiceItemId 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCBA(invoiceId: string, invoiceItemId: string, accountId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCBA(invoiceId, invoiceItemId, accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove custom fields from invoice
         * @param {string} invoiceId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [customField] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoiceCustomFields(invoiceId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteInvoiceCustomFields(invoiceId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove tags from invoice
         * @param {string} invoiceId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [tagDef] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoiceTags(invoiceId: string, xKillbillCreatedBy: string, tagDef?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteInvoiceTags(invoiceId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Generate a dryRun invoice
         * @param {InvoiceDryRun} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [targetDate] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateDryRunInvoice(body: InvoiceDryRun, accountId: string, xKillbillCreatedBy: string, targetDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Invoice> {
            return localVarFp.generateDryRunInvoice(body, accountId, xKillbillCreatedBy, targetDate, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves the catalog translation for the tenant
         * @param {string} locale 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCatalogTranslation(locale: string, options?: any): AxiosPromise<string> {
            return localVarFp.getCatalogTranslation(locale, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an invoice by id
         * @param {string} invoiceId 
         * @param {boolean} [withChildrenItems] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoice(invoiceId: string, withChildrenItems?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Invoice> {
            return localVarFp.getInvoice(invoiceId, withChildrenItems, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Render an invoice as HTML
         * @param {string} invoiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceAsHTML(invoiceId: string, options?: any): AxiosPromise<string> {
            return localVarFp.getInvoiceAsHTML(invoiceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve invoice audit logs with history by id
         * @param {string} invoiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceAuditLogsWithHistory(invoiceId: string, options?: any): AxiosPromise<Array<AuditLog>> {
            return localVarFp.getInvoiceAuditLogsWithHistory(invoiceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an invoice by invoice item id
         * @param {string} itemId 
         * @param {boolean} [withChildrenItems] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceByItemId(itemId: string, withChildrenItems?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Invoice> {
            return localVarFp.getInvoiceByItemId(itemId, withChildrenItems, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an invoice by number
         * @param {number} invoiceNumber 
         * @param {boolean} [withChildrenItems] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceByNumber(invoiceNumber: number, withChildrenItems?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Invoice> {
            return localVarFp.getInvoiceByNumber(invoiceNumber, withChildrenItems, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve invoice custom fields
         * @param {string} invoiceId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceCustomFields(invoiceId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<CustomField>> {
            return localVarFp.getInvoiceCustomFields(invoiceId, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves the manualPay invoice template for the tenant
         * @param {string} locale 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceMPTemplate(locale: string, options?: any): AxiosPromise<string> {
            return localVarFp.getInvoiceMPTemplate(locale, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve invoice tags
         * @param {string} invoiceId 
         * @param {boolean} [includedDeleted] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceTags(invoiceId: string, includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.getInvoiceTags(invoiceId, includedDeleted, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves the invoice template for the tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceTemplate(options?: any): AxiosPromise<string> {
            return localVarFp.getInvoiceTemplate(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves the invoice translation for the tenant
         * @param {string} locale 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceTranslation(locale: string, options?: any): AxiosPromise<string> {
            return localVarFp.getInvoiceTranslation(locale, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List invoices
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoices(offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<Invoice>> {
            return localVarFp.getInvoices(offset, limit, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a set of invoices by group id
         * @param {string} groupId 
         * @param {string} accountId 
         * @param {boolean} [withChildrenItems] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoicesGroup(groupId: string, accountId: string, withChildrenItems?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<Invoice>> {
            return localVarFp.getInvoicesGroup(groupId, accountId, withChildrenItems, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve payments associated with an invoice
         * @param {string} invoiceId 
         * @param {boolean} [withPluginInfo] 
         * @param {boolean} [withAttempts] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentsForInvoice(invoiceId: string, withPluginInfo?: boolean, withAttempts?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<InvoicePayment>> {
            return localVarFp.getPaymentsForInvoice(invoiceId, withPluginInfo, withAttempts, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Modify custom fields to invoice
         * @param {Array<CustomField>} body 
         * @param {string} invoiceId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyInvoiceCustomFields(body: Array<CustomField>, invoiceId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.modifyInvoiceCustomFields(body, invoiceId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search invoices
         * @param {string} searchKey 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchInvoices(searchKey: string, offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<Invoice>> {
            return localVarFp.searchInvoices(searchKey, offset, limit, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload the catalog translation for the tenant
         * @param {string} body 
         * @param {string} locale 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [deleteIfExists] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadCatalogTranslation(body: string, locale: string, xKillbillCreatedBy: string, deleteIfExists?: boolean, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<string> {
            return localVarFp.uploadCatalogTranslation(body, locale, xKillbillCreatedBy, deleteIfExists, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload the manualPay invoice template for the tenant
         * @param {string} body 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [deleteIfExists] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadInvoiceMPTemplate(body: string, xKillbillCreatedBy: string, deleteIfExists?: boolean, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<string> {
            return localVarFp.uploadInvoiceMPTemplate(body, xKillbillCreatedBy, deleteIfExists, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload the invoice template for the tenant
         * @param {string} body 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [deleteIfExists] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadInvoiceTemplate(body: string, xKillbillCreatedBy: string, deleteIfExists?: boolean, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<string> {
            return localVarFp.uploadInvoiceTemplate(body, xKillbillCreatedBy, deleteIfExists, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload the invoice translation for the tenant
         * @param {string} body 
         * @param {string} locale 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [deleteIfExists] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadInvoiceTranslation(body: string, locale: string, xKillbillCreatedBy: string, deleteIfExists?: boolean, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<string> {
            return localVarFp.uploadInvoiceTranslation(body, locale, xKillbillCreatedBy, deleteIfExists, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Perform the action of voiding an invoice
         * @param {string} invoiceId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voidInvoice(invoiceId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.voidInvoice(invoiceId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InvoiceApi - object-oriented interface
 * @export
 * @class InvoiceApi
 * @extends {BaseAPI}
 */
export class InvoiceApi extends BaseAPI {
    /**
     * 
     * @summary Adjust an invoice item
     * @param {InvoiceItem} body 
     * @param {string} invoiceId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [requestedDate] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public adjustInvoiceItem(body: InvoiceItem, invoiceId: string, xKillbillCreatedBy: string, requestedDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return InvoiceApiFp(this.configuration).adjustInvoiceItem(body, invoiceId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Perform the invoice status transition from DRAFT to COMMITTED
     * @param {string} invoiceId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public commitInvoice(invoiceId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return InvoiceApiFp(this.configuration).commitInvoice(invoiceId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create external charge(s)
     * @param {Array<InvoiceItem>} body 
     * @param {string} accountId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [requestedDate] 
     * @param {boolean} [autoCommit] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public createExternalCharges(body: Array<InvoiceItem>, accountId: string, xKillbillCreatedBy: string, requestedDate?: string, autoCommit?: boolean, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return InvoiceApiFp(this.configuration).createExternalCharges(body, accountId, xKillbillCreatedBy, requestedDate, autoCommit, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Trigger an invoice generation
     * @param {string} accountId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [targetDate] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public createFutureInvoice(accountId: string, xKillbillCreatedBy: string, targetDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return InvoiceApiFp(this.configuration).createFutureInvoice(accountId, xKillbillCreatedBy, targetDate, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Trigger an invoice generation
     * @param {string} accountId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [targetDate] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public createFutureInvoiceGroup(accountId: string, xKillbillCreatedBy: string, targetDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return InvoiceApiFp(this.configuration).createFutureInvoiceGroup(accountId, xKillbillCreatedBy, targetDate, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Trigger a payment for invoice
     * @param {InvoicePayment} body 
     * @param {string} invoiceId 
     * @param {string} xKillbillCreatedBy 
     * @param {boolean} [externalPayment] 
     * @param {Array<string>} [controlPluginName] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public createInstantPayment(body: InvoicePayment, invoiceId: string, xKillbillCreatedBy: string, externalPayment?: boolean, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return InvoiceApiFp(this.configuration).createInstantPayment(body, invoiceId, xKillbillCreatedBy, externalPayment, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add custom fields to invoice
     * @param {Array<CustomField>} body 
     * @param {string} invoiceId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public createInvoiceCustomFields(body: Array<CustomField>, invoiceId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return InvoiceApiFp(this.configuration).createInvoiceCustomFields(body, invoiceId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add tags to invoice
     * @param {Array<string>} body 
     * @param {string} invoiceId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public createInvoiceTags(body: Array<string>, invoiceId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return InvoiceApiFp(this.configuration).createInvoiceTags(body, invoiceId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a migration invoice
     * @param {Array<InvoiceItem>} body 
     * @param {string} accountId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [targetDate] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public createMigrationInvoice(body: Array<InvoiceItem>, accountId: string, xKillbillCreatedBy: string, targetDate?: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return InvoiceApiFp(this.configuration).createMigrationInvoice(body, accountId, xKillbillCreatedBy, targetDate, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create tax items
     * @param {Array<InvoiceItem>} body 
     * @param {string} accountId 
     * @param {string} xKillbillCreatedBy 
     * @param {boolean} [autoCommit] 
     * @param {string} [requestedDate] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public createTaxItems(body: Array<InvoiceItem>, accountId: string, xKillbillCreatedBy: string, autoCommit?: boolean, requestedDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return InvoiceApiFp(this.configuration).createTaxItems(body, accountId, xKillbillCreatedBy, autoCommit, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a CBA item
     * @param {string} invoiceId 
     * @param {string} invoiceItemId 
     * @param {string} accountId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public deleteCBA(invoiceId: string, invoiceItemId: string, accountId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return InvoiceApiFp(this.configuration).deleteCBA(invoiceId, invoiceItemId, accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove custom fields from invoice
     * @param {string} invoiceId 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [customField] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public deleteInvoiceCustomFields(invoiceId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return InvoiceApiFp(this.configuration).deleteInvoiceCustomFields(invoiceId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove tags from invoice
     * @param {string} invoiceId 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [tagDef] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public deleteInvoiceTags(invoiceId: string, xKillbillCreatedBy: string, tagDef?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return InvoiceApiFp(this.configuration).deleteInvoiceTags(invoiceId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Generate a dryRun invoice
     * @param {InvoiceDryRun} body 
     * @param {string} accountId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [targetDate] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public generateDryRunInvoice(body: InvoiceDryRun, accountId: string, xKillbillCreatedBy: string, targetDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return InvoiceApiFp(this.configuration).generateDryRunInvoice(body, accountId, xKillbillCreatedBy, targetDate, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves the catalog translation for the tenant
     * @param {string} locale 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public getCatalogTranslation(locale: string, options?: AxiosRequestConfig) {
        return InvoiceApiFp(this.configuration).getCatalogTranslation(locale, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an invoice by id
     * @param {string} invoiceId 
     * @param {boolean} [withChildrenItems] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public getInvoice(invoiceId: string, withChildrenItems?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig) {
        return InvoiceApiFp(this.configuration).getInvoice(invoiceId, withChildrenItems, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Render an invoice as HTML
     * @param {string} invoiceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public getInvoiceAsHTML(invoiceId: string, options?: AxiosRequestConfig) {
        return InvoiceApiFp(this.configuration).getInvoiceAsHTML(invoiceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve invoice audit logs with history by id
     * @param {string} invoiceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public getInvoiceAuditLogsWithHistory(invoiceId: string, options?: AxiosRequestConfig) {
        return InvoiceApiFp(this.configuration).getInvoiceAuditLogsWithHistory(invoiceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an invoice by invoice item id
     * @param {string} itemId 
     * @param {boolean} [withChildrenItems] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public getInvoiceByItemId(itemId: string, withChildrenItems?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig) {
        return InvoiceApiFp(this.configuration).getInvoiceByItemId(itemId, withChildrenItems, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an invoice by number
     * @param {number} invoiceNumber 
     * @param {boolean} [withChildrenItems] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public getInvoiceByNumber(invoiceNumber: number, withChildrenItems?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig) {
        return InvoiceApiFp(this.configuration).getInvoiceByNumber(invoiceNumber, withChildrenItems, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve invoice custom fields
     * @param {string} invoiceId 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public getInvoiceCustomFields(invoiceId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig) {
        return InvoiceApiFp(this.configuration).getInvoiceCustomFields(invoiceId, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves the manualPay invoice template for the tenant
     * @param {string} locale 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public getInvoiceMPTemplate(locale: string, options?: AxiosRequestConfig) {
        return InvoiceApiFp(this.configuration).getInvoiceMPTemplate(locale, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve invoice tags
     * @param {string} invoiceId 
     * @param {boolean} [includedDeleted] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public getInvoiceTags(invoiceId: string, includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig) {
        return InvoiceApiFp(this.configuration).getInvoiceTags(invoiceId, includedDeleted, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves the invoice template for the tenant
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public getInvoiceTemplate(options?: AxiosRequestConfig) {
        return InvoiceApiFp(this.configuration).getInvoiceTemplate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves the invoice translation for the tenant
     * @param {string} locale 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public getInvoiceTranslation(locale: string, options?: AxiosRequestConfig) {
        return InvoiceApiFp(this.configuration).getInvoiceTranslation(locale, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List invoices
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public getInvoices(offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig) {
        return InvoiceApiFp(this.configuration).getInvoices(offset, limit, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a set of invoices by group id
     * @param {string} groupId 
     * @param {string} accountId 
     * @param {boolean} [withChildrenItems] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public getInvoicesGroup(groupId: string, accountId: string, withChildrenItems?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig) {
        return InvoiceApiFp(this.configuration).getInvoicesGroup(groupId, accountId, withChildrenItems, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve payments associated with an invoice
     * @param {string} invoiceId 
     * @param {boolean} [withPluginInfo] 
     * @param {boolean} [withAttempts] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public getPaymentsForInvoice(invoiceId: string, withPluginInfo?: boolean, withAttempts?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig) {
        return InvoiceApiFp(this.configuration).getPaymentsForInvoice(invoiceId, withPluginInfo, withAttempts, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Modify custom fields to invoice
     * @param {Array<CustomField>} body 
     * @param {string} invoiceId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public modifyInvoiceCustomFields(body: Array<CustomField>, invoiceId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return InvoiceApiFp(this.configuration).modifyInvoiceCustomFields(body, invoiceId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search invoices
     * @param {string} searchKey 
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public searchInvoices(searchKey: string, offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig) {
        return InvoiceApiFp(this.configuration).searchInvoices(searchKey, offset, limit, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload the catalog translation for the tenant
     * @param {string} body 
     * @param {string} locale 
     * @param {string} xKillbillCreatedBy 
     * @param {boolean} [deleteIfExists] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public uploadCatalogTranslation(body: string, locale: string, xKillbillCreatedBy: string, deleteIfExists?: boolean, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return InvoiceApiFp(this.configuration).uploadCatalogTranslation(body, locale, xKillbillCreatedBy, deleteIfExists, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload the manualPay invoice template for the tenant
     * @param {string} body 
     * @param {string} xKillbillCreatedBy 
     * @param {boolean} [deleteIfExists] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public uploadInvoiceMPTemplate(body: string, xKillbillCreatedBy: string, deleteIfExists?: boolean, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return InvoiceApiFp(this.configuration).uploadInvoiceMPTemplate(body, xKillbillCreatedBy, deleteIfExists, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload the invoice template for the tenant
     * @param {string} body 
     * @param {string} xKillbillCreatedBy 
     * @param {boolean} [deleteIfExists] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public uploadInvoiceTemplate(body: string, xKillbillCreatedBy: string, deleteIfExists?: boolean, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return InvoiceApiFp(this.configuration).uploadInvoiceTemplate(body, xKillbillCreatedBy, deleteIfExists, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload the invoice translation for the tenant
     * @param {string} body 
     * @param {string} locale 
     * @param {string} xKillbillCreatedBy 
     * @param {boolean} [deleteIfExists] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public uploadInvoiceTranslation(body: string, locale: string, xKillbillCreatedBy: string, deleteIfExists?: boolean, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return InvoiceApiFp(this.configuration).uploadInvoiceTranslation(body, locale, xKillbillCreatedBy, deleteIfExists, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Perform the action of voiding an invoice
     * @param {string} invoiceId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public voidInvoice(invoiceId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return InvoiceApiFp(this.configuration).voidInvoice(invoiceId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * InvoiceItemApi - axios parameter creator
 * @export
 */
export const InvoiceItemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add custom fields to invoice item
         * @param {Array<CustomField>} body 
         * @param {string} invoiceItemId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoiceItemCustomFields: async (body: Array<CustomField>, invoiceItemId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createInvoiceItemCustomFields', 'body', body)
            // verify required parameter 'invoiceItemId' is not null or undefined
            assertParamExists('createInvoiceItemCustomFields', 'invoiceItemId', invoiceItemId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('createInvoiceItemCustomFields', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/invoiceItems/{invoiceItemId}/customFields`
                .replace(`{${"invoiceItemId"}}`, encodeURIComponent(String(invoiceItemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add tags to invoice item
         * @param {Array<string>} body 
         * @param {string} invoiceItemId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoiceItemTags: async (body: Array<string>, invoiceItemId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createInvoiceItemTags', 'body', body)
            // verify required parameter 'invoiceItemId' is not null or undefined
            assertParamExists('createInvoiceItemTags', 'invoiceItemId', invoiceItemId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('createInvoiceItemTags', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/invoiceItems/{invoiceItemId}/tags`
                .replace(`{${"invoiceItemId"}}`, encodeURIComponent(String(invoiceItemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove custom fields from invoice item
         * @param {string} invoiceItemId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [customField] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoiceItemCustomFields: async (invoiceItemId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceItemId' is not null or undefined
            assertParamExists('deleteInvoiceItemCustomFields', 'invoiceItemId', invoiceItemId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('deleteInvoiceItemCustomFields', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/invoiceItems/{invoiceItemId}/customFields`
                .replace(`{${"invoiceItemId"}}`, encodeURIComponent(String(invoiceItemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (customField) {
                localVarQueryParameter['customField'] = customField;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove tags from invoice item
         * @param {string} invoiceItemId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [tagDef] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoiceItemTags: async (invoiceItemId: string, xKillbillCreatedBy: string, tagDef?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceItemId' is not null or undefined
            assertParamExists('deleteInvoiceItemTags', 'invoiceItemId', invoiceItemId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('deleteInvoiceItemTags', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/invoiceItems/{invoiceItemId}/tags`
                .replace(`{${"invoiceItemId"}}`, encodeURIComponent(String(invoiceItemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (tagDef) {
                localVarQueryParameter['tagDef'] = tagDef;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve invoice item audit logs with history by id
         * @param {string} invoiceItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceItemAuditLogsWithHistory: async (invoiceItemId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceItemId' is not null or undefined
            assertParamExists('getInvoiceItemAuditLogsWithHistory', 'invoiceItemId', invoiceItemId)
            const localVarPath = `/1.0/kb/invoiceItems/{invoiceItemId}/auditLogsWithHistory`
                .replace(`{${"invoiceItemId"}}`, encodeURIComponent(String(invoiceItemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve invoice item custom fields
         * @param {string} invoiceItemId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceItemCustomFields: async (invoiceItemId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceItemId' is not null or undefined
            assertParamExists('getInvoiceItemCustomFields', 'invoiceItemId', invoiceItemId)
            const localVarPath = `/1.0/kb/invoiceItems/{invoiceItemId}/customFields`
                .replace(`{${"invoiceItemId"}}`, encodeURIComponent(String(invoiceItemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve invoice item tags
         * @param {string} invoiceItemId 
         * @param {string} accountId 
         * @param {boolean} [includedDeleted] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceItemTags: async (invoiceItemId: string, accountId: string, includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceItemId' is not null or undefined
            assertParamExists('getInvoiceItemTags', 'invoiceItemId', invoiceItemId)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getInvoiceItemTags', 'accountId', accountId)
            const localVarPath = `/1.0/kb/invoiceItems/{invoiceItemId}/tags`
                .replace(`{${"invoiceItemId"}}`, encodeURIComponent(String(invoiceItemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (includedDeleted !== undefined) {
                localVarQueryParameter['includedDeleted'] = includedDeleted;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modify custom fields to invoice item
         * @param {Array<CustomField>} body 
         * @param {string} invoiceItemId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyInvoiceItemCustomFields: async (body: Array<CustomField>, invoiceItemId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('modifyInvoiceItemCustomFields', 'body', body)
            // verify required parameter 'invoiceItemId' is not null or undefined
            assertParamExists('modifyInvoiceItemCustomFields', 'invoiceItemId', invoiceItemId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('modifyInvoiceItemCustomFields', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/invoiceItems/{invoiceItemId}/customFields`
                .replace(`{${"invoiceItemId"}}`, encodeURIComponent(String(invoiceItemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InvoiceItemApi - functional programming interface
 * @export
 */
export const InvoiceItemApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InvoiceItemApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add custom fields to invoice item
         * @param {Array<CustomField>} body 
         * @param {string} invoiceItemId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createInvoiceItemCustomFields(body: Array<CustomField>, invoiceItemId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CustomField>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createInvoiceItemCustomFields(body, invoiceItemId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add tags to invoice item
         * @param {Array<string>} body 
         * @param {string} invoiceItemId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createInvoiceItemTags(body: Array<string>, invoiceItemId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createInvoiceItemTags(body, invoiceItemId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove custom fields from invoice item
         * @param {string} invoiceItemId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [customField] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteInvoiceItemCustomFields(invoiceItemId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteInvoiceItemCustomFields(invoiceItemId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove tags from invoice item
         * @param {string} invoiceItemId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [tagDef] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteInvoiceItemTags(invoiceItemId: string, xKillbillCreatedBy: string, tagDef?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteInvoiceItemTags(invoiceItemId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve invoice item audit logs with history by id
         * @param {string} invoiceItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvoiceItemAuditLogsWithHistory(invoiceItemId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AuditLog>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInvoiceItemAuditLogsWithHistory(invoiceItemId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve invoice item custom fields
         * @param {string} invoiceItemId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvoiceItemCustomFields(invoiceItemId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CustomField>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInvoiceItemCustomFields(invoiceItemId, audit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve invoice item tags
         * @param {string} invoiceItemId 
         * @param {string} accountId 
         * @param {boolean} [includedDeleted] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvoiceItemTags(invoiceItemId: string, accountId: string, includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInvoiceItemTags(invoiceItemId, accountId, includedDeleted, audit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Modify custom fields to invoice item
         * @param {Array<CustomField>} body 
         * @param {string} invoiceItemId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyInvoiceItemCustomFields(body: Array<CustomField>, invoiceItemId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifyInvoiceItemCustomFields(body, invoiceItemId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InvoiceItemApi - factory interface
 * @export
 */
export const InvoiceItemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InvoiceItemApiFp(configuration)
    return {
        /**
         * 
         * @summary Add custom fields to invoice item
         * @param {Array<CustomField>} body 
         * @param {string} invoiceItemId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoiceItemCustomFields(body: Array<CustomField>, invoiceItemId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Array<CustomField>> {
            return localVarFp.createInvoiceItemCustomFields(body, invoiceItemId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add tags to invoice item
         * @param {Array<string>} body 
         * @param {string} invoiceItemId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoiceItemTags(body: Array<string>, invoiceItemId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.createInvoiceItemTags(body, invoiceItemId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove custom fields from invoice item
         * @param {string} invoiceItemId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [customField] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoiceItemCustomFields(invoiceItemId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteInvoiceItemCustomFields(invoiceItemId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove tags from invoice item
         * @param {string} invoiceItemId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [tagDef] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoiceItemTags(invoiceItemId: string, xKillbillCreatedBy: string, tagDef?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteInvoiceItemTags(invoiceItemId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve invoice item audit logs with history by id
         * @param {string} invoiceItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceItemAuditLogsWithHistory(invoiceItemId: string, options?: any): AxiosPromise<Array<AuditLog>> {
            return localVarFp.getInvoiceItemAuditLogsWithHistory(invoiceItemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve invoice item custom fields
         * @param {string} invoiceItemId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceItemCustomFields(invoiceItemId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<CustomField>> {
            return localVarFp.getInvoiceItemCustomFields(invoiceItemId, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve invoice item tags
         * @param {string} invoiceItemId 
         * @param {string} accountId 
         * @param {boolean} [includedDeleted] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceItemTags(invoiceItemId: string, accountId: string, includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.getInvoiceItemTags(invoiceItemId, accountId, includedDeleted, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Modify custom fields to invoice item
         * @param {Array<CustomField>} body 
         * @param {string} invoiceItemId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyInvoiceItemCustomFields(body: Array<CustomField>, invoiceItemId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.modifyInvoiceItemCustomFields(body, invoiceItemId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InvoiceItemApi - object-oriented interface
 * @export
 * @class InvoiceItemApi
 * @extends {BaseAPI}
 */
export class InvoiceItemApi extends BaseAPI {
    /**
     * 
     * @summary Add custom fields to invoice item
     * @param {Array<CustomField>} body 
     * @param {string} invoiceItemId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceItemApi
     */
    public createInvoiceItemCustomFields(body: Array<CustomField>, invoiceItemId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return InvoiceItemApiFp(this.configuration).createInvoiceItemCustomFields(body, invoiceItemId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add tags to invoice item
     * @param {Array<string>} body 
     * @param {string} invoiceItemId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceItemApi
     */
    public createInvoiceItemTags(body: Array<string>, invoiceItemId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return InvoiceItemApiFp(this.configuration).createInvoiceItemTags(body, invoiceItemId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove custom fields from invoice item
     * @param {string} invoiceItemId 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [customField] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceItemApi
     */
    public deleteInvoiceItemCustomFields(invoiceItemId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return InvoiceItemApiFp(this.configuration).deleteInvoiceItemCustomFields(invoiceItemId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove tags from invoice item
     * @param {string} invoiceItemId 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [tagDef] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceItemApi
     */
    public deleteInvoiceItemTags(invoiceItemId: string, xKillbillCreatedBy: string, tagDef?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return InvoiceItemApiFp(this.configuration).deleteInvoiceItemTags(invoiceItemId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve invoice item audit logs with history by id
     * @param {string} invoiceItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceItemApi
     */
    public getInvoiceItemAuditLogsWithHistory(invoiceItemId: string, options?: AxiosRequestConfig) {
        return InvoiceItemApiFp(this.configuration).getInvoiceItemAuditLogsWithHistory(invoiceItemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve invoice item custom fields
     * @param {string} invoiceItemId 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceItemApi
     */
    public getInvoiceItemCustomFields(invoiceItemId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig) {
        return InvoiceItemApiFp(this.configuration).getInvoiceItemCustomFields(invoiceItemId, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve invoice item tags
     * @param {string} invoiceItemId 
     * @param {string} accountId 
     * @param {boolean} [includedDeleted] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceItemApi
     */
    public getInvoiceItemTags(invoiceItemId: string, accountId: string, includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig) {
        return InvoiceItemApiFp(this.configuration).getInvoiceItemTags(invoiceItemId, accountId, includedDeleted, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Modify custom fields to invoice item
     * @param {Array<CustomField>} body 
     * @param {string} invoiceItemId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceItemApi
     */
    public modifyInvoiceItemCustomFields(body: Array<CustomField>, invoiceItemId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return InvoiceItemApiFp(this.configuration).modifyInvoiceItemCustomFields(body, invoiceItemId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * InvoicePaymentApi - axios parameter creator
 * @export
 */
export const InvoicePaymentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Complete an existing transaction
         * @param {PaymentTransaction} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeInvoicePaymentTransaction: async (body: PaymentTransaction, paymentId: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('completeInvoicePaymentTransaction', 'body', body)
            // verify required parameter 'paymentId' is not null or undefined
            assertParamExists('completeInvoicePaymentTransaction', 'paymentId', paymentId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('completeInvoicePaymentTransaction', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/invoicePayments/{paymentId}`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (controlPluginName) {
                localVarQueryParameter['controlPluginName'] = controlPluginName;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Record a chargeback
         * @param {InvoicePaymentTransaction} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChargeback: async (body: InvoicePaymentTransaction, paymentId: string, xKillbillCreatedBy: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createChargeback', 'body', body)
            // verify required parameter 'paymentId' is not null or undefined
            assertParamExists('createChargeback', 'paymentId', paymentId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('createChargeback', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/invoicePayments/{paymentId}/chargebacks`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Record a chargebackReversal
         * @param {InvoicePaymentTransaction} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChargebackReversal: async (body: InvoicePaymentTransaction, paymentId: string, xKillbillCreatedBy: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createChargebackReversal', 'body', body)
            // verify required parameter 'paymentId' is not null or undefined
            assertParamExists('createChargebackReversal', 'paymentId', paymentId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('createChargebackReversal', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/invoicePayments/{paymentId}/chargebackReversals`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add custom fields to payment
         * @param {Array<CustomField>} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoicePaymentCustomFields: async (body: Array<CustomField>, paymentId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createInvoicePaymentCustomFields', 'body', body)
            // verify required parameter 'paymentId' is not null or undefined
            assertParamExists('createInvoicePaymentCustomFields', 'paymentId', paymentId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('createInvoicePaymentCustomFields', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/invoicePayments/{paymentId}/customFields`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add tags to payment
         * @param {Array<string>} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoicePaymentTags: async (body: Array<string>, paymentId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createInvoicePaymentTags', 'body', body)
            // verify required parameter 'paymentId' is not null or undefined
            assertParamExists('createInvoicePaymentTags', 'paymentId', paymentId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('createInvoicePaymentTags', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/invoicePayments/{paymentId}/tags`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Refund a payment, and adjust the invoice if needed
         * @param {InvoicePaymentTransaction} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [externalPayment] 
         * @param {string} [paymentMethodId] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRefundWithAdjustments: async (body: InvoicePaymentTransaction, paymentId: string, xKillbillCreatedBy: string, externalPayment?: boolean, paymentMethodId?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createRefundWithAdjustments', 'body', body)
            // verify required parameter 'paymentId' is not null or undefined
            assertParamExists('createRefundWithAdjustments', 'paymentId', paymentId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('createRefundWithAdjustments', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/invoicePayments/{paymentId}/refunds`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (externalPayment !== undefined) {
                localVarQueryParameter['externalPayment'] = externalPayment;
            }

            if (paymentMethodId !== undefined) {
                localVarQueryParameter['paymentMethodId'] = paymentMethodId;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove custom fields from payment
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [customField] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoicePaymentCustomFields: async (paymentId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentId' is not null or undefined
            assertParamExists('deleteInvoicePaymentCustomFields', 'paymentId', paymentId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('deleteInvoicePaymentCustomFields', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/invoicePayments/{paymentId}/customFields`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (customField) {
                localVarQueryParameter['customField'] = customField;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove tags from payment
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [tagDef] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoicePaymentTags: async (paymentId: string, xKillbillCreatedBy: string, tagDef?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentId' is not null or undefined
            assertParamExists('deleteInvoicePaymentTags', 'paymentId', paymentId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('deleteInvoicePaymentTags', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/invoicePayments/{paymentId}/tags`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (tagDef) {
                localVarQueryParameter['tagDef'] = tagDef;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a payment by id
         * @param {string} paymentId 
         * @param {boolean} [withPluginInfo] 
         * @param {boolean} [withAttempts] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoicePayment: async (paymentId: string, withPluginInfo?: boolean, withAttempts?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentId' is not null or undefined
            assertParamExists('getInvoicePayment', 'paymentId', paymentId)
            const localVarPath = `/1.0/kb/invoicePayments/{paymentId}`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (withPluginInfo !== undefined) {
                localVarQueryParameter['withPluginInfo'] = withPluginInfo;
            }

            if (withAttempts !== undefined) {
                localVarQueryParameter['withAttempts'] = withAttempts;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve invoice payment audit logs with history by id
         * @param {string} invoicePaymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoicePaymentAuditLogsWithHistory: async (invoicePaymentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoicePaymentId' is not null or undefined
            assertParamExists('getInvoicePaymentAuditLogsWithHistory', 'invoicePaymentId', invoicePaymentId)
            const localVarPath = `/1.0/kb/invoicePayments/{invoicePaymentId}/auditLogsWithHistory`
                .replace(`{${"invoicePaymentId"}}`, encodeURIComponent(String(invoicePaymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve payment custom fields
         * @param {string} paymentId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoicePaymentCustomFields: async (paymentId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentId' is not null or undefined
            assertParamExists('getInvoicePaymentCustomFields', 'paymentId', paymentId)
            const localVarPath = `/1.0/kb/invoicePayments/{paymentId}/customFields`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve payment tags
         * @param {string} paymentId 
         * @param {boolean} [includedDeleted] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoicePaymentTags: async (paymentId: string, includedDeleted?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentId' is not null or undefined
            assertParamExists('getInvoicePaymentTags', 'paymentId', paymentId)
            const localVarPath = `/1.0/kb/invoicePayments/{paymentId}/tags`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (includedDeleted !== undefined) {
                localVarQueryParameter['includedDeleted'] = includedDeleted;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modify custom fields to payment
         * @param {Array<CustomField>} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyInvoicePaymentCustomFields: async (body: Array<CustomField>, paymentId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('modifyInvoicePaymentCustomFields', 'body', body)
            // verify required parameter 'paymentId' is not null or undefined
            assertParamExists('modifyInvoicePaymentCustomFields', 'paymentId', paymentId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('modifyInvoicePaymentCustomFields', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/invoicePayments/{paymentId}/customFields`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InvoicePaymentApi - functional programming interface
 * @export
 */
export const InvoicePaymentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InvoicePaymentApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Complete an existing transaction
         * @param {PaymentTransaction} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completeInvoicePaymentTransaction(body: PaymentTransaction, paymentId: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completeInvoicePaymentTransaction(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Record a chargeback
         * @param {InvoicePaymentTransaction} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createChargeback(body: InvoicePaymentTransaction, paymentId: string, xKillbillCreatedBy: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoicePayment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createChargeback(body, paymentId, xKillbillCreatedBy, pluginProperty, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Record a chargebackReversal
         * @param {InvoicePaymentTransaction} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createChargebackReversal(body: InvoicePaymentTransaction, paymentId: string, xKillbillCreatedBy: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoicePayment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createChargebackReversal(body, paymentId, xKillbillCreatedBy, pluginProperty, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add custom fields to payment
         * @param {Array<CustomField>} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createInvoicePaymentCustomFields(body: Array<CustomField>, paymentId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CustomField>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createInvoicePaymentCustomFields(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add tags to payment
         * @param {Array<string>} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createInvoicePaymentTags(body: Array<string>, paymentId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createInvoicePaymentTags(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Refund a payment, and adjust the invoice if needed
         * @param {InvoicePaymentTransaction} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [externalPayment] 
         * @param {string} [paymentMethodId] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRefundWithAdjustments(body: InvoicePaymentTransaction, paymentId: string, xKillbillCreatedBy: string, externalPayment?: boolean, paymentMethodId?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoicePayment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRefundWithAdjustments(body, paymentId, xKillbillCreatedBy, externalPayment, paymentMethodId, pluginProperty, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove custom fields from payment
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [customField] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteInvoicePaymentCustomFields(paymentId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteInvoicePaymentCustomFields(paymentId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove tags from payment
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [tagDef] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteInvoicePaymentTags(paymentId: string, xKillbillCreatedBy: string, tagDef?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteInvoicePaymentTags(paymentId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a payment by id
         * @param {string} paymentId 
         * @param {boolean} [withPluginInfo] 
         * @param {boolean} [withAttempts] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvoicePayment(paymentId: string, withPluginInfo?: boolean, withAttempts?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoicePayment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInvoicePayment(paymentId, withPluginInfo, withAttempts, pluginProperty, audit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve invoice payment audit logs with history by id
         * @param {string} invoicePaymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvoicePaymentAuditLogsWithHistory(invoicePaymentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AuditLog>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInvoicePaymentAuditLogsWithHistory(invoicePaymentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve payment custom fields
         * @param {string} paymentId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvoicePaymentCustomFields(paymentId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CustomField>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInvoicePaymentCustomFields(paymentId, audit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve payment tags
         * @param {string} paymentId 
         * @param {boolean} [includedDeleted] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvoicePaymentTags(paymentId: string, includedDeleted?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInvoicePaymentTags(paymentId, includedDeleted, pluginProperty, audit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Modify custom fields to payment
         * @param {Array<CustomField>} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyInvoicePaymentCustomFields(body: Array<CustomField>, paymentId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifyInvoicePaymentCustomFields(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InvoicePaymentApi - factory interface
 * @export
 */
export const InvoicePaymentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InvoicePaymentApiFp(configuration)
    return {
        /**
         * 
         * @summary Complete an existing transaction
         * @param {PaymentTransaction} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeInvoicePaymentTransaction(body: PaymentTransaction, paymentId: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.completeInvoicePaymentTransaction(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Record a chargeback
         * @param {InvoicePaymentTransaction} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChargeback(body: InvoicePaymentTransaction, paymentId: string, xKillbillCreatedBy: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<InvoicePayment> {
            return localVarFp.createChargeback(body, paymentId, xKillbillCreatedBy, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Record a chargebackReversal
         * @param {InvoicePaymentTransaction} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChargebackReversal(body: InvoicePaymentTransaction, paymentId: string, xKillbillCreatedBy: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<InvoicePayment> {
            return localVarFp.createChargebackReversal(body, paymentId, xKillbillCreatedBy, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add custom fields to payment
         * @param {Array<CustomField>} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoicePaymentCustomFields(body: Array<CustomField>, paymentId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Array<CustomField>> {
            return localVarFp.createInvoicePaymentCustomFields(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add tags to payment
         * @param {Array<string>} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoicePaymentTags(body: Array<string>, paymentId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.createInvoicePaymentTags(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Refund a payment, and adjust the invoice if needed
         * @param {InvoicePaymentTransaction} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [externalPayment] 
         * @param {string} [paymentMethodId] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRefundWithAdjustments(body: InvoicePaymentTransaction, paymentId: string, xKillbillCreatedBy: string, externalPayment?: boolean, paymentMethodId?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<InvoicePayment> {
            return localVarFp.createRefundWithAdjustments(body, paymentId, xKillbillCreatedBy, externalPayment, paymentMethodId, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove custom fields from payment
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [customField] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoicePaymentCustomFields(paymentId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteInvoicePaymentCustomFields(paymentId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove tags from payment
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [tagDef] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoicePaymentTags(paymentId: string, xKillbillCreatedBy: string, tagDef?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteInvoicePaymentTags(paymentId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a payment by id
         * @param {string} paymentId 
         * @param {boolean} [withPluginInfo] 
         * @param {boolean} [withAttempts] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoicePayment(paymentId: string, withPluginInfo?: boolean, withAttempts?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<InvoicePayment> {
            return localVarFp.getInvoicePayment(paymentId, withPluginInfo, withAttempts, pluginProperty, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve invoice payment audit logs with history by id
         * @param {string} invoicePaymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoicePaymentAuditLogsWithHistory(invoicePaymentId: string, options?: any): AxiosPromise<Array<AuditLog>> {
            return localVarFp.getInvoicePaymentAuditLogsWithHistory(invoicePaymentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve payment custom fields
         * @param {string} paymentId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoicePaymentCustomFields(paymentId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<CustomField>> {
            return localVarFp.getInvoicePaymentCustomFields(paymentId, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve payment tags
         * @param {string} paymentId 
         * @param {boolean} [includedDeleted] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoicePaymentTags(paymentId: string, includedDeleted?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.getInvoicePaymentTags(paymentId, includedDeleted, pluginProperty, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Modify custom fields to payment
         * @param {Array<CustomField>} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyInvoicePaymentCustomFields(body: Array<CustomField>, paymentId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.modifyInvoicePaymentCustomFields(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InvoicePaymentApi - object-oriented interface
 * @export
 * @class InvoicePaymentApi
 * @extends {BaseAPI}
 */
export class InvoicePaymentApi extends BaseAPI {
    /**
     * 
     * @summary Complete an existing transaction
     * @param {PaymentTransaction} body 
     * @param {string} paymentId 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [controlPluginName] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicePaymentApi
     */
    public completeInvoicePaymentTransaction(body: PaymentTransaction, paymentId: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return InvoicePaymentApiFp(this.configuration).completeInvoicePaymentTransaction(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Record a chargeback
     * @param {InvoicePaymentTransaction} body 
     * @param {string} paymentId 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicePaymentApi
     */
    public createChargeback(body: InvoicePaymentTransaction, paymentId: string, xKillbillCreatedBy: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return InvoicePaymentApiFp(this.configuration).createChargeback(body, paymentId, xKillbillCreatedBy, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Record a chargebackReversal
     * @param {InvoicePaymentTransaction} body 
     * @param {string} paymentId 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicePaymentApi
     */
    public createChargebackReversal(body: InvoicePaymentTransaction, paymentId: string, xKillbillCreatedBy: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return InvoicePaymentApiFp(this.configuration).createChargebackReversal(body, paymentId, xKillbillCreatedBy, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add custom fields to payment
     * @param {Array<CustomField>} body 
     * @param {string} paymentId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicePaymentApi
     */
    public createInvoicePaymentCustomFields(body: Array<CustomField>, paymentId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return InvoicePaymentApiFp(this.configuration).createInvoicePaymentCustomFields(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add tags to payment
     * @param {Array<string>} body 
     * @param {string} paymentId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicePaymentApi
     */
    public createInvoicePaymentTags(body: Array<string>, paymentId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return InvoicePaymentApiFp(this.configuration).createInvoicePaymentTags(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Refund a payment, and adjust the invoice if needed
     * @param {InvoicePaymentTransaction} body 
     * @param {string} paymentId 
     * @param {string} xKillbillCreatedBy 
     * @param {boolean} [externalPayment] 
     * @param {string} [paymentMethodId] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicePaymentApi
     */
    public createRefundWithAdjustments(body: InvoicePaymentTransaction, paymentId: string, xKillbillCreatedBy: string, externalPayment?: boolean, paymentMethodId?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return InvoicePaymentApiFp(this.configuration).createRefundWithAdjustments(body, paymentId, xKillbillCreatedBy, externalPayment, paymentMethodId, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove custom fields from payment
     * @param {string} paymentId 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [customField] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicePaymentApi
     */
    public deleteInvoicePaymentCustomFields(paymentId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return InvoicePaymentApiFp(this.configuration).deleteInvoicePaymentCustomFields(paymentId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove tags from payment
     * @param {string} paymentId 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [tagDef] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicePaymentApi
     */
    public deleteInvoicePaymentTags(paymentId: string, xKillbillCreatedBy: string, tagDef?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return InvoicePaymentApiFp(this.configuration).deleteInvoicePaymentTags(paymentId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a payment by id
     * @param {string} paymentId 
     * @param {boolean} [withPluginInfo] 
     * @param {boolean} [withAttempts] 
     * @param {Array<string>} [pluginProperty] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicePaymentApi
     */
    public getInvoicePayment(paymentId: string, withPluginInfo?: boolean, withAttempts?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig) {
        return InvoicePaymentApiFp(this.configuration).getInvoicePayment(paymentId, withPluginInfo, withAttempts, pluginProperty, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve invoice payment audit logs with history by id
     * @param {string} invoicePaymentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicePaymentApi
     */
    public getInvoicePaymentAuditLogsWithHistory(invoicePaymentId: string, options?: AxiosRequestConfig) {
        return InvoicePaymentApiFp(this.configuration).getInvoicePaymentAuditLogsWithHistory(invoicePaymentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve payment custom fields
     * @param {string} paymentId 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicePaymentApi
     */
    public getInvoicePaymentCustomFields(paymentId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig) {
        return InvoicePaymentApiFp(this.configuration).getInvoicePaymentCustomFields(paymentId, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve payment tags
     * @param {string} paymentId 
     * @param {boolean} [includedDeleted] 
     * @param {Array<string>} [pluginProperty] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicePaymentApi
     */
    public getInvoicePaymentTags(paymentId: string, includedDeleted?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig) {
        return InvoicePaymentApiFp(this.configuration).getInvoicePaymentTags(paymentId, includedDeleted, pluginProperty, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Modify custom fields to payment
     * @param {Array<CustomField>} body 
     * @param {string} paymentId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicePaymentApi
     */
    public modifyInvoicePaymentCustomFields(body: Array<CustomField>, paymentId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return InvoicePaymentApiFp(this.configuration).modifyInvoicePaymentCustomFields(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NodesInfoApi - axios parameter creator
 * @export
 */
export const NodesInfoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve all the nodes infos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodesInfo: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/1.0/kb/nodesInfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Trigger a node command
         * @param {NodeCommand} body 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [localNodeOnly] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerNodeCommand: async (body: NodeCommand, xKillbillCreatedBy: string, localNodeOnly?: boolean, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('triggerNodeCommand', 'body', body)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('triggerNodeCommand', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/nodesInfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (localNodeOnly !== undefined) {
                localVarQueryParameter['localNodeOnly'] = localNodeOnly;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NodesInfoApi - functional programming interface
 * @export
 */
export const NodesInfoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NodesInfoApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Retrieve all the nodes infos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNodesInfo(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NodeInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNodesInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Trigger a node command
         * @param {NodeCommand} body 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [localNodeOnly] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async triggerNodeCommand(body: NodeCommand, xKillbillCreatedBy: string, localNodeOnly?: boolean, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.triggerNodeCommand(body, xKillbillCreatedBy, localNodeOnly, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NodesInfoApi - factory interface
 * @export
 */
export const NodesInfoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NodesInfoApiFp(configuration)
    return {
        /**
         * 
         * @summary Retrieve all the nodes infos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodesInfo(options?: any): AxiosPromise<Array<NodeInfo>> {
            return localVarFp.getNodesInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Trigger a node command
         * @param {NodeCommand} body 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [localNodeOnly] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerNodeCommand(body: NodeCommand, xKillbillCreatedBy: string, localNodeOnly?: boolean, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.triggerNodeCommand(body, xKillbillCreatedBy, localNodeOnly, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NodesInfoApi - object-oriented interface
 * @export
 * @class NodesInfoApi
 * @extends {BaseAPI}
 */
export class NodesInfoApi extends BaseAPI {
    /**
     * 
     * @summary Retrieve all the nodes infos
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesInfoApi
     */
    public getNodesInfo(options?: AxiosRequestConfig) {
        return NodesInfoApiFp(this.configuration).getNodesInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Trigger a node command
     * @param {NodeCommand} body 
     * @param {string} xKillbillCreatedBy 
     * @param {boolean} [localNodeOnly] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesInfoApi
     */
    public triggerNodeCommand(body: NodeCommand, xKillbillCreatedBy: string, localNodeOnly?: boolean, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return NodesInfoApiFp(this.configuration).triggerNodeCommand(body, xKillbillCreatedBy, localNodeOnly, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OverdueApi - axios parameter creator
 * @export
 */
export const OverdueApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve the overdue config as JSON
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOverdueConfigJson: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/1.0/kb/overdue`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the overdue config as XML
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOverdueConfigXml: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/1.0/kb/overdue/xml`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload the full overdue config as JSON
         * @param {Overdue} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadOverdueConfigJson: async (body: Overdue, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('uploadOverdueConfigJson', 'body', body)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('uploadOverdueConfigJson', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/overdue`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload the full overdue config as XML
         * @param {string} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadOverdueConfigXml: async (body: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('uploadOverdueConfigXml', 'body', body)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('uploadOverdueConfigXml', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/overdue/xml`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'text/xml';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OverdueApi - functional programming interface
 * @export
 */
export const OverdueApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OverdueApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Retrieve the overdue config as JSON
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOverdueConfigJson(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Overdue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOverdueConfigJson(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve the overdue config as XML
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOverdueConfigXml(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOverdueConfigXml(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Upload the full overdue config as JSON
         * @param {Overdue} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadOverdueConfigJson(body: Overdue, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Overdue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadOverdueConfigJson(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Upload the full overdue config as XML
         * @param {string} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadOverdueConfigXml(body: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadOverdueConfigXml(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OverdueApi - factory interface
 * @export
 */
export const OverdueApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OverdueApiFp(configuration)
    return {
        /**
         * 
         * @summary Retrieve the overdue config as JSON
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOverdueConfigJson(options?: any): AxiosPromise<Overdue> {
            return localVarFp.getOverdueConfigJson(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve the overdue config as XML
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOverdueConfigXml(options?: any): AxiosPromise<string> {
            return localVarFp.getOverdueConfigXml(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload the full overdue config as JSON
         * @param {Overdue} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadOverdueConfigJson(body: Overdue, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Overdue> {
            return localVarFp.uploadOverdueConfigJson(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload the full overdue config as XML
         * @param {string} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadOverdueConfigXml(body: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<string> {
            return localVarFp.uploadOverdueConfigXml(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OverdueApi - object-oriented interface
 * @export
 * @class OverdueApi
 * @extends {BaseAPI}
 */
export class OverdueApi extends BaseAPI {
    /**
     * 
     * @summary Retrieve the overdue config as JSON
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OverdueApi
     */
    public getOverdueConfigJson(options?: AxiosRequestConfig) {
        return OverdueApiFp(this.configuration).getOverdueConfigJson(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve the overdue config as XML
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OverdueApi
     */
    public getOverdueConfigXml(options?: AxiosRequestConfig) {
        return OverdueApiFp(this.configuration).getOverdueConfigXml(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload the full overdue config as JSON
     * @param {Overdue} body 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OverdueApi
     */
    public uploadOverdueConfigJson(body: Overdue, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return OverdueApiFp(this.configuration).uploadOverdueConfigJson(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload the full overdue config as XML
     * @param {string} body 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OverdueApi
     */
    public uploadOverdueConfigXml(body: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return OverdueApiFp(this.configuration).uploadOverdueConfigXml(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PaymentApi - axios parameter creator
 * @export
 */
export const PaymentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Cancels a scheduled payment attempt retry
         * @param {string} transactionExternalKey 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelScheduledPaymentTransactionByExternalKey: async (transactionExternalKey: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionExternalKey' is not null or undefined
            assertParamExists('cancelScheduledPaymentTransactionByExternalKey', 'transactionExternalKey', transactionExternalKey)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('cancelScheduledPaymentTransactionByExternalKey', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/payments/cancelScheduledPaymentTransaction`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (transactionExternalKey !== undefined) {
                localVarQueryParameter['transactionExternalKey'] = transactionExternalKey;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cancels a scheduled payment attempt retry
         * @param {string} paymentTransactionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelScheduledPaymentTransactionById: async (paymentTransactionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentTransactionId' is not null or undefined
            assertParamExists('cancelScheduledPaymentTransactionById', 'paymentTransactionId', paymentTransactionId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('cancelScheduledPaymentTransactionById', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/payments/{paymentTransactionId}/cancelScheduledPaymentTransaction`
                .replace(`{${"paymentTransactionId"}}`, encodeURIComponent(String(paymentTransactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Capture an existing authorization
         * @param {PaymentTransaction} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        captureAuthorization: async (body: PaymentTransaction, paymentId: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('captureAuthorization', 'body', body)
            // verify required parameter 'paymentId' is not null or undefined
            assertParamExists('captureAuthorization', 'paymentId', paymentId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('captureAuthorization', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/payments/{paymentId}`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (controlPluginName) {
                localVarQueryParameter['controlPluginName'] = controlPluginName;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Capture an existing authorization
         * @param {PaymentTransaction} body 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        captureAuthorizationByExternalKey: async (body: PaymentTransaction, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('captureAuthorizationByExternalKey', 'body', body)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('captureAuthorizationByExternalKey', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/payments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (controlPluginName) {
                localVarQueryParameter['controlPluginName'] = controlPluginName;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Record a chargeback
         * @param {PaymentTransaction} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chargebackPayment: async (body: PaymentTransaction, paymentId: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('chargebackPayment', 'body', body)
            // verify required parameter 'paymentId' is not null or undefined
            assertParamExists('chargebackPayment', 'paymentId', paymentId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('chargebackPayment', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/payments/{paymentId}/chargebacks`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (controlPluginName) {
                localVarQueryParameter['controlPluginName'] = controlPluginName;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Record a chargeback
         * @param {PaymentTransaction} body 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chargebackPaymentByExternalKey: async (body: PaymentTransaction, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('chargebackPaymentByExternalKey', 'body', body)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('chargebackPaymentByExternalKey', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/payments/chargebacks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (controlPluginName) {
                localVarQueryParameter['controlPluginName'] = controlPluginName;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Record a chargeback reversal
         * @param {PaymentTransaction} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chargebackReversalPayment: async (body: PaymentTransaction, paymentId: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('chargebackReversalPayment', 'body', body)
            // verify required parameter 'paymentId' is not null or undefined
            assertParamExists('chargebackReversalPayment', 'paymentId', paymentId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('chargebackReversalPayment', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/payments/{paymentId}/chargebackReversals`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (controlPluginName) {
                localVarQueryParameter['controlPluginName'] = controlPluginName;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Record a chargeback reversal
         * @param {PaymentTransaction} body 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chargebackReversalPaymentByExternalKey: async (body: PaymentTransaction, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('chargebackReversalPaymentByExternalKey', 'body', body)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('chargebackReversalPaymentByExternalKey', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/payments/chargebackReversals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (controlPluginName) {
                localVarQueryParameter['controlPluginName'] = controlPluginName;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Complete an existing transaction
         * @param {PaymentTransaction} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeTransaction: async (body: PaymentTransaction, paymentId: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('completeTransaction', 'body', body)
            // verify required parameter 'paymentId' is not null or undefined
            assertParamExists('completeTransaction', 'paymentId', paymentId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('completeTransaction', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/payments/{paymentId}`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (controlPluginName) {
                localVarQueryParameter['controlPluginName'] = controlPluginName;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Complete an existing transaction
         * @param {PaymentTransaction} body 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeTransactionByExternalKey: async (body: PaymentTransaction, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('completeTransactionByExternalKey', 'body', body)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('completeTransactionByExternalKey', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/payments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (controlPluginName) {
                localVarQueryParameter['controlPluginName'] = controlPluginName;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Combo api to create a new payment transaction on a existing (or not) account 
         * @param {ComboPaymentTransaction} body 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createComboPayment: async (body: ComboPaymentTransaction, xKillbillCreatedBy: string, controlPluginName?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createComboPayment', 'body', body)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('createComboPayment', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/payments/combo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (controlPluginName) {
                localVarQueryParameter['controlPluginName'] = controlPluginName;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add custom fields to payment
         * @param {Array<CustomField>} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentCustomFields: async (body: Array<CustomField>, paymentId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createPaymentCustomFields', 'body', body)
            // verify required parameter 'paymentId' is not null or undefined
            assertParamExists('createPaymentCustomFields', 'paymentId', paymentId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('createPaymentCustomFields', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/payments/{paymentId}/customFields`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add tags to payment payment
         * @param {Array<string>} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentTags: async (body: Array<string>, paymentId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createPaymentTags', 'body', body)
            // verify required parameter 'paymentId' is not null or undefined
            assertParamExists('createPaymentTags', 'paymentId', paymentId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('createPaymentTags', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/payments/{paymentId}/tags`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove custom fields from payment payment
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [customField] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentCustomFields: async (paymentId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentId' is not null or undefined
            assertParamExists('deletePaymentCustomFields', 'paymentId', paymentId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('deletePaymentCustomFields', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/payments/{paymentId}/customFields`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (customField) {
                localVarQueryParameter['customField'] = customField;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove tags from payment payment
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [tagDef] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentTags: async (paymentId: string, xKillbillCreatedBy: string, tagDef?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentId' is not null or undefined
            assertParamExists('deletePaymentTags', 'paymentId', paymentId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('deletePaymentTags', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/payments/{paymentId}/tags`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (tagDef) {
                localVarQueryParameter['tagDef'] = tagDef;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a payment by id
         * @param {string} paymentId 
         * @param {boolean} [withPluginInfo] 
         * @param {boolean} [withAttempts] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayment: async (paymentId: string, withPluginInfo?: boolean, withAttempts?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentId' is not null or undefined
            assertParamExists('getPayment', 'paymentId', paymentId)
            const localVarPath = `/1.0/kb/payments/{paymentId}`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (withPluginInfo !== undefined) {
                localVarQueryParameter['withPluginInfo'] = withPluginInfo;
            }

            if (withAttempts !== undefined) {
                localVarQueryParameter['withAttempts'] = withAttempts;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve payment attempt audit logs with history by id
         * @param {string} paymentAttemptId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentAttemptAuditLogsWithHistory: async (paymentAttemptId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentAttemptId' is not null or undefined
            assertParamExists('getPaymentAttemptAuditLogsWithHistory', 'paymentAttemptId', paymentAttemptId)
            const localVarPath = `/1.0/kb/payments/attempts/{paymentAttemptId}/auditLogsWithHistory`
                .replace(`{${"paymentAttemptId"}}`, encodeURIComponent(String(paymentAttemptId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve payment audit logs with history by id
         * @param {string} paymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentAuditLogsWithHistory: async (paymentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentId' is not null or undefined
            assertParamExists('getPaymentAuditLogsWithHistory', 'paymentId', paymentId)
            const localVarPath = `/1.0/kb/payments/{paymentId}/auditLogsWithHistory`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a payment by external key
         * @param {string} externalKey 
         * @param {boolean} [withPluginInfo] 
         * @param {boolean} [withAttempts] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentByExternalKey: async (externalKey: string, withPluginInfo?: boolean, withAttempts?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'externalKey' is not null or undefined
            assertParamExists('getPaymentByExternalKey', 'externalKey', externalKey)
            const localVarPath = `/1.0/kb/payments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (withPluginInfo !== undefined) {
                localVarQueryParameter['withPluginInfo'] = withPluginInfo;
            }

            if (withAttempts !== undefined) {
                localVarQueryParameter['withAttempts'] = withAttempts;
            }

            if (externalKey !== undefined) {
                localVarQueryParameter['externalKey'] = externalKey;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve payment custom fields
         * @param {string} paymentId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentCustomFields: async (paymentId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentId' is not null or undefined
            assertParamExists('getPaymentCustomFields', 'paymentId', paymentId)
            const localVarPath = `/1.0/kb/payments/{paymentId}/customFields`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve payment payment tags
         * @param {string} paymentId 
         * @param {boolean} [includedDeleted] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentTags: async (paymentId: string, includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentId' is not null or undefined
            assertParamExists('getPaymentTags', 'paymentId', paymentId)
            const localVarPath = `/1.0/kb/payments/{paymentId}/tags`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (includedDeleted !== undefined) {
                localVarQueryParameter['includedDeleted'] = includedDeleted;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get payments
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [pluginName] 
         * @param {boolean} [withPluginInfo] 
         * @param {boolean} [withAttempts] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayments: async (offset?: number, limit?: number, pluginName?: string, withPluginInfo?: boolean, withAttempts?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/1.0/kb/payments/pagination`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (pluginName !== undefined) {
                localVarQueryParameter['pluginName'] = pluginName;
            }

            if (withPluginInfo !== undefined) {
                localVarQueryParameter['withPluginInfo'] = withPluginInfo;
            }

            if (withAttempts !== undefined) {
                localVarQueryParameter['withAttempts'] = withAttempts;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modify custom fields to payment
         * @param {Array<CustomField>} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyPaymentCustomFields: async (body: Array<CustomField>, paymentId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('modifyPaymentCustomFields', 'body', body)
            // verify required parameter 'paymentId' is not null or undefined
            assertParamExists('modifyPaymentCustomFields', 'paymentId', paymentId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('modifyPaymentCustomFields', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/payments/{paymentId}/customFields`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Refund an existing payment
         * @param {PaymentTransaction} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refundPayment: async (body: PaymentTransaction, paymentId: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('refundPayment', 'body', body)
            // verify required parameter 'paymentId' is not null or undefined
            assertParamExists('refundPayment', 'paymentId', paymentId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('refundPayment', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/payments/{paymentId}/refunds`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (controlPluginName) {
                localVarQueryParameter['controlPluginName'] = controlPluginName;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Refund an existing payment
         * @param {PaymentTransaction} body 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refundPaymentByExternalKey: async (body: PaymentTransaction, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('refundPaymentByExternalKey', 'body', body)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('refundPaymentByExternalKey', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/payments/refunds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (controlPluginName) {
                localVarQueryParameter['controlPluginName'] = controlPluginName;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search payments
         * @param {string} searchKey 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {boolean} [withPluginInfo] 
         * @param {boolean} [withAttempts] 
         * @param {string} [pluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPayments: async (searchKey: string, offset?: number, limit?: number, withPluginInfo?: boolean, withAttempts?: boolean, pluginName?: string, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchKey' is not null or undefined
            assertParamExists('searchPayments', 'searchKey', searchKey)
            const localVarPath = `/1.0/kb/payments/search/{searchKey}`
                .replace(`{${"searchKey"}}`, encodeURIComponent(String(searchKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (withPluginInfo !== undefined) {
                localVarQueryParameter['withPluginInfo'] = withPluginInfo;
            }

            if (withAttempts !== undefined) {
                localVarQueryParameter['withAttempts'] = withAttempts;
            }

            if (pluginName !== undefined) {
                localVarQueryParameter['pluginName'] = pluginName;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Void an existing payment
         * @param {PaymentTransaction} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voidPayment: async (body: PaymentTransaction, paymentId: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('voidPayment', 'body', body)
            // verify required parameter 'paymentId' is not null or undefined
            assertParamExists('voidPayment', 'paymentId', paymentId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('voidPayment', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/payments/{paymentId}`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (controlPluginName) {
                localVarQueryParameter['controlPluginName'] = controlPluginName;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Void an existing payment
         * @param {PaymentTransaction} body 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voidPaymentByExternalKey: async (body: PaymentTransaction, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('voidPaymentByExternalKey', 'body', body)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('voidPaymentByExternalKey', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/payments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (controlPluginName) {
                localVarQueryParameter['controlPluginName'] = controlPluginName;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentApi - functional programming interface
 * @export
 */
export const PaymentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Cancels a scheduled payment attempt retry
         * @param {string} transactionExternalKey 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelScheduledPaymentTransactionByExternalKey(transactionExternalKey: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelScheduledPaymentTransactionByExternalKey(transactionExternalKey, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Cancels a scheduled payment attempt retry
         * @param {string} paymentTransactionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelScheduledPaymentTransactionById(paymentTransactionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelScheduledPaymentTransactionById(paymentTransactionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Capture an existing authorization
         * @param {PaymentTransaction} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async captureAuthorization(body: PaymentTransaction, paymentId: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.captureAuthorization(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Capture an existing authorization
         * @param {PaymentTransaction} body 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async captureAuthorizationByExternalKey(body: PaymentTransaction, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.captureAuthorizationByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Record a chargeback
         * @param {PaymentTransaction} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chargebackPayment(body: PaymentTransaction, paymentId: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chargebackPayment(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Record a chargeback
         * @param {PaymentTransaction} body 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chargebackPaymentByExternalKey(body: PaymentTransaction, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chargebackPaymentByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Record a chargeback reversal
         * @param {PaymentTransaction} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chargebackReversalPayment(body: PaymentTransaction, paymentId: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chargebackReversalPayment(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Record a chargeback reversal
         * @param {PaymentTransaction} body 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chargebackReversalPaymentByExternalKey(body: PaymentTransaction, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chargebackReversalPaymentByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Complete an existing transaction
         * @param {PaymentTransaction} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completeTransaction(body: PaymentTransaction, paymentId: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completeTransaction(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Complete an existing transaction
         * @param {PaymentTransaction} body 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completeTransactionByExternalKey(body: PaymentTransaction, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completeTransactionByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Combo api to create a new payment transaction on a existing (or not) account 
         * @param {ComboPaymentTransaction} body 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createComboPayment(body: ComboPaymentTransaction, xKillbillCreatedBy: string, controlPluginName?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createComboPayment(body, xKillbillCreatedBy, controlPluginName, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add custom fields to payment
         * @param {Array<CustomField>} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPaymentCustomFields(body: Array<CustomField>, paymentId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CustomField>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPaymentCustomFields(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add tags to payment payment
         * @param {Array<string>} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPaymentTags(body: Array<string>, paymentId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPaymentTags(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove custom fields from payment payment
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [customField] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePaymentCustomFields(paymentId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePaymentCustomFields(paymentId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove tags from payment payment
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [tagDef] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePaymentTags(paymentId: string, xKillbillCreatedBy: string, tagDef?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePaymentTags(paymentId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a payment by id
         * @param {string} paymentId 
         * @param {boolean} [withPluginInfo] 
         * @param {boolean} [withAttempts] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPayment(paymentId: string, withPluginInfo?: boolean, withAttempts?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPayment(paymentId, withPluginInfo, withAttempts, pluginProperty, audit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve payment attempt audit logs with history by id
         * @param {string} paymentAttemptId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentAttemptAuditLogsWithHistory(paymentAttemptId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AuditLog>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPaymentAttemptAuditLogsWithHistory(paymentAttemptId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve payment audit logs with history by id
         * @param {string} paymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentAuditLogsWithHistory(paymentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AuditLog>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPaymentAuditLogsWithHistory(paymentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a payment by external key
         * @param {string} externalKey 
         * @param {boolean} [withPluginInfo] 
         * @param {boolean} [withAttempts] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentByExternalKey(externalKey: string, withPluginInfo?: boolean, withAttempts?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPaymentByExternalKey(externalKey, withPluginInfo, withAttempts, pluginProperty, audit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve payment custom fields
         * @param {string} paymentId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentCustomFields(paymentId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CustomField>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPaymentCustomFields(paymentId, audit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve payment payment tags
         * @param {string} paymentId 
         * @param {boolean} [includedDeleted] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentTags(paymentId: string, includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPaymentTags(paymentId, includedDeleted, audit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get payments
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [pluginName] 
         * @param {boolean} [withPluginInfo] 
         * @param {boolean} [withAttempts] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPayments(offset?: number, limit?: number, pluginName?: string, withPluginInfo?: boolean, withAttempts?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Payment>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPayments(offset, limit, pluginName, withPluginInfo, withAttempts, pluginProperty, audit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Modify custom fields to payment
         * @param {Array<CustomField>} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyPaymentCustomFields(body: Array<CustomField>, paymentId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifyPaymentCustomFields(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Refund an existing payment
         * @param {PaymentTransaction} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refundPayment(body: PaymentTransaction, paymentId: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refundPayment(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Refund an existing payment
         * @param {PaymentTransaction} body 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refundPaymentByExternalKey(body: PaymentTransaction, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refundPaymentByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Search payments
         * @param {string} searchKey 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {boolean} [withPluginInfo] 
         * @param {boolean} [withAttempts] 
         * @param {string} [pluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchPayments(searchKey: string, offset?: number, limit?: number, withPluginInfo?: boolean, withAttempts?: boolean, pluginName?: string, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Payment>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchPayments(searchKey, offset, limit, withPluginInfo, withAttempts, pluginName, pluginProperty, audit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Void an existing payment
         * @param {PaymentTransaction} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async voidPayment(body: PaymentTransaction, paymentId: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.voidPayment(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Void an existing payment
         * @param {PaymentTransaction} body 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async voidPaymentByExternalKey(body: PaymentTransaction, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.voidPaymentByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PaymentApi - factory interface
 * @export
 */
export const PaymentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentApiFp(configuration)
    return {
        /**
         * 
         * @summary Cancels a scheduled payment attempt retry
         * @param {string} transactionExternalKey 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelScheduledPaymentTransactionByExternalKey(transactionExternalKey: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.cancelScheduledPaymentTransactionByExternalKey(transactionExternalKey, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Cancels a scheduled payment attempt retry
         * @param {string} paymentTransactionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelScheduledPaymentTransactionById(paymentTransactionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.cancelScheduledPaymentTransactionById(paymentTransactionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Capture an existing authorization
         * @param {PaymentTransaction} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        captureAuthorization(body: PaymentTransaction, paymentId: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Payment> {
            return localVarFp.captureAuthorization(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Capture an existing authorization
         * @param {PaymentTransaction} body 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        captureAuthorizationByExternalKey(body: PaymentTransaction, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Payment> {
            return localVarFp.captureAuthorizationByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Record a chargeback
         * @param {PaymentTransaction} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chargebackPayment(body: PaymentTransaction, paymentId: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Payment> {
            return localVarFp.chargebackPayment(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Record a chargeback
         * @param {PaymentTransaction} body 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chargebackPaymentByExternalKey(body: PaymentTransaction, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Payment> {
            return localVarFp.chargebackPaymentByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Record a chargeback reversal
         * @param {PaymentTransaction} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chargebackReversalPayment(body: PaymentTransaction, paymentId: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Payment> {
            return localVarFp.chargebackReversalPayment(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Record a chargeback reversal
         * @param {PaymentTransaction} body 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chargebackReversalPaymentByExternalKey(body: PaymentTransaction, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Payment> {
            return localVarFp.chargebackReversalPaymentByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Complete an existing transaction
         * @param {PaymentTransaction} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeTransaction(body: PaymentTransaction, paymentId: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.completeTransaction(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Complete an existing transaction
         * @param {PaymentTransaction} body 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeTransactionByExternalKey(body: PaymentTransaction, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.completeTransactionByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Combo api to create a new payment transaction on a existing (or not) account 
         * @param {ComboPaymentTransaction} body 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createComboPayment(body: ComboPaymentTransaction, xKillbillCreatedBy: string, controlPluginName?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Payment> {
            return localVarFp.createComboPayment(body, xKillbillCreatedBy, controlPluginName, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add custom fields to payment
         * @param {Array<CustomField>} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentCustomFields(body: Array<CustomField>, paymentId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Array<CustomField>> {
            return localVarFp.createPaymentCustomFields(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add tags to payment payment
         * @param {Array<string>} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentTags(body: Array<string>, paymentId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.createPaymentTags(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove custom fields from payment payment
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [customField] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentCustomFields(paymentId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePaymentCustomFields(paymentId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove tags from payment payment
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [tagDef] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentTags(paymentId: string, xKillbillCreatedBy: string, tagDef?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePaymentTags(paymentId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a payment by id
         * @param {string} paymentId 
         * @param {boolean} [withPluginInfo] 
         * @param {boolean} [withAttempts] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayment(paymentId: string, withPluginInfo?: boolean, withAttempts?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Payment> {
            return localVarFp.getPayment(paymentId, withPluginInfo, withAttempts, pluginProperty, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve payment attempt audit logs with history by id
         * @param {string} paymentAttemptId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentAttemptAuditLogsWithHistory(paymentAttemptId: string, options?: any): AxiosPromise<Array<AuditLog>> {
            return localVarFp.getPaymentAttemptAuditLogsWithHistory(paymentAttemptId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve payment audit logs with history by id
         * @param {string} paymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentAuditLogsWithHistory(paymentId: string, options?: any): AxiosPromise<Array<AuditLog>> {
            return localVarFp.getPaymentAuditLogsWithHistory(paymentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a payment by external key
         * @param {string} externalKey 
         * @param {boolean} [withPluginInfo] 
         * @param {boolean} [withAttempts] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentByExternalKey(externalKey: string, withPluginInfo?: boolean, withAttempts?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Payment> {
            return localVarFp.getPaymentByExternalKey(externalKey, withPluginInfo, withAttempts, pluginProperty, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve payment custom fields
         * @param {string} paymentId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentCustomFields(paymentId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<CustomField>> {
            return localVarFp.getPaymentCustomFields(paymentId, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve payment payment tags
         * @param {string} paymentId 
         * @param {boolean} [includedDeleted] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentTags(paymentId: string, includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.getPaymentTags(paymentId, includedDeleted, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get payments
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [pluginName] 
         * @param {boolean} [withPluginInfo] 
         * @param {boolean} [withAttempts] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayments(offset?: number, limit?: number, pluginName?: string, withPluginInfo?: boolean, withAttempts?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<Payment>> {
            return localVarFp.getPayments(offset, limit, pluginName, withPluginInfo, withAttempts, pluginProperty, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Modify custom fields to payment
         * @param {Array<CustomField>} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyPaymentCustomFields(body: Array<CustomField>, paymentId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.modifyPaymentCustomFields(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Refund an existing payment
         * @param {PaymentTransaction} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refundPayment(body: PaymentTransaction, paymentId: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Payment> {
            return localVarFp.refundPayment(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Refund an existing payment
         * @param {PaymentTransaction} body 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refundPaymentByExternalKey(body: PaymentTransaction, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Payment> {
            return localVarFp.refundPaymentByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search payments
         * @param {string} searchKey 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {boolean} [withPluginInfo] 
         * @param {boolean} [withAttempts] 
         * @param {string} [pluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPayments(searchKey: string, offset?: number, limit?: number, withPluginInfo?: boolean, withAttempts?: boolean, pluginName?: string, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<Payment>> {
            return localVarFp.searchPayments(searchKey, offset, limit, withPluginInfo, withAttempts, pluginName, pluginProperty, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Void an existing payment
         * @param {PaymentTransaction} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voidPayment(body: PaymentTransaction, paymentId: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.voidPayment(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Void an existing payment
         * @param {PaymentTransaction} body 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voidPaymentByExternalKey(body: PaymentTransaction, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.voidPaymentByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentApi - object-oriented interface
 * @export
 * @class PaymentApi
 * @extends {BaseAPI}
 */
export class PaymentApi extends BaseAPI {
    /**
     * 
     * @summary Cancels a scheduled payment attempt retry
     * @param {string} transactionExternalKey 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public cancelScheduledPaymentTransactionByExternalKey(transactionExternalKey: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return PaymentApiFp(this.configuration).cancelScheduledPaymentTransactionByExternalKey(transactionExternalKey, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Cancels a scheduled payment attempt retry
     * @param {string} paymentTransactionId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public cancelScheduledPaymentTransactionById(paymentTransactionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return PaymentApiFp(this.configuration).cancelScheduledPaymentTransactionById(paymentTransactionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Capture an existing authorization
     * @param {PaymentTransaction} body 
     * @param {string} paymentId 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [controlPluginName] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public captureAuthorization(body: PaymentTransaction, paymentId: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return PaymentApiFp(this.configuration).captureAuthorization(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Capture an existing authorization
     * @param {PaymentTransaction} body 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [controlPluginName] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public captureAuthorizationByExternalKey(body: PaymentTransaction, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return PaymentApiFp(this.configuration).captureAuthorizationByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Record a chargeback
     * @param {PaymentTransaction} body 
     * @param {string} paymentId 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [controlPluginName] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public chargebackPayment(body: PaymentTransaction, paymentId: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return PaymentApiFp(this.configuration).chargebackPayment(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Record a chargeback
     * @param {PaymentTransaction} body 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [controlPluginName] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public chargebackPaymentByExternalKey(body: PaymentTransaction, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return PaymentApiFp(this.configuration).chargebackPaymentByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Record a chargeback reversal
     * @param {PaymentTransaction} body 
     * @param {string} paymentId 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [controlPluginName] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public chargebackReversalPayment(body: PaymentTransaction, paymentId: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return PaymentApiFp(this.configuration).chargebackReversalPayment(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Record a chargeback reversal
     * @param {PaymentTransaction} body 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [controlPluginName] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public chargebackReversalPaymentByExternalKey(body: PaymentTransaction, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return PaymentApiFp(this.configuration).chargebackReversalPaymentByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Complete an existing transaction
     * @param {PaymentTransaction} body 
     * @param {string} paymentId 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [controlPluginName] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public completeTransaction(body: PaymentTransaction, paymentId: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return PaymentApiFp(this.configuration).completeTransaction(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Complete an existing transaction
     * @param {PaymentTransaction} body 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [controlPluginName] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public completeTransactionByExternalKey(body: PaymentTransaction, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return PaymentApiFp(this.configuration).completeTransactionByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Combo api to create a new payment transaction on a existing (or not) account 
     * @param {ComboPaymentTransaction} body 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [controlPluginName] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public createComboPayment(body: ComboPaymentTransaction, xKillbillCreatedBy: string, controlPluginName?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return PaymentApiFp(this.configuration).createComboPayment(body, xKillbillCreatedBy, controlPluginName, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add custom fields to payment
     * @param {Array<CustomField>} body 
     * @param {string} paymentId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public createPaymentCustomFields(body: Array<CustomField>, paymentId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return PaymentApiFp(this.configuration).createPaymentCustomFields(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add tags to payment payment
     * @param {Array<string>} body 
     * @param {string} paymentId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public createPaymentTags(body: Array<string>, paymentId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return PaymentApiFp(this.configuration).createPaymentTags(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove custom fields from payment payment
     * @param {string} paymentId 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [customField] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public deletePaymentCustomFields(paymentId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return PaymentApiFp(this.configuration).deletePaymentCustomFields(paymentId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove tags from payment payment
     * @param {string} paymentId 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [tagDef] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public deletePaymentTags(paymentId: string, xKillbillCreatedBy: string, tagDef?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return PaymentApiFp(this.configuration).deletePaymentTags(paymentId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a payment by id
     * @param {string} paymentId 
     * @param {boolean} [withPluginInfo] 
     * @param {boolean} [withAttempts] 
     * @param {Array<string>} [pluginProperty] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public getPayment(paymentId: string, withPluginInfo?: boolean, withAttempts?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig) {
        return PaymentApiFp(this.configuration).getPayment(paymentId, withPluginInfo, withAttempts, pluginProperty, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve payment attempt audit logs with history by id
     * @param {string} paymentAttemptId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public getPaymentAttemptAuditLogsWithHistory(paymentAttemptId: string, options?: AxiosRequestConfig) {
        return PaymentApiFp(this.configuration).getPaymentAttemptAuditLogsWithHistory(paymentAttemptId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve payment audit logs with history by id
     * @param {string} paymentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public getPaymentAuditLogsWithHistory(paymentId: string, options?: AxiosRequestConfig) {
        return PaymentApiFp(this.configuration).getPaymentAuditLogsWithHistory(paymentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a payment by external key
     * @param {string} externalKey 
     * @param {boolean} [withPluginInfo] 
     * @param {boolean} [withAttempts] 
     * @param {Array<string>} [pluginProperty] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public getPaymentByExternalKey(externalKey: string, withPluginInfo?: boolean, withAttempts?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig) {
        return PaymentApiFp(this.configuration).getPaymentByExternalKey(externalKey, withPluginInfo, withAttempts, pluginProperty, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve payment custom fields
     * @param {string} paymentId 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public getPaymentCustomFields(paymentId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig) {
        return PaymentApiFp(this.configuration).getPaymentCustomFields(paymentId, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve payment payment tags
     * @param {string} paymentId 
     * @param {boolean} [includedDeleted] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public getPaymentTags(paymentId: string, includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig) {
        return PaymentApiFp(this.configuration).getPaymentTags(paymentId, includedDeleted, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get payments
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {string} [pluginName] 
     * @param {boolean} [withPluginInfo] 
     * @param {boolean} [withAttempts] 
     * @param {Array<string>} [pluginProperty] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public getPayments(offset?: number, limit?: number, pluginName?: string, withPluginInfo?: boolean, withAttempts?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig) {
        return PaymentApiFp(this.configuration).getPayments(offset, limit, pluginName, withPluginInfo, withAttempts, pluginProperty, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Modify custom fields to payment
     * @param {Array<CustomField>} body 
     * @param {string} paymentId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public modifyPaymentCustomFields(body: Array<CustomField>, paymentId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return PaymentApiFp(this.configuration).modifyPaymentCustomFields(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Refund an existing payment
     * @param {PaymentTransaction} body 
     * @param {string} paymentId 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [controlPluginName] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public refundPayment(body: PaymentTransaction, paymentId: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return PaymentApiFp(this.configuration).refundPayment(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Refund an existing payment
     * @param {PaymentTransaction} body 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [controlPluginName] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public refundPaymentByExternalKey(body: PaymentTransaction, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return PaymentApiFp(this.configuration).refundPaymentByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search payments
     * @param {string} searchKey 
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {boolean} [withPluginInfo] 
     * @param {boolean} [withAttempts] 
     * @param {string} [pluginName] 
     * @param {Array<string>} [pluginProperty] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public searchPayments(searchKey: string, offset?: number, limit?: number, withPluginInfo?: boolean, withAttempts?: boolean, pluginName?: string, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig) {
        return PaymentApiFp(this.configuration).searchPayments(searchKey, offset, limit, withPluginInfo, withAttempts, pluginName, pluginProperty, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Void an existing payment
     * @param {PaymentTransaction} body 
     * @param {string} paymentId 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [controlPluginName] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public voidPayment(body: PaymentTransaction, paymentId: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return PaymentApiFp(this.configuration).voidPayment(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Void an existing payment
     * @param {PaymentTransaction} body 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [controlPluginName] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public voidPaymentByExternalKey(body: PaymentTransaction, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return PaymentApiFp(this.configuration).voidPaymentByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PaymentGatewayApi - axios parameter creator
 * @export
 */
export const PaymentGatewayApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Combo API to generate form data to redirect the customer to the gateway
         * @param {ComboHostedPaymentPage} body 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildComboFormDescriptor: async (body: ComboHostedPaymentPage, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('buildComboFormDescriptor', 'body', body)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('buildComboFormDescriptor', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/paymentGateways/hosted/form`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (controlPluginName) {
                localVarQueryParameter['controlPluginName'] = controlPluginName;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Generate form data to redirect the customer to the gateway
         * @param {HostedPaymentPageFields} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [paymentMethodId] 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildFormDescriptor: async (body: HostedPaymentPageFields, accountId: string, xKillbillCreatedBy: string, paymentMethodId?: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('buildFormDescriptor', 'body', body)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('buildFormDescriptor', 'accountId', accountId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('buildFormDescriptor', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/paymentGateways/hosted/form/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (paymentMethodId !== undefined) {
                localVarQueryParameter['paymentMethodId'] = paymentMethodId;
            }

            if (controlPluginName) {
                localVarQueryParameter['controlPluginName'] = controlPluginName;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The response is built by the appropriate plugin
         * @summary Process a gateway notification
         * @param {string} body 
         * @param {string} pluginName 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processNotification: async (body: string, pluginName: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('processNotification', 'body', body)
            // verify required parameter 'pluginName' is not null or undefined
            assertParamExists('processNotification', 'pluginName', pluginName)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('processNotification', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/paymentGateways/notification/{pluginName}`
                .replace(`{${"pluginName"}}`, encodeURIComponent(String(pluginName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (controlPluginName) {
                localVarQueryParameter['controlPluginName'] = controlPluginName;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentGatewayApi - functional programming interface
 * @export
 */
export const PaymentGatewayApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentGatewayApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Combo API to generate form data to redirect the customer to the gateway
         * @param {ComboHostedPaymentPage} body 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async buildComboFormDescriptor(body: ComboHostedPaymentPage, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HostedPaymentPageFormDescriptor>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.buildComboFormDescriptor(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Generate form data to redirect the customer to the gateway
         * @param {HostedPaymentPageFields} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [paymentMethodId] 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async buildFormDescriptor(body: HostedPaymentPageFields, accountId: string, xKillbillCreatedBy: string, paymentMethodId?: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HostedPaymentPageFormDescriptor>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.buildFormDescriptor(body, accountId, xKillbillCreatedBy, paymentMethodId, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The response is built by the appropriate plugin
         * @summary Process a gateway notification
         * @param {string} body 
         * @param {string} pluginName 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async processNotification(body: string, pluginName: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.processNotification(body, pluginName, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PaymentGatewayApi - factory interface
 * @export
 */
export const PaymentGatewayApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentGatewayApiFp(configuration)
    return {
        /**
         * 
         * @summary Combo API to generate form data to redirect the customer to the gateway
         * @param {ComboHostedPaymentPage} body 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildComboFormDescriptor(body: ComboHostedPaymentPage, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<HostedPaymentPageFormDescriptor> {
            return localVarFp.buildComboFormDescriptor(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Generate form data to redirect the customer to the gateway
         * @param {HostedPaymentPageFields} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [paymentMethodId] 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildFormDescriptor(body: HostedPaymentPageFields, accountId: string, xKillbillCreatedBy: string, paymentMethodId?: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<HostedPaymentPageFormDescriptor> {
            return localVarFp.buildFormDescriptor(body, accountId, xKillbillCreatedBy, paymentMethodId, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * The response is built by the appropriate plugin
         * @summary Process a gateway notification
         * @param {string} body 
         * @param {string} pluginName 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processNotification(body: string, pluginName: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.processNotification(body, pluginName, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentGatewayApi - object-oriented interface
 * @export
 * @class PaymentGatewayApi
 * @extends {BaseAPI}
 */
export class PaymentGatewayApi extends BaseAPI {
    /**
     * 
     * @summary Combo API to generate form data to redirect the customer to the gateway
     * @param {ComboHostedPaymentPage} body 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [controlPluginName] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentGatewayApi
     */
    public buildComboFormDescriptor(body: ComboHostedPaymentPage, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return PaymentGatewayApiFp(this.configuration).buildComboFormDescriptor(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Generate form data to redirect the customer to the gateway
     * @param {HostedPaymentPageFields} body 
     * @param {string} accountId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [paymentMethodId] 
     * @param {Array<string>} [controlPluginName] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentGatewayApi
     */
    public buildFormDescriptor(body: HostedPaymentPageFields, accountId: string, xKillbillCreatedBy: string, paymentMethodId?: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return PaymentGatewayApiFp(this.configuration).buildFormDescriptor(body, accountId, xKillbillCreatedBy, paymentMethodId, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The response is built by the appropriate plugin
     * @summary Process a gateway notification
     * @param {string} body 
     * @param {string} pluginName 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [controlPluginName] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentGatewayApi
     */
    public processNotification(body: string, pluginName: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return PaymentGatewayApiFp(this.configuration).processNotification(body, pluginName, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PaymentMethodApi - axios parameter creator
 * @export
 */
export const PaymentMethodApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add custom fields to payment method
         * @param {Array<CustomField>} body 
         * @param {string} paymentMethodId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentMethodCustomFields: async (body: Array<CustomField>, paymentMethodId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createPaymentMethodCustomFields', 'body', body)
            // verify required parameter 'paymentMethodId' is not null or undefined
            assertParamExists('createPaymentMethodCustomFields', 'paymentMethodId', paymentMethodId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('createPaymentMethodCustomFields', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/paymentMethods/{paymentMethodId}/customFields`
                .replace(`{${"paymentMethodId"}}`, encodeURIComponent(String(paymentMethodId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a payment method
         * @param {string} paymentMethodId 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [deleteDefaultPmWithAutoPayOff] 
         * @param {boolean} [forceDefaultPmDeletion] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentMethod: async (paymentMethodId: string, xKillbillCreatedBy: string, deleteDefaultPmWithAutoPayOff?: boolean, forceDefaultPmDeletion?: boolean, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentMethodId' is not null or undefined
            assertParamExists('deletePaymentMethod', 'paymentMethodId', paymentMethodId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('deletePaymentMethod', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/paymentMethods/{paymentMethodId}`
                .replace(`{${"paymentMethodId"}}`, encodeURIComponent(String(paymentMethodId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (deleteDefaultPmWithAutoPayOff !== undefined) {
                localVarQueryParameter['deleteDefaultPmWithAutoPayOff'] = deleteDefaultPmWithAutoPayOff;
            }

            if (forceDefaultPmDeletion !== undefined) {
                localVarQueryParameter['forceDefaultPmDeletion'] = forceDefaultPmDeletion;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove custom fields from payment method
         * @param {string} paymentMethodId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [customField] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentMethodCustomFields: async (paymentMethodId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentMethodId' is not null or undefined
            assertParamExists('deletePaymentMethodCustomFields', 'paymentMethodId', paymentMethodId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('deletePaymentMethodCustomFields', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/paymentMethods/{paymentMethodId}/customFields`
                .replace(`{${"paymentMethodId"}}`, encodeURIComponent(String(paymentMethodId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (customField) {
                localVarQueryParameter['customField'] = customField;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a payment method by id
         * @param {string} paymentMethodId 
         * @param {boolean} [includedDeleted] 
         * @param {boolean} [withPluginInfo] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethod: async (paymentMethodId: string, includedDeleted?: boolean, withPluginInfo?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentMethodId' is not null or undefined
            assertParamExists('getPaymentMethod', 'paymentMethodId', paymentMethodId)
            const localVarPath = `/1.0/kb/paymentMethods/{paymentMethodId}`
                .replace(`{${"paymentMethodId"}}`, encodeURIComponent(String(paymentMethodId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (includedDeleted !== undefined) {
                localVarQueryParameter['includedDeleted'] = includedDeleted;
            }

            if (withPluginInfo !== undefined) {
                localVarQueryParameter['withPluginInfo'] = withPluginInfo;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve payment method audit logs with history by id
         * @param {string} paymentMethodId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethodAuditLogsWithHistory: async (paymentMethodId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentMethodId' is not null or undefined
            assertParamExists('getPaymentMethodAuditLogsWithHistory', 'paymentMethodId', paymentMethodId)
            const localVarPath = `/1.0/kb/paymentMethods/{paymentMethodId}/auditLogsWithHistory`
                .replace(`{${"paymentMethodId"}}`, encodeURIComponent(String(paymentMethodId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a payment method by external key
         * @param {string} externalKey 
         * @param {boolean} [includedDeleted] 
         * @param {boolean} [withPluginInfo] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethodByKey: async (externalKey: string, includedDeleted?: boolean, withPluginInfo?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'externalKey' is not null or undefined
            assertParamExists('getPaymentMethodByKey', 'externalKey', externalKey)
            const localVarPath = `/1.0/kb/paymentMethods`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (externalKey !== undefined) {
                localVarQueryParameter['externalKey'] = externalKey;
            }

            if (includedDeleted !== undefined) {
                localVarQueryParameter['includedDeleted'] = includedDeleted;
            }

            if (withPluginInfo !== undefined) {
                localVarQueryParameter['withPluginInfo'] = withPluginInfo;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve payment method custom fields
         * @param {string} paymentMethodId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethodCustomFields: async (paymentMethodId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentMethodId' is not null or undefined
            assertParamExists('getPaymentMethodCustomFields', 'paymentMethodId', paymentMethodId)
            const localVarPath = `/1.0/kb/paymentMethods/{paymentMethodId}/customFields`
                .replace(`{${"paymentMethodId"}}`, encodeURIComponent(String(paymentMethodId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List payment methods
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [pluginName] 
         * @param {boolean} [withPluginInfo] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethods: async (offset?: number, limit?: number, pluginName?: string, withPluginInfo?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/1.0/kb/paymentMethods/pagination`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (pluginName !== undefined) {
                localVarQueryParameter['pluginName'] = pluginName;
            }

            if (withPluginInfo !== undefined) {
                localVarQueryParameter['withPluginInfo'] = withPluginInfo;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modify custom fields to payment method
         * @param {Array<CustomField>} body 
         * @param {string} paymentMethodId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyPaymentMethodCustomFields: async (body: Array<CustomField>, paymentMethodId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('modifyPaymentMethodCustomFields', 'body', body)
            // verify required parameter 'paymentMethodId' is not null or undefined
            assertParamExists('modifyPaymentMethodCustomFields', 'paymentMethodId', paymentMethodId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('modifyPaymentMethodCustomFields', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/paymentMethods/{paymentMethodId}/customFields`
                .replace(`{${"paymentMethodId"}}`, encodeURIComponent(String(paymentMethodId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search payment methods
         * @param {string} searchKey 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [pluginName] 
         * @param {boolean} [withPluginInfo] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPaymentMethods: async (searchKey: string, offset?: number, limit?: number, pluginName?: string, withPluginInfo?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchKey' is not null or undefined
            assertParamExists('searchPaymentMethods', 'searchKey', searchKey)
            const localVarPath = `/1.0/kb/paymentMethods/search/{searchKey}`
                .replace(`{${"searchKey"}}`, encodeURIComponent(String(searchKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (pluginName !== undefined) {
                localVarQueryParameter['pluginName'] = pluginName;
            }

            if (withPluginInfo !== undefined) {
                localVarQueryParameter['withPluginInfo'] = withPluginInfo;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentMethodApi - functional programming interface
 * @export
 */
export const PaymentMethodApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentMethodApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add custom fields to payment method
         * @param {Array<CustomField>} body 
         * @param {string} paymentMethodId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPaymentMethodCustomFields(body: Array<CustomField>, paymentMethodId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CustomField>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPaymentMethodCustomFields(body, paymentMethodId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a payment method
         * @param {string} paymentMethodId 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [deleteDefaultPmWithAutoPayOff] 
         * @param {boolean} [forceDefaultPmDeletion] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePaymentMethod(paymentMethodId: string, xKillbillCreatedBy: string, deleteDefaultPmWithAutoPayOff?: boolean, forceDefaultPmDeletion?: boolean, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePaymentMethod(paymentMethodId, xKillbillCreatedBy, deleteDefaultPmWithAutoPayOff, forceDefaultPmDeletion, pluginProperty, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove custom fields from payment method
         * @param {string} paymentMethodId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [customField] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePaymentMethodCustomFields(paymentMethodId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePaymentMethodCustomFields(paymentMethodId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a payment method by id
         * @param {string} paymentMethodId 
         * @param {boolean} [includedDeleted] 
         * @param {boolean} [withPluginInfo] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentMethod(paymentMethodId: string, includedDeleted?: boolean, withPluginInfo?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentMethod>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPaymentMethod(paymentMethodId, includedDeleted, withPluginInfo, pluginProperty, audit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve payment method audit logs with history by id
         * @param {string} paymentMethodId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentMethodAuditLogsWithHistory(paymentMethodId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AuditLog>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPaymentMethodAuditLogsWithHistory(paymentMethodId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a payment method by external key
         * @param {string} externalKey 
         * @param {boolean} [includedDeleted] 
         * @param {boolean} [withPluginInfo] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentMethodByKey(externalKey: string, includedDeleted?: boolean, withPluginInfo?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentMethod>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPaymentMethodByKey(externalKey, includedDeleted, withPluginInfo, pluginProperty, audit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve payment method custom fields
         * @param {string} paymentMethodId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentMethodCustomFields(paymentMethodId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CustomField>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPaymentMethodCustomFields(paymentMethodId, audit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List payment methods
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [pluginName] 
         * @param {boolean} [withPluginInfo] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentMethods(offset?: number, limit?: number, pluginName?: string, withPluginInfo?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PaymentMethod>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPaymentMethods(offset, limit, pluginName, withPluginInfo, pluginProperty, audit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Modify custom fields to payment method
         * @param {Array<CustomField>} body 
         * @param {string} paymentMethodId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyPaymentMethodCustomFields(body: Array<CustomField>, paymentMethodId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifyPaymentMethodCustomFields(body, paymentMethodId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Search payment methods
         * @param {string} searchKey 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [pluginName] 
         * @param {boolean} [withPluginInfo] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchPaymentMethods(searchKey: string, offset?: number, limit?: number, pluginName?: string, withPluginInfo?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PaymentMethod>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchPaymentMethods(searchKey, offset, limit, pluginName, withPluginInfo, pluginProperty, audit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PaymentMethodApi - factory interface
 * @export
 */
export const PaymentMethodApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentMethodApiFp(configuration)
    return {
        /**
         * 
         * @summary Add custom fields to payment method
         * @param {Array<CustomField>} body 
         * @param {string} paymentMethodId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentMethodCustomFields(body: Array<CustomField>, paymentMethodId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Array<CustomField>> {
            return localVarFp.createPaymentMethodCustomFields(body, paymentMethodId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a payment method
         * @param {string} paymentMethodId 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [deleteDefaultPmWithAutoPayOff] 
         * @param {boolean} [forceDefaultPmDeletion] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentMethod(paymentMethodId: string, xKillbillCreatedBy: string, deleteDefaultPmWithAutoPayOff?: boolean, forceDefaultPmDeletion?: boolean, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePaymentMethod(paymentMethodId, xKillbillCreatedBy, deleteDefaultPmWithAutoPayOff, forceDefaultPmDeletion, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove custom fields from payment method
         * @param {string} paymentMethodId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [customField] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentMethodCustomFields(paymentMethodId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePaymentMethodCustomFields(paymentMethodId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a payment method by id
         * @param {string} paymentMethodId 
         * @param {boolean} [includedDeleted] 
         * @param {boolean} [withPluginInfo] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethod(paymentMethodId: string, includedDeleted?: boolean, withPluginInfo?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<PaymentMethod> {
            return localVarFp.getPaymentMethod(paymentMethodId, includedDeleted, withPluginInfo, pluginProperty, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve payment method audit logs with history by id
         * @param {string} paymentMethodId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethodAuditLogsWithHistory(paymentMethodId: string, options?: any): AxiosPromise<Array<AuditLog>> {
            return localVarFp.getPaymentMethodAuditLogsWithHistory(paymentMethodId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a payment method by external key
         * @param {string} externalKey 
         * @param {boolean} [includedDeleted] 
         * @param {boolean} [withPluginInfo] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethodByKey(externalKey: string, includedDeleted?: boolean, withPluginInfo?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<PaymentMethod> {
            return localVarFp.getPaymentMethodByKey(externalKey, includedDeleted, withPluginInfo, pluginProperty, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve payment method custom fields
         * @param {string} paymentMethodId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethodCustomFields(paymentMethodId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<CustomField>> {
            return localVarFp.getPaymentMethodCustomFields(paymentMethodId, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List payment methods
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [pluginName] 
         * @param {boolean} [withPluginInfo] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethods(offset?: number, limit?: number, pluginName?: string, withPluginInfo?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<PaymentMethod>> {
            return localVarFp.getPaymentMethods(offset, limit, pluginName, withPluginInfo, pluginProperty, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Modify custom fields to payment method
         * @param {Array<CustomField>} body 
         * @param {string} paymentMethodId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyPaymentMethodCustomFields(body: Array<CustomField>, paymentMethodId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.modifyPaymentMethodCustomFields(body, paymentMethodId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search payment methods
         * @param {string} searchKey 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [pluginName] 
         * @param {boolean} [withPluginInfo] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPaymentMethods(searchKey: string, offset?: number, limit?: number, pluginName?: string, withPluginInfo?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<PaymentMethod>> {
            return localVarFp.searchPaymentMethods(searchKey, offset, limit, pluginName, withPluginInfo, pluginProperty, audit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentMethodApi - object-oriented interface
 * @export
 * @class PaymentMethodApi
 * @extends {BaseAPI}
 */
export class PaymentMethodApi extends BaseAPI {
    /**
     * 
     * @summary Add custom fields to payment method
     * @param {Array<CustomField>} body 
     * @param {string} paymentMethodId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentMethodApi
     */
    public createPaymentMethodCustomFields(body: Array<CustomField>, paymentMethodId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return PaymentMethodApiFp(this.configuration).createPaymentMethodCustomFields(body, paymentMethodId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a payment method
     * @param {string} paymentMethodId 
     * @param {string} xKillbillCreatedBy 
     * @param {boolean} [deleteDefaultPmWithAutoPayOff] 
     * @param {boolean} [forceDefaultPmDeletion] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentMethodApi
     */
    public deletePaymentMethod(paymentMethodId: string, xKillbillCreatedBy: string, deleteDefaultPmWithAutoPayOff?: boolean, forceDefaultPmDeletion?: boolean, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return PaymentMethodApiFp(this.configuration).deletePaymentMethod(paymentMethodId, xKillbillCreatedBy, deleteDefaultPmWithAutoPayOff, forceDefaultPmDeletion, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove custom fields from payment method
     * @param {string} paymentMethodId 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [customField] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentMethodApi
     */
    public deletePaymentMethodCustomFields(paymentMethodId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return PaymentMethodApiFp(this.configuration).deletePaymentMethodCustomFields(paymentMethodId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a payment method by id
     * @param {string} paymentMethodId 
     * @param {boolean} [includedDeleted] 
     * @param {boolean} [withPluginInfo] 
     * @param {Array<string>} [pluginProperty] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentMethodApi
     */
    public getPaymentMethod(paymentMethodId: string, includedDeleted?: boolean, withPluginInfo?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig) {
        return PaymentMethodApiFp(this.configuration).getPaymentMethod(paymentMethodId, includedDeleted, withPluginInfo, pluginProperty, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve payment method audit logs with history by id
     * @param {string} paymentMethodId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentMethodApi
     */
    public getPaymentMethodAuditLogsWithHistory(paymentMethodId: string, options?: AxiosRequestConfig) {
        return PaymentMethodApiFp(this.configuration).getPaymentMethodAuditLogsWithHistory(paymentMethodId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a payment method by external key
     * @param {string} externalKey 
     * @param {boolean} [includedDeleted] 
     * @param {boolean} [withPluginInfo] 
     * @param {Array<string>} [pluginProperty] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentMethodApi
     */
    public getPaymentMethodByKey(externalKey: string, includedDeleted?: boolean, withPluginInfo?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig) {
        return PaymentMethodApiFp(this.configuration).getPaymentMethodByKey(externalKey, includedDeleted, withPluginInfo, pluginProperty, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve payment method custom fields
     * @param {string} paymentMethodId 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentMethodApi
     */
    public getPaymentMethodCustomFields(paymentMethodId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig) {
        return PaymentMethodApiFp(this.configuration).getPaymentMethodCustomFields(paymentMethodId, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List payment methods
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {string} [pluginName] 
     * @param {boolean} [withPluginInfo] 
     * @param {Array<string>} [pluginProperty] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentMethodApi
     */
    public getPaymentMethods(offset?: number, limit?: number, pluginName?: string, withPluginInfo?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig) {
        return PaymentMethodApiFp(this.configuration).getPaymentMethods(offset, limit, pluginName, withPluginInfo, pluginProperty, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Modify custom fields to payment method
     * @param {Array<CustomField>} body 
     * @param {string} paymentMethodId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentMethodApi
     */
    public modifyPaymentMethodCustomFields(body: Array<CustomField>, paymentMethodId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return PaymentMethodApiFp(this.configuration).modifyPaymentMethodCustomFields(body, paymentMethodId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search payment methods
     * @param {string} searchKey 
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {string} [pluginName] 
     * @param {boolean} [withPluginInfo] 
     * @param {Array<string>} [pluginProperty] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentMethodApi
     */
    public searchPaymentMethods(searchKey: string, offset?: number, limit?: number, pluginName?: string, withPluginInfo?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig) {
        return PaymentMethodApiFp(this.configuration).searchPaymentMethods(searchKey, offset, limit, pluginName, withPluginInfo, pluginProperty, audit, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PaymentTransactionApi - axios parameter creator
 * @export
 */
export const PaymentTransactionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add custom fields to payment transaction
         * @param {Array<CustomField>} body 
         * @param {string} transactionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransactionCustomFields: async (body: Array<CustomField>, transactionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createTransactionCustomFields', 'body', body)
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('createTransactionCustomFields', 'transactionId', transactionId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('createTransactionCustomFields', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/paymentTransactions/{transactionId}/customFields`
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add tags to payment transaction
         * @param {Array<string>} body 
         * @param {string} transactionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransactionTags: async (body: Array<string>, transactionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createTransactionTags', 'body', body)
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('createTransactionTags', 'transactionId', transactionId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('createTransactionTags', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/paymentTransactions/{transactionId}/tags`
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove custom fields from payment transaction
         * @param {string} transactionId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [customField] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransactionCustomFields: async (transactionId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('deleteTransactionCustomFields', 'transactionId', transactionId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('deleteTransactionCustomFields', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/paymentTransactions/{transactionId}/customFields`
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (customField) {
                localVarQueryParameter['customField'] = customField;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove tags from payment transaction
         * @param {string} transactionId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [tagDef] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransactionTags: async (transactionId: string, xKillbillCreatedBy: string, tagDef?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('deleteTransactionTags', 'transactionId', transactionId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('deleteTransactionTags', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/paymentTransactions/{transactionId}/tags`
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (tagDef) {
                localVarQueryParameter['tagDef'] = tagDef;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a payment by transaction external key
         * @param {string} transactionExternalKey 
         * @param {boolean} [withPluginInfo] 
         * @param {boolean} [withAttempts] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentByTransactionExternalKey: async (transactionExternalKey: string, withPluginInfo?: boolean, withAttempts?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionExternalKey' is not null or undefined
            assertParamExists('getPaymentByTransactionExternalKey', 'transactionExternalKey', transactionExternalKey)
            const localVarPath = `/1.0/kb/paymentTransactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (transactionExternalKey !== undefined) {
                localVarQueryParameter['transactionExternalKey'] = transactionExternalKey;
            }

            if (withPluginInfo !== undefined) {
                localVarQueryParameter['withPluginInfo'] = withPluginInfo;
            }

            if (withAttempts !== undefined) {
                localVarQueryParameter['withAttempts'] = withAttempts;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a payment by transaction id
         * @param {string} transactionId 
         * @param {boolean} [withPluginInfo] 
         * @param {boolean} [withAttempts] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentByTransactionId: async (transactionId: string, withPluginInfo?: boolean, withAttempts?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('getPaymentByTransactionId', 'transactionId', transactionId)
            const localVarPath = `/1.0/kb/paymentTransactions/{transactionId}`
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (withPluginInfo !== undefined) {
                localVarQueryParameter['withPluginInfo'] = withPluginInfo;
            }

            if (withAttempts !== undefined) {
                localVarQueryParameter['withAttempts'] = withAttempts;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve payment transaction audit logs with history by id
         * @param {string} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionAuditLogsWithHistory: async (transactionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('getTransactionAuditLogsWithHistory', 'transactionId', transactionId)
            const localVarPath = `/1.0/kb/paymentTransactions/{transactionId}/auditLogsWithHistory`
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve payment transaction custom fields
         * @param {string} transactionId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionCustomFields: async (transactionId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('getTransactionCustomFields', 'transactionId', transactionId)
            const localVarPath = `/1.0/kb/paymentTransactions/{transactionId}/customFields`
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve payment transaction tags
         * @param {string} transactionId 
         * @param {boolean} [includedDeleted] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionTags: async (transactionId: string, includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('getTransactionTags', 'transactionId', transactionId)
            const localVarPath = `/1.0/kb/paymentTransactions/{transactionId}/tags`
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (includedDeleted !== undefined) {
                localVarQueryParameter['includedDeleted'] = includedDeleted;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modify custom fields to payment transaction
         * @param {Array<CustomField>} body 
         * @param {string} transactionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyTransactionCustomFields: async (body: Array<CustomField>, transactionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('modifyTransactionCustomFields', 'body', body)
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('modifyTransactionCustomFields', 'transactionId', transactionId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('modifyTransactionCustomFields', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/paymentTransactions/{transactionId}/customFields`
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Mark a pending payment transaction as succeeded or failed
         * @param {PaymentTransaction} body 
         * @param {string} transactionId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notifyStateChanged: async (body: PaymentTransaction, transactionId: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('notifyStateChanged', 'body', body)
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('notifyStateChanged', 'transactionId', transactionId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('notifyStateChanged', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/paymentTransactions/{transactionId}`
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (controlPluginName) {
                localVarQueryParameter['controlPluginName'] = controlPluginName;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentTransactionApi - functional programming interface
 * @export
 */
export const PaymentTransactionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentTransactionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add custom fields to payment transaction
         * @param {Array<CustomField>} body 
         * @param {string} transactionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTransactionCustomFields(body: Array<CustomField>, transactionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CustomField>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTransactionCustomFields(body, transactionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add tags to payment transaction
         * @param {Array<string>} body 
         * @param {string} transactionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTransactionTags(body: Array<string>, transactionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTransactionTags(body, transactionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove custom fields from payment transaction
         * @param {string} transactionId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [customField] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTransactionCustomFields(transactionId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTransactionCustomFields(transactionId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove tags from payment transaction
         * @param {string} transactionId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [tagDef] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTransactionTags(transactionId: string, xKillbillCreatedBy: string, tagDef?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTransactionTags(transactionId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a payment by transaction external key
         * @param {string} transactionExternalKey 
         * @param {boolean} [withPluginInfo] 
         * @param {boolean} [withAttempts] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentByTransactionExternalKey(transactionExternalKey: string, withPluginInfo?: boolean, withAttempts?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPaymentByTransactionExternalKey(transactionExternalKey, withPluginInfo, withAttempts, pluginProperty, audit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a payment by transaction id
         * @param {string} transactionId 
         * @param {boolean} [withPluginInfo] 
         * @param {boolean} [withAttempts] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentByTransactionId(transactionId: string, withPluginInfo?: boolean, withAttempts?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPaymentByTransactionId(transactionId, withPluginInfo, withAttempts, pluginProperty, audit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve payment transaction audit logs with history by id
         * @param {string} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionAuditLogsWithHistory(transactionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AuditLog>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionAuditLogsWithHistory(transactionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve payment transaction custom fields
         * @param {string} transactionId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionCustomFields(transactionId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CustomField>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionCustomFields(transactionId, audit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve payment transaction tags
         * @param {string} transactionId 
         * @param {boolean} [includedDeleted] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionTags(transactionId: string, includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionTags(transactionId, includedDeleted, audit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Modify custom fields to payment transaction
         * @param {Array<CustomField>} body 
         * @param {string} transactionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyTransactionCustomFields(body: Array<CustomField>, transactionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifyTransactionCustomFields(body, transactionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Mark a pending payment transaction as succeeded or failed
         * @param {PaymentTransaction} body 
         * @param {string} transactionId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notifyStateChanged(body: PaymentTransaction, transactionId: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notifyStateChanged(body, transactionId, xKillbillCreatedBy, controlPluginName, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PaymentTransactionApi - factory interface
 * @export
 */
export const PaymentTransactionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentTransactionApiFp(configuration)
    return {
        /**
         * 
         * @summary Add custom fields to payment transaction
         * @param {Array<CustomField>} body 
         * @param {string} transactionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransactionCustomFields(body: Array<CustomField>, transactionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Array<CustomField>> {
            return localVarFp.createTransactionCustomFields(body, transactionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add tags to payment transaction
         * @param {Array<string>} body 
         * @param {string} transactionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransactionTags(body: Array<string>, transactionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.createTransactionTags(body, transactionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove custom fields from payment transaction
         * @param {string} transactionId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [customField] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransactionCustomFields(transactionId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTransactionCustomFields(transactionId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove tags from payment transaction
         * @param {string} transactionId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [tagDef] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransactionTags(transactionId: string, xKillbillCreatedBy: string, tagDef?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTransactionTags(transactionId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a payment by transaction external key
         * @param {string} transactionExternalKey 
         * @param {boolean} [withPluginInfo] 
         * @param {boolean} [withAttempts] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentByTransactionExternalKey(transactionExternalKey: string, withPluginInfo?: boolean, withAttempts?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Payment> {
            return localVarFp.getPaymentByTransactionExternalKey(transactionExternalKey, withPluginInfo, withAttempts, pluginProperty, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a payment by transaction id
         * @param {string} transactionId 
         * @param {boolean} [withPluginInfo] 
         * @param {boolean} [withAttempts] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentByTransactionId(transactionId: string, withPluginInfo?: boolean, withAttempts?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Payment> {
            return localVarFp.getPaymentByTransactionId(transactionId, withPluginInfo, withAttempts, pluginProperty, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve payment transaction audit logs with history by id
         * @param {string} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionAuditLogsWithHistory(transactionId: string, options?: any): AxiosPromise<Array<AuditLog>> {
            return localVarFp.getTransactionAuditLogsWithHistory(transactionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve payment transaction custom fields
         * @param {string} transactionId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionCustomFields(transactionId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<CustomField>> {
            return localVarFp.getTransactionCustomFields(transactionId, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve payment transaction tags
         * @param {string} transactionId 
         * @param {boolean} [includedDeleted] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionTags(transactionId: string, includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.getTransactionTags(transactionId, includedDeleted, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Modify custom fields to payment transaction
         * @param {Array<CustomField>} body 
         * @param {string} transactionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyTransactionCustomFields(body: Array<CustomField>, transactionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.modifyTransactionCustomFields(body, transactionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Mark a pending payment transaction as succeeded or failed
         * @param {PaymentTransaction} body 
         * @param {string} transactionId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notifyStateChanged(body: PaymentTransaction, transactionId: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Payment> {
            return localVarFp.notifyStateChanged(body, transactionId, xKillbillCreatedBy, controlPluginName, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentTransactionApi - object-oriented interface
 * @export
 * @class PaymentTransactionApi
 * @extends {BaseAPI}
 */
export class PaymentTransactionApi extends BaseAPI {
    /**
     * 
     * @summary Add custom fields to payment transaction
     * @param {Array<CustomField>} body 
     * @param {string} transactionId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTransactionApi
     */
    public createTransactionCustomFields(body: Array<CustomField>, transactionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return PaymentTransactionApiFp(this.configuration).createTransactionCustomFields(body, transactionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add tags to payment transaction
     * @param {Array<string>} body 
     * @param {string} transactionId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTransactionApi
     */
    public createTransactionTags(body: Array<string>, transactionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return PaymentTransactionApiFp(this.configuration).createTransactionTags(body, transactionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove custom fields from payment transaction
     * @param {string} transactionId 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [customField] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTransactionApi
     */
    public deleteTransactionCustomFields(transactionId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return PaymentTransactionApiFp(this.configuration).deleteTransactionCustomFields(transactionId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove tags from payment transaction
     * @param {string} transactionId 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [tagDef] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTransactionApi
     */
    public deleteTransactionTags(transactionId: string, xKillbillCreatedBy: string, tagDef?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return PaymentTransactionApiFp(this.configuration).deleteTransactionTags(transactionId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a payment by transaction external key
     * @param {string} transactionExternalKey 
     * @param {boolean} [withPluginInfo] 
     * @param {boolean} [withAttempts] 
     * @param {Array<string>} [pluginProperty] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTransactionApi
     */
    public getPaymentByTransactionExternalKey(transactionExternalKey: string, withPluginInfo?: boolean, withAttempts?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig) {
        return PaymentTransactionApiFp(this.configuration).getPaymentByTransactionExternalKey(transactionExternalKey, withPluginInfo, withAttempts, pluginProperty, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a payment by transaction id
     * @param {string} transactionId 
     * @param {boolean} [withPluginInfo] 
     * @param {boolean} [withAttempts] 
     * @param {Array<string>} [pluginProperty] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTransactionApi
     */
    public getPaymentByTransactionId(transactionId: string, withPluginInfo?: boolean, withAttempts?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig) {
        return PaymentTransactionApiFp(this.configuration).getPaymentByTransactionId(transactionId, withPluginInfo, withAttempts, pluginProperty, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve payment transaction audit logs with history by id
     * @param {string} transactionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTransactionApi
     */
    public getTransactionAuditLogsWithHistory(transactionId: string, options?: AxiosRequestConfig) {
        return PaymentTransactionApiFp(this.configuration).getTransactionAuditLogsWithHistory(transactionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve payment transaction custom fields
     * @param {string} transactionId 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTransactionApi
     */
    public getTransactionCustomFields(transactionId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig) {
        return PaymentTransactionApiFp(this.configuration).getTransactionCustomFields(transactionId, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve payment transaction tags
     * @param {string} transactionId 
     * @param {boolean} [includedDeleted] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTransactionApi
     */
    public getTransactionTags(transactionId: string, includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig) {
        return PaymentTransactionApiFp(this.configuration).getTransactionTags(transactionId, includedDeleted, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Modify custom fields to payment transaction
     * @param {Array<CustomField>} body 
     * @param {string} transactionId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTransactionApi
     */
    public modifyTransactionCustomFields(body: Array<CustomField>, transactionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return PaymentTransactionApiFp(this.configuration).modifyTransactionCustomFields(body, transactionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Mark a pending payment transaction as succeeded or failed
     * @param {PaymentTransaction} body 
     * @param {string} transactionId 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [controlPluginName] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTransactionApi
     */
    public notifyStateChanged(body: PaymentTransaction, transactionId: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return PaymentTransactionApiFp(this.configuration).notifyStateChanged(body, transactionId, xKillbillCreatedBy, controlPluginName, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PluginInfoApi - axios parameter creator
 * @export
 */
export const PluginInfoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve the list of registered plugins
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPluginsInfo: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/1.0/kb/pluginsInfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PluginInfoApi - functional programming interface
 * @export
 */
export const PluginInfoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PluginInfoApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Retrieve the list of registered plugins
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPluginsInfo(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PluginInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPluginsInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PluginInfoApi - factory interface
 * @export
 */
export const PluginInfoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PluginInfoApiFp(configuration)
    return {
        /**
         * 
         * @summary Retrieve the list of registered plugins
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPluginsInfo(options?: any): AxiosPromise<Array<PluginInfo>> {
            return localVarFp.getPluginsInfo(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PluginInfoApi - object-oriented interface
 * @export
 * @class PluginInfoApi
 * @extends {BaseAPI}
 */
export class PluginInfoApi extends BaseAPI {
    /**
     * 
     * @summary Retrieve the list of registered plugins
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginInfoApi
     */
    public getPluginsInfo(options?: AxiosRequestConfig) {
        return PluginInfoApiFp(this.configuration).getPluginsInfo(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SecurityApi - axios parameter creator
 * @export
 */
export const SecurityApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a new role definition)
         * @param {RoleDefinition} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRoleDefinition: async (body: RoleDefinition, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('addRoleDefinition', 'body', body)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('addRoleDefinition', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/security/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a new user with roles (to make api requests)
         * @param {UserRoles} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserRoles: async (body: UserRoles, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('addUserRoles', 'body', body)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('addUserRoles', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/security/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List user permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserPermissions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/1.0/kb/security/permissions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserSubject: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/1.0/kb/security/subject`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get role definition
         * @param {string} role 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoleDefinition: async (role: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'role' is not null or undefined
            assertParamExists('getRoleDefinition', 'role', role)
            const localVarPath = `/1.0/kb/security/roles/{role}`
                .replace(`{${"role"}}`, encodeURIComponent(String(role)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get roles associated to a user
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRoles: async (username: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('getUserRoles', 'username', username)
            const localVarPath = `/1.0/kb/security/users/{username}/roles`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invalidate an existing user
         * @param {string} username 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidateUser: async (username: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('invalidateUser', 'username', username)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('invalidateUser', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/security/users/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a new role definition)
         * @param {RoleDefinition} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRoleDefinition: async (body: RoleDefinition, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateRoleDefinition', 'body', body)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('updateRoleDefinition', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/security/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a user password
         * @param {UserRoles} body 
         * @param {string} username 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPassword: async (body: UserRoles, username: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateUserPassword', 'body', body)
            // verify required parameter 'username' is not null or undefined
            assertParamExists('updateUserPassword', 'username', username)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('updateUserPassword', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/security/users/{username}/password`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update roles associated to a user
         * @param {UserRoles} body 
         * @param {string} username 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserRoles: async (body: UserRoles, username: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateUserRoles', 'body', body)
            // verify required parameter 'username' is not null or undefined
            assertParamExists('updateUserRoles', 'username', username)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('updateUserRoles', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/security/users/{username}/roles`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SecurityApi - functional programming interface
 * @export
 */
export const SecurityApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SecurityApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add a new role definition)
         * @param {RoleDefinition} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addRoleDefinition(body: RoleDefinition, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleDefinition>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addRoleDefinition(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add a new user with roles (to make api requests)
         * @param {UserRoles} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addUserRoles(body: UserRoles, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRoles>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addUserRoles(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List user permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentUserPermissions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentUserPermissions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get user information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentUserSubject(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentUserSubject(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get role definition
         * @param {string} role 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoleDefinition(role: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleDefinition>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoleDefinition(role, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get roles associated to a user
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserRoles(username: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRoles>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserRoles(username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Invalidate an existing user
         * @param {string} username 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async invalidateUser(username: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.invalidateUser(username, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a new role definition)
         * @param {RoleDefinition} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRoleDefinition(body: RoleDefinition, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRoleDefinition(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a user password
         * @param {UserRoles} body 
         * @param {string} username 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserPassword(body: UserRoles, username: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserPassword(body, username, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update roles associated to a user
         * @param {UserRoles} body 
         * @param {string} username 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserRoles(body: UserRoles, username: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserRoles(body, username, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SecurityApi - factory interface
 * @export
 */
export const SecurityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SecurityApiFp(configuration)
    return {
        /**
         * 
         * @summary Add a new role definition)
         * @param {RoleDefinition} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRoleDefinition(body: RoleDefinition, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<RoleDefinition> {
            return localVarFp.addRoleDefinition(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a new user with roles (to make api requests)
         * @param {UserRoles} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserRoles(body: UserRoles, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<UserRoles> {
            return localVarFp.addUserRoles(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List user permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserPermissions(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getCurrentUserPermissions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserSubject(options?: any): AxiosPromise<Subject> {
            return localVarFp.getCurrentUserSubject(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get role definition
         * @param {string} role 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoleDefinition(role: string, options?: any): AxiosPromise<RoleDefinition> {
            return localVarFp.getRoleDefinition(role, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get roles associated to a user
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRoles(username: string, options?: any): AxiosPromise<UserRoles> {
            return localVarFp.getUserRoles(username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invalidate an existing user
         * @param {string} username 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidateUser(username: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.invalidateUser(username, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a new role definition)
         * @param {RoleDefinition} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRoleDefinition(body: RoleDefinition, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.updateRoleDefinition(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a user password
         * @param {UserRoles} body 
         * @param {string} username 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPassword(body: UserRoles, username: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.updateUserPassword(body, username, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update roles associated to a user
         * @param {UserRoles} body 
         * @param {string} username 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserRoles(body: UserRoles, username: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.updateUserRoles(body, username, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SecurityApi - object-oriented interface
 * @export
 * @class SecurityApi
 * @extends {BaseAPI}
 */
export class SecurityApi extends BaseAPI {
    /**
     * 
     * @summary Add a new role definition)
     * @param {RoleDefinition} body 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    public addRoleDefinition(body: RoleDefinition, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return SecurityApiFp(this.configuration).addRoleDefinition(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a new user with roles (to make api requests)
     * @param {UserRoles} body 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    public addUserRoles(body: UserRoles, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return SecurityApiFp(this.configuration).addUserRoles(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List user permissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    public getCurrentUserPermissions(options?: AxiosRequestConfig) {
        return SecurityApiFp(this.configuration).getCurrentUserPermissions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    public getCurrentUserSubject(options?: AxiosRequestConfig) {
        return SecurityApiFp(this.configuration).getCurrentUserSubject(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get role definition
     * @param {string} role 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    public getRoleDefinition(role: string, options?: AxiosRequestConfig) {
        return SecurityApiFp(this.configuration).getRoleDefinition(role, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get roles associated to a user
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    public getUserRoles(username: string, options?: AxiosRequestConfig) {
        return SecurityApiFp(this.configuration).getUserRoles(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invalidate an existing user
     * @param {string} username 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    public invalidateUser(username: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return SecurityApiFp(this.configuration).invalidateUser(username, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a new role definition)
     * @param {RoleDefinition} body 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    public updateRoleDefinition(body: RoleDefinition, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return SecurityApiFp(this.configuration).updateRoleDefinition(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a user password
     * @param {UserRoles} body 
     * @param {string} username 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    public updateUserPassword(body: UserRoles, username: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return SecurityApiFp(this.configuration).updateUserPassword(body, username, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update roles associated to a user
     * @param {UserRoles} body 
     * @param {string} username 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    public updateUserRoles(body: UserRoles, username: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return SecurityApiFp(this.configuration).updateUserRoles(body, username, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SubscriptionApi - axios parameter creator
 * @export
 */
export const SubscriptionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Block a subscription
         * @param {BlockingState} body 
         * @param {string} subscriptionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [requestedDate] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSubscriptionBlockingState: async (body: BlockingState, subscriptionId: string, xKillbillCreatedBy: string, requestedDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('addSubscriptionBlockingState', 'body', body)
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('addSubscriptionBlockingState', 'subscriptionId', subscriptionId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('addSubscriptionBlockingState', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/subscriptions/{subscriptionId}/block`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (requestedDate !== undefined) {
                localVarQueryParameter['requestedDate'] = (requestedDate as any instanceof Date) ?
                    (requestedDate as any).toISOString().substr(0,10) :
                    requestedDate;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cancel an entitlement plan
         * @param {string} subscriptionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [requestedDate] 
         * @param {boolean} [callCompletion] 
         * @param {number} [callTimeoutSec] 
         * @param {'IMMEDIATE' | 'END_OF_TERM'} [entitlementPolicy] 
         * @param {'START_OF_TERM' | 'END_OF_TERM' | 'IMMEDIATE' | 'ILLEGAL'} [billingPolicy] 
         * @param {boolean} [useRequestedDateForBilling] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelSubscriptionPlan: async (subscriptionId: string, xKillbillCreatedBy: string, requestedDate?: string, callCompletion?: boolean, callTimeoutSec?: number, entitlementPolicy?: 'IMMEDIATE' | 'END_OF_TERM', billingPolicy?: 'START_OF_TERM' | 'END_OF_TERM' | 'IMMEDIATE' | 'ILLEGAL', useRequestedDateForBilling?: boolean, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('cancelSubscriptionPlan', 'subscriptionId', subscriptionId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('cancelSubscriptionPlan', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/subscriptions/{subscriptionId}`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (requestedDate !== undefined) {
                localVarQueryParameter['requestedDate'] = (requestedDate as any instanceof Date) ?
                    (requestedDate as any).toISOString().substr(0,10) :
                    requestedDate;
            }

            if (callCompletion !== undefined) {
                localVarQueryParameter['callCompletion'] = callCompletion;
            }

            if (callTimeoutSec !== undefined) {
                localVarQueryParameter['callTimeoutSec'] = callTimeoutSec;
            }

            if (entitlementPolicy !== undefined) {
                localVarQueryParameter['entitlementPolicy'] = entitlementPolicy;
            }

            if (billingPolicy !== undefined) {
                localVarQueryParameter['billingPolicy'] = billingPolicy;
            }

            if (useRequestedDateForBilling !== undefined) {
                localVarQueryParameter['useRequestedDateForBilling'] = useRequestedDateForBilling;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Change entitlement plan
         * @param {Subscription} body 
         * @param {string} subscriptionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [requestedDate] 
         * @param {boolean} [callCompletion] 
         * @param {number} [callTimeoutSec] 
         * @param {'START_OF_TERM' | 'END_OF_TERM' | 'IMMEDIATE' | 'ILLEGAL'} [billingPolicy] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeSubscriptionPlan: async (body: Subscription, subscriptionId: string, xKillbillCreatedBy: string, requestedDate?: string, callCompletion?: boolean, callTimeoutSec?: number, billingPolicy?: 'START_OF_TERM' | 'END_OF_TERM' | 'IMMEDIATE' | 'ILLEGAL', pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('changeSubscriptionPlan', 'body', body)
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('changeSubscriptionPlan', 'subscriptionId', subscriptionId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('changeSubscriptionPlan', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/subscriptions/{subscriptionId}`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (requestedDate !== undefined) {
                localVarQueryParameter['requestedDate'] = (requestedDate as any instanceof Date) ?
                    (requestedDate as any).toISOString().substr(0,10) :
                    requestedDate;
            }

            if (callCompletion !== undefined) {
                localVarQueryParameter['callCompletion'] = callCompletion;
            }

            if (callTimeoutSec !== undefined) {
                localVarQueryParameter['callTimeoutSec'] = callTimeoutSec;
            }

            if (billingPolicy !== undefined) {
                localVarQueryParameter['billingPolicy'] = billingPolicy;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create an subscription
         * @param {Subscription} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [entitlementDate] 
         * @param {string} [billingDate] 
         * @param {boolean} [renameKeyIfExistsAndUnused] 
         * @param {boolean} [migrated] 
         * @param {boolean} [skipResponse] 
         * @param {boolean} [callCompletion] 
         * @param {number} [callTimeoutSec] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscription: async (body: Subscription, xKillbillCreatedBy: string, entitlementDate?: string, billingDate?: string, renameKeyIfExistsAndUnused?: boolean, migrated?: boolean, skipResponse?: boolean, callCompletion?: boolean, callTimeoutSec?: number, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createSubscription', 'body', body)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('createSubscription', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (entitlementDate !== undefined) {
                localVarQueryParameter['entitlementDate'] = (entitlementDate as any instanceof Date) ?
                    (entitlementDate as any).toISOString().substr(0,10) :
                    entitlementDate;
            }

            if (billingDate !== undefined) {
                localVarQueryParameter['billingDate'] = (billingDate as any instanceof Date) ?
                    (billingDate as any).toISOString().substr(0,10) :
                    billingDate;
            }

            if (renameKeyIfExistsAndUnused !== undefined) {
                localVarQueryParameter['renameKeyIfExistsAndUnused'] = renameKeyIfExistsAndUnused;
            }

            if (migrated !== undefined) {
                localVarQueryParameter['migrated'] = migrated;
            }

            if (skipResponse !== undefined) {
                localVarQueryParameter['skipResponse'] = skipResponse;
            }

            if (callCompletion !== undefined) {
                localVarQueryParameter['callCompletion'] = callCompletion;
            }

            if (callTimeoutSec !== undefined) {
                localVarQueryParameter['callTimeoutSec'] = callTimeoutSec;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add custom fields to subscription
         * @param {Array<CustomField>} body 
         * @param {string} subscriptionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscriptionCustomFields: async (body: Array<CustomField>, subscriptionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createSubscriptionCustomFields', 'body', body)
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('createSubscriptionCustomFields', 'subscriptionId', subscriptionId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('createSubscriptionCustomFields', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/subscriptions/{subscriptionId}/customFields`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<string>} body 
         * @param {string} subscriptionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscriptionTags: async (body: Array<string>, subscriptionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createSubscriptionTags', 'body', body)
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('createSubscriptionTags', 'subscriptionId', subscriptionId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('createSubscriptionTags', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/subscriptions/{subscriptionId}/tags`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create an entitlement with addOn products
         * @param {Array<Subscription>} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [entitlementDate] 
         * @param {string} [billingDate] 
         * @param {boolean} [migrated] 
         * @param {boolean} [skipResponse] 
         * @param {boolean} [renameKeyIfExistsAndUnused] 
         * @param {boolean} [callCompletion] 
         * @param {number} [callTimeoutSec] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscriptionWithAddOns: async (body: Array<Subscription>, xKillbillCreatedBy: string, entitlementDate?: string, billingDate?: string, migrated?: boolean, skipResponse?: boolean, renameKeyIfExistsAndUnused?: boolean, callCompletion?: boolean, callTimeoutSec?: number, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createSubscriptionWithAddOns', 'body', body)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('createSubscriptionWithAddOns', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/subscriptions/createSubscriptionWithAddOns`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (entitlementDate !== undefined) {
                localVarQueryParameter['entitlementDate'] = (entitlementDate as any instanceof Date) ?
                    (entitlementDate as any).toISOString().substr(0,10) :
                    entitlementDate;
            }

            if (billingDate !== undefined) {
                localVarQueryParameter['billingDate'] = (billingDate as any instanceof Date) ?
                    (billingDate as any).toISOString().substr(0,10) :
                    billingDate;
            }

            if (migrated !== undefined) {
                localVarQueryParameter['migrated'] = migrated;
            }

            if (skipResponse !== undefined) {
                localVarQueryParameter['skipResponse'] = skipResponse;
            }

            if (renameKeyIfExistsAndUnused !== undefined) {
                localVarQueryParameter['renameKeyIfExistsAndUnused'] = renameKeyIfExistsAndUnused;
            }

            if (callCompletion !== undefined) {
                localVarQueryParameter['callCompletion'] = callCompletion;
            }

            if (callTimeoutSec !== undefined) {
                localVarQueryParameter['callTimeoutSec'] = callTimeoutSec;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create multiple entitlements with addOn products
         * @param {Array<BulkSubscriptionsBundle>} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [entitlementDate] 
         * @param {string} [billingDate] 
         * @param {boolean} [renameKeyIfExistsAndUnused] 
         * @param {boolean} [migrated] 
         * @param {boolean} [skipResponse] 
         * @param {boolean} [callCompletion] 
         * @param {number} [callTimeoutSec] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscriptionsWithAddOns: async (body: Array<BulkSubscriptionsBundle>, xKillbillCreatedBy: string, entitlementDate?: string, billingDate?: string, renameKeyIfExistsAndUnused?: boolean, migrated?: boolean, skipResponse?: boolean, callCompletion?: boolean, callTimeoutSec?: number, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createSubscriptionsWithAddOns', 'body', body)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('createSubscriptionsWithAddOns', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/subscriptions/createSubscriptionsWithAddOns`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (entitlementDate !== undefined) {
                localVarQueryParameter['entitlementDate'] = (entitlementDate as any instanceof Date) ?
                    (entitlementDate as any).toISOString().substr(0,10) :
                    entitlementDate;
            }

            if (billingDate !== undefined) {
                localVarQueryParameter['billingDate'] = (billingDate as any instanceof Date) ?
                    (billingDate as any).toISOString().substr(0,10) :
                    billingDate;
            }

            if (renameKeyIfExistsAndUnused !== undefined) {
                localVarQueryParameter['renameKeyIfExistsAndUnused'] = renameKeyIfExistsAndUnused;
            }

            if (migrated !== undefined) {
                localVarQueryParameter['migrated'] = migrated;
            }

            if (skipResponse !== undefined) {
                localVarQueryParameter['skipResponse'] = skipResponse;
            }

            if (callCompletion !== undefined) {
                localVarQueryParameter['callCompletion'] = callCompletion;
            }

            if (callTimeoutSec !== undefined) {
                localVarQueryParameter['callTimeoutSec'] = callTimeoutSec;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove custom fields from subscription
         * @param {string} subscriptionId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [customField] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubscriptionCustomFields: async (subscriptionId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('deleteSubscriptionCustomFields', 'subscriptionId', subscriptionId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('deleteSubscriptionCustomFields', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/subscriptions/{subscriptionId}/customFields`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (customField) {
                localVarQueryParameter['customField'] = customField;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove tags from subscription
         * @param {string} subscriptionId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [tagDef] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubscriptionTags: async (subscriptionId: string, xKillbillCreatedBy: string, tagDef?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('deleteSubscriptionTags', 'subscriptionId', subscriptionId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('deleteSubscriptionTags', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/subscriptions/{subscriptionId}/tags`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (tagDef) {
                localVarQueryParameter['tagDef'] = tagDef;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a subscription by id
         * @param {string} subscriptionId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscription: async (subscriptionId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('getSubscription', 'subscriptionId', subscriptionId)
            const localVarPath = `/1.0/kb/subscriptions/{subscriptionId}`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve subscription audit logs with history by id
         * @param {string} subscriptionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionAuditLogsWithHistory: async (subscriptionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('getSubscriptionAuditLogsWithHistory', 'subscriptionId', subscriptionId)
            const localVarPath = `/1.0/kb/subscriptions/{subscriptionId}/auditLogsWithHistory`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a subscription by external key
         * @param {string} externalKey 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionByKey: async (externalKey: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'externalKey' is not null or undefined
            assertParamExists('getSubscriptionByKey', 'externalKey', externalKey)
            const localVarPath = `/1.0/kb/subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (externalKey !== undefined) {
                localVarQueryParameter['externalKey'] = externalKey;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve subscription custom fields
         * @param {string} subscriptionId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionCustomFields: async (subscriptionId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('getSubscriptionCustomFields', 'subscriptionId', subscriptionId)
            const localVarPath = `/1.0/kb/subscriptions/{subscriptionId}/customFields`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve subscription event audit logs with history by id
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionEventAuditLogsWithHistory: async (eventId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getSubscriptionEventAuditLogsWithHistory', 'eventId', eventId)
            const localVarPath = `/1.0/kb/subscriptions/events/{eventId}/auditLogsWithHistory`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve subscription tags
         * @param {string} subscriptionId 
         * @param {boolean} [includedDeleted] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionTags: async (subscriptionId: string, includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('getSubscriptionTags', 'subscriptionId', subscriptionId)
            const localVarPath = `/1.0/kb/subscriptions/{subscriptionId}/tags`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (includedDeleted !== undefined) {
                localVarQueryParameter['includedDeleted'] = includedDeleted;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modify custom fields to subscription
         * @param {Array<CustomField>} body 
         * @param {string} subscriptionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifySubscriptionCustomFields: async (body: Array<CustomField>, subscriptionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('modifySubscriptionCustomFields', 'body', body)
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('modifySubscriptionCustomFields', 'subscriptionId', subscriptionId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('modifySubscriptionCustomFields', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/subscriptions/{subscriptionId}/customFields`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Un-cancel an entitlement
         * @param {string} subscriptionId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uncancelSubscriptionPlan: async (subscriptionId: string, xKillbillCreatedBy: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('uncancelSubscriptionPlan', 'subscriptionId', subscriptionId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('uncancelSubscriptionPlan', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/subscriptions/{subscriptionId}/uncancel`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Undo a pending change plan on an entitlement
         * @param {string} subscriptionId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        undoChangeSubscriptionPlan: async (subscriptionId: string, xKillbillCreatedBy: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('undoChangeSubscriptionPlan', 'subscriptionId', subscriptionId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('undoChangeSubscriptionPlan', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/subscriptions/{subscriptionId}/undoChangePlan`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the BCD associated to a subscription
         * @param {Subscription} body 
         * @param {string} subscriptionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [effectiveFromDate] 
         * @param {boolean} [forceNewBcdWithPastEffectiveDate] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubscriptionBCD: async (body: Subscription, subscriptionId: string, xKillbillCreatedBy: string, effectiveFromDate?: string, forceNewBcdWithPastEffectiveDate?: boolean, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateSubscriptionBCD', 'body', body)
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('updateSubscriptionBCD', 'subscriptionId', subscriptionId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('updateSubscriptionBCD', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/subscriptions/{subscriptionId}/bcd`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (effectiveFromDate !== undefined) {
                localVarQueryParameter['effectiveFromDate'] = (effectiveFromDate as any instanceof Date) ?
                    (effectiveFromDate as any).toISOString().substr(0,10) :
                    effectiveFromDate;
            }

            if (forceNewBcdWithPastEffectiveDate !== undefined) {
                localVarQueryParameter['forceNewBcdWithPastEffectiveDate'] = forceNewBcdWithPastEffectiveDate;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the quantity associated to a subscription
         * @param {Subscription} body 
         * @param {string} subscriptionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [effectiveFromDate] 
         * @param {boolean} [forceNewQuantityWithPastEffectiveDate] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubscriptionQuantity: async (body: Subscription, subscriptionId: string, xKillbillCreatedBy: string, effectiveFromDate?: string, forceNewQuantityWithPastEffectiveDate?: boolean, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateSubscriptionQuantity', 'body', body)
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('updateSubscriptionQuantity', 'subscriptionId', subscriptionId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('updateSubscriptionQuantity', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/subscriptions/{subscriptionId}/quantity`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (effectiveFromDate !== undefined) {
                localVarQueryParameter['effectiveFromDate'] = (effectiveFromDate as any instanceof Date) ?
                    (effectiveFromDate as any).toISOString().substr(0,10) :
                    effectiveFromDate;
            }

            if (forceNewQuantityWithPastEffectiveDate !== undefined) {
                localVarQueryParameter['forceNewQuantityWithPastEffectiveDate'] = forceNewQuantityWithPastEffectiveDate;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubscriptionApi - functional programming interface
 * @export
 */
export const SubscriptionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SubscriptionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Block a subscription
         * @param {BlockingState} body 
         * @param {string} subscriptionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [requestedDate] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addSubscriptionBlockingState(body: BlockingState, subscriptionId: string, xKillbillCreatedBy: string, requestedDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BlockingState>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addSubscriptionBlockingState(body, subscriptionId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Cancel an entitlement plan
         * @param {string} subscriptionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [requestedDate] 
         * @param {boolean} [callCompletion] 
         * @param {number} [callTimeoutSec] 
         * @param {'IMMEDIATE' | 'END_OF_TERM'} [entitlementPolicy] 
         * @param {'START_OF_TERM' | 'END_OF_TERM' | 'IMMEDIATE' | 'ILLEGAL'} [billingPolicy] 
         * @param {boolean} [useRequestedDateForBilling] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelSubscriptionPlan(subscriptionId: string, xKillbillCreatedBy: string, requestedDate?: string, callCompletion?: boolean, callTimeoutSec?: number, entitlementPolicy?: 'IMMEDIATE' | 'END_OF_TERM', billingPolicy?: 'START_OF_TERM' | 'END_OF_TERM' | 'IMMEDIATE' | 'ILLEGAL', useRequestedDateForBilling?: boolean, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelSubscriptionPlan(subscriptionId, xKillbillCreatedBy, requestedDate, callCompletion, callTimeoutSec, entitlementPolicy, billingPolicy, useRequestedDateForBilling, pluginProperty, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Change entitlement plan
         * @param {Subscription} body 
         * @param {string} subscriptionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [requestedDate] 
         * @param {boolean} [callCompletion] 
         * @param {number} [callTimeoutSec] 
         * @param {'START_OF_TERM' | 'END_OF_TERM' | 'IMMEDIATE' | 'ILLEGAL'} [billingPolicy] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeSubscriptionPlan(body: Subscription, subscriptionId: string, xKillbillCreatedBy: string, requestedDate?: string, callCompletion?: boolean, callTimeoutSec?: number, billingPolicy?: 'START_OF_TERM' | 'END_OF_TERM' | 'IMMEDIATE' | 'ILLEGAL', pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeSubscriptionPlan(body, subscriptionId, xKillbillCreatedBy, requestedDate, callCompletion, callTimeoutSec, billingPolicy, pluginProperty, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create an subscription
         * @param {Subscription} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [entitlementDate] 
         * @param {string} [billingDate] 
         * @param {boolean} [renameKeyIfExistsAndUnused] 
         * @param {boolean} [migrated] 
         * @param {boolean} [skipResponse] 
         * @param {boolean} [callCompletion] 
         * @param {number} [callTimeoutSec] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSubscription(body: Subscription, xKillbillCreatedBy: string, entitlementDate?: string, billingDate?: string, renameKeyIfExistsAndUnused?: boolean, migrated?: boolean, skipResponse?: boolean, callCompletion?: boolean, callTimeoutSec?: number, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscription>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSubscription(body, xKillbillCreatedBy, entitlementDate, billingDate, renameKeyIfExistsAndUnused, migrated, skipResponse, callCompletion, callTimeoutSec, pluginProperty, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add custom fields to subscription
         * @param {Array<CustomField>} body 
         * @param {string} subscriptionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSubscriptionCustomFields(body: Array<CustomField>, subscriptionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSubscriptionCustomFields(body, subscriptionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Array<string>} body 
         * @param {string} subscriptionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSubscriptionTags(body: Array<string>, subscriptionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSubscriptionTags(body, subscriptionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create an entitlement with addOn products
         * @param {Array<Subscription>} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [entitlementDate] 
         * @param {string} [billingDate] 
         * @param {boolean} [migrated] 
         * @param {boolean} [skipResponse] 
         * @param {boolean} [renameKeyIfExistsAndUnused] 
         * @param {boolean} [callCompletion] 
         * @param {number} [callTimeoutSec] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSubscriptionWithAddOns(body: Array<Subscription>, xKillbillCreatedBy: string, entitlementDate?: string, billingDate?: string, migrated?: boolean, skipResponse?: boolean, renameKeyIfExistsAndUnused?: boolean, callCompletion?: boolean, callTimeoutSec?: number, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Bundle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSubscriptionWithAddOns(body, xKillbillCreatedBy, entitlementDate, billingDate, migrated, skipResponse, renameKeyIfExistsAndUnused, callCompletion, callTimeoutSec, pluginProperty, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create multiple entitlements with addOn products
         * @param {Array<BulkSubscriptionsBundle>} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [entitlementDate] 
         * @param {string} [billingDate] 
         * @param {boolean} [renameKeyIfExistsAndUnused] 
         * @param {boolean} [migrated] 
         * @param {boolean} [skipResponse] 
         * @param {boolean} [callCompletion] 
         * @param {number} [callTimeoutSec] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSubscriptionsWithAddOns(body: Array<BulkSubscriptionsBundle>, xKillbillCreatedBy: string, entitlementDate?: string, billingDate?: string, renameKeyIfExistsAndUnused?: boolean, migrated?: boolean, skipResponse?: boolean, callCompletion?: boolean, callTimeoutSec?: number, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Bundle>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSubscriptionsWithAddOns(body, xKillbillCreatedBy, entitlementDate, billingDate, renameKeyIfExistsAndUnused, migrated, skipResponse, callCompletion, callTimeoutSec, pluginProperty, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove custom fields from subscription
         * @param {string} subscriptionId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [customField] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSubscriptionCustomFields(subscriptionId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSubscriptionCustomFields(subscriptionId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove tags from subscription
         * @param {string} subscriptionId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [tagDef] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSubscriptionTags(subscriptionId: string, xKillbillCreatedBy: string, tagDef?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSubscriptionTags(subscriptionId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a subscription by id
         * @param {string} subscriptionId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubscription(subscriptionId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscription>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubscription(subscriptionId, audit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve subscription audit logs with history by id
         * @param {string} subscriptionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubscriptionAuditLogsWithHistory(subscriptionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AuditLog>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubscriptionAuditLogsWithHistory(subscriptionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a subscription by external key
         * @param {string} externalKey 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubscriptionByKey(externalKey: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscription>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubscriptionByKey(externalKey, audit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve subscription custom fields
         * @param {string} subscriptionId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubscriptionCustomFields(subscriptionId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CustomField>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubscriptionCustomFields(subscriptionId, audit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve subscription event audit logs with history by id
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubscriptionEventAuditLogsWithHistory(eventId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AuditLog>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubscriptionEventAuditLogsWithHistory(eventId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve subscription tags
         * @param {string} subscriptionId 
         * @param {boolean} [includedDeleted] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubscriptionTags(subscriptionId: string, includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubscriptionTags(subscriptionId, includedDeleted, audit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Modify custom fields to subscription
         * @param {Array<CustomField>} body 
         * @param {string} subscriptionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifySubscriptionCustomFields(body: Array<CustomField>, subscriptionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifySubscriptionCustomFields(body, subscriptionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Un-cancel an entitlement
         * @param {string} subscriptionId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uncancelSubscriptionPlan(subscriptionId: string, xKillbillCreatedBy: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uncancelSubscriptionPlan(subscriptionId, xKillbillCreatedBy, pluginProperty, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Undo a pending change plan on an entitlement
         * @param {string} subscriptionId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async undoChangeSubscriptionPlan(subscriptionId: string, xKillbillCreatedBy: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.undoChangeSubscriptionPlan(subscriptionId, xKillbillCreatedBy, pluginProperty, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the BCD associated to a subscription
         * @param {Subscription} body 
         * @param {string} subscriptionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [effectiveFromDate] 
         * @param {boolean} [forceNewBcdWithPastEffectiveDate] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSubscriptionBCD(body: Subscription, subscriptionId: string, xKillbillCreatedBy: string, effectiveFromDate?: string, forceNewBcdWithPastEffectiveDate?: boolean, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSubscriptionBCD(body, subscriptionId, xKillbillCreatedBy, effectiveFromDate, forceNewBcdWithPastEffectiveDate, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the quantity associated to a subscription
         * @param {Subscription} body 
         * @param {string} subscriptionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [effectiveFromDate] 
         * @param {boolean} [forceNewQuantityWithPastEffectiveDate] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSubscriptionQuantity(body: Subscription, subscriptionId: string, xKillbillCreatedBy: string, effectiveFromDate?: string, forceNewQuantityWithPastEffectiveDate?: boolean, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSubscriptionQuantity(body, subscriptionId, xKillbillCreatedBy, effectiveFromDate, forceNewQuantityWithPastEffectiveDate, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SubscriptionApi - factory interface
 * @export
 */
export const SubscriptionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SubscriptionApiFp(configuration)
    return {
        /**
         * 
         * @summary Block a subscription
         * @param {BlockingState} body 
         * @param {string} subscriptionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [requestedDate] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSubscriptionBlockingState(body: BlockingState, subscriptionId: string, xKillbillCreatedBy: string, requestedDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Array<BlockingState>> {
            return localVarFp.addSubscriptionBlockingState(body, subscriptionId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Cancel an entitlement plan
         * @param {string} subscriptionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [requestedDate] 
         * @param {boolean} [callCompletion] 
         * @param {number} [callTimeoutSec] 
         * @param {'IMMEDIATE' | 'END_OF_TERM'} [entitlementPolicy] 
         * @param {'START_OF_TERM' | 'END_OF_TERM' | 'IMMEDIATE' | 'ILLEGAL'} [billingPolicy] 
         * @param {boolean} [useRequestedDateForBilling] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelSubscriptionPlan(subscriptionId: string, xKillbillCreatedBy: string, requestedDate?: string, callCompletion?: boolean, callTimeoutSec?: number, entitlementPolicy?: 'IMMEDIATE' | 'END_OF_TERM', billingPolicy?: 'START_OF_TERM' | 'END_OF_TERM' | 'IMMEDIATE' | 'ILLEGAL', useRequestedDateForBilling?: boolean, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.cancelSubscriptionPlan(subscriptionId, xKillbillCreatedBy, requestedDate, callCompletion, callTimeoutSec, entitlementPolicy, billingPolicy, useRequestedDateForBilling, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Change entitlement plan
         * @param {Subscription} body 
         * @param {string} subscriptionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [requestedDate] 
         * @param {boolean} [callCompletion] 
         * @param {number} [callTimeoutSec] 
         * @param {'START_OF_TERM' | 'END_OF_TERM' | 'IMMEDIATE' | 'ILLEGAL'} [billingPolicy] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeSubscriptionPlan(body: Subscription, subscriptionId: string, xKillbillCreatedBy: string, requestedDate?: string, callCompletion?: boolean, callTimeoutSec?: number, billingPolicy?: 'START_OF_TERM' | 'END_OF_TERM' | 'IMMEDIATE' | 'ILLEGAL', pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.changeSubscriptionPlan(body, subscriptionId, xKillbillCreatedBy, requestedDate, callCompletion, callTimeoutSec, billingPolicy, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create an subscription
         * @param {Subscription} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [entitlementDate] 
         * @param {string} [billingDate] 
         * @param {boolean} [renameKeyIfExistsAndUnused] 
         * @param {boolean} [migrated] 
         * @param {boolean} [skipResponse] 
         * @param {boolean} [callCompletion] 
         * @param {number} [callTimeoutSec] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscription(body: Subscription, xKillbillCreatedBy: string, entitlementDate?: string, billingDate?: string, renameKeyIfExistsAndUnused?: boolean, migrated?: boolean, skipResponse?: boolean, callCompletion?: boolean, callTimeoutSec?: number, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Subscription> {
            return localVarFp.createSubscription(body, xKillbillCreatedBy, entitlementDate, billingDate, renameKeyIfExistsAndUnused, migrated, skipResponse, callCompletion, callTimeoutSec, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add custom fields to subscription
         * @param {Array<CustomField>} body 
         * @param {string} subscriptionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscriptionCustomFields(body: Array<CustomField>, subscriptionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.createSubscriptionCustomFields(body, subscriptionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<string>} body 
         * @param {string} subscriptionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscriptionTags(body: Array<string>, subscriptionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.createSubscriptionTags(body, subscriptionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create an entitlement with addOn products
         * @param {Array<Subscription>} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [entitlementDate] 
         * @param {string} [billingDate] 
         * @param {boolean} [migrated] 
         * @param {boolean} [skipResponse] 
         * @param {boolean} [renameKeyIfExistsAndUnused] 
         * @param {boolean} [callCompletion] 
         * @param {number} [callTimeoutSec] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscriptionWithAddOns(body: Array<Subscription>, xKillbillCreatedBy: string, entitlementDate?: string, billingDate?: string, migrated?: boolean, skipResponse?: boolean, renameKeyIfExistsAndUnused?: boolean, callCompletion?: boolean, callTimeoutSec?: number, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Bundle> {
            return localVarFp.createSubscriptionWithAddOns(body, xKillbillCreatedBy, entitlementDate, billingDate, migrated, skipResponse, renameKeyIfExistsAndUnused, callCompletion, callTimeoutSec, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create multiple entitlements with addOn products
         * @param {Array<BulkSubscriptionsBundle>} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [entitlementDate] 
         * @param {string} [billingDate] 
         * @param {boolean} [renameKeyIfExistsAndUnused] 
         * @param {boolean} [migrated] 
         * @param {boolean} [skipResponse] 
         * @param {boolean} [callCompletion] 
         * @param {number} [callTimeoutSec] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscriptionsWithAddOns(body: Array<BulkSubscriptionsBundle>, xKillbillCreatedBy: string, entitlementDate?: string, billingDate?: string, renameKeyIfExistsAndUnused?: boolean, migrated?: boolean, skipResponse?: boolean, callCompletion?: boolean, callTimeoutSec?: number, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Array<Bundle>> {
            return localVarFp.createSubscriptionsWithAddOns(body, xKillbillCreatedBy, entitlementDate, billingDate, renameKeyIfExistsAndUnused, migrated, skipResponse, callCompletion, callTimeoutSec, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove custom fields from subscription
         * @param {string} subscriptionId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [customField] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubscriptionCustomFields(subscriptionId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSubscriptionCustomFields(subscriptionId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove tags from subscription
         * @param {string} subscriptionId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [tagDef] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubscriptionTags(subscriptionId: string, xKillbillCreatedBy: string, tagDef?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSubscriptionTags(subscriptionId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a subscription by id
         * @param {string} subscriptionId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscription(subscriptionId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Subscription> {
            return localVarFp.getSubscription(subscriptionId, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve subscription audit logs with history by id
         * @param {string} subscriptionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionAuditLogsWithHistory(subscriptionId: string, options?: any): AxiosPromise<Array<AuditLog>> {
            return localVarFp.getSubscriptionAuditLogsWithHistory(subscriptionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a subscription by external key
         * @param {string} externalKey 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionByKey(externalKey: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Subscription> {
            return localVarFp.getSubscriptionByKey(externalKey, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve subscription custom fields
         * @param {string} subscriptionId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionCustomFields(subscriptionId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<CustomField>> {
            return localVarFp.getSubscriptionCustomFields(subscriptionId, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve subscription event audit logs with history by id
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionEventAuditLogsWithHistory(eventId: string, options?: any): AxiosPromise<Array<AuditLog>> {
            return localVarFp.getSubscriptionEventAuditLogsWithHistory(eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve subscription tags
         * @param {string} subscriptionId 
         * @param {boolean} [includedDeleted] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionTags(subscriptionId: string, includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.getSubscriptionTags(subscriptionId, includedDeleted, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Modify custom fields to subscription
         * @param {Array<CustomField>} body 
         * @param {string} subscriptionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifySubscriptionCustomFields(body: Array<CustomField>, subscriptionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.modifySubscriptionCustomFields(body, subscriptionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Un-cancel an entitlement
         * @param {string} subscriptionId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uncancelSubscriptionPlan(subscriptionId: string, xKillbillCreatedBy: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.uncancelSubscriptionPlan(subscriptionId, xKillbillCreatedBy, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Undo a pending change plan on an entitlement
         * @param {string} subscriptionId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        undoChangeSubscriptionPlan(subscriptionId: string, xKillbillCreatedBy: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.undoChangeSubscriptionPlan(subscriptionId, xKillbillCreatedBy, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the BCD associated to a subscription
         * @param {Subscription} body 
         * @param {string} subscriptionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [effectiveFromDate] 
         * @param {boolean} [forceNewBcdWithPastEffectiveDate] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubscriptionBCD(body: Subscription, subscriptionId: string, xKillbillCreatedBy: string, effectiveFromDate?: string, forceNewBcdWithPastEffectiveDate?: boolean, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.updateSubscriptionBCD(body, subscriptionId, xKillbillCreatedBy, effectiveFromDate, forceNewBcdWithPastEffectiveDate, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the quantity associated to a subscription
         * @param {Subscription} body 
         * @param {string} subscriptionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [effectiveFromDate] 
         * @param {boolean} [forceNewQuantityWithPastEffectiveDate] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubscriptionQuantity(body: Subscription, subscriptionId: string, xKillbillCreatedBy: string, effectiveFromDate?: string, forceNewQuantityWithPastEffectiveDate?: boolean, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.updateSubscriptionQuantity(body, subscriptionId, xKillbillCreatedBy, effectiveFromDate, forceNewQuantityWithPastEffectiveDate, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SubscriptionApi - object-oriented interface
 * @export
 * @class SubscriptionApi
 * @extends {BaseAPI}
 */
export class SubscriptionApi extends BaseAPI {
    /**
     * 
     * @summary Block a subscription
     * @param {BlockingState} body 
     * @param {string} subscriptionId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [requestedDate] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public addSubscriptionBlockingState(body: BlockingState, subscriptionId: string, xKillbillCreatedBy: string, requestedDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).addSubscriptionBlockingState(body, subscriptionId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Cancel an entitlement plan
     * @param {string} subscriptionId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [requestedDate] 
     * @param {boolean} [callCompletion] 
     * @param {number} [callTimeoutSec] 
     * @param {'IMMEDIATE' | 'END_OF_TERM'} [entitlementPolicy] 
     * @param {'START_OF_TERM' | 'END_OF_TERM' | 'IMMEDIATE' | 'ILLEGAL'} [billingPolicy] 
     * @param {boolean} [useRequestedDateForBilling] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public cancelSubscriptionPlan(subscriptionId: string, xKillbillCreatedBy: string, requestedDate?: string, callCompletion?: boolean, callTimeoutSec?: number, entitlementPolicy?: 'IMMEDIATE' | 'END_OF_TERM', billingPolicy?: 'START_OF_TERM' | 'END_OF_TERM' | 'IMMEDIATE' | 'ILLEGAL', useRequestedDateForBilling?: boolean, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).cancelSubscriptionPlan(subscriptionId, xKillbillCreatedBy, requestedDate, callCompletion, callTimeoutSec, entitlementPolicy, billingPolicy, useRequestedDateForBilling, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Change entitlement plan
     * @param {Subscription} body 
     * @param {string} subscriptionId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [requestedDate] 
     * @param {boolean} [callCompletion] 
     * @param {number} [callTimeoutSec] 
     * @param {'START_OF_TERM' | 'END_OF_TERM' | 'IMMEDIATE' | 'ILLEGAL'} [billingPolicy] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public changeSubscriptionPlan(body: Subscription, subscriptionId: string, xKillbillCreatedBy: string, requestedDate?: string, callCompletion?: boolean, callTimeoutSec?: number, billingPolicy?: 'START_OF_TERM' | 'END_OF_TERM' | 'IMMEDIATE' | 'ILLEGAL', pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).changeSubscriptionPlan(body, subscriptionId, xKillbillCreatedBy, requestedDate, callCompletion, callTimeoutSec, billingPolicy, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create an subscription
     * @param {Subscription} body 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [entitlementDate] 
     * @param {string} [billingDate] 
     * @param {boolean} [renameKeyIfExistsAndUnused] 
     * @param {boolean} [migrated] 
     * @param {boolean} [skipResponse] 
     * @param {boolean} [callCompletion] 
     * @param {number} [callTimeoutSec] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public createSubscription(body: Subscription, xKillbillCreatedBy: string, entitlementDate?: string, billingDate?: string, renameKeyIfExistsAndUnused?: boolean, migrated?: boolean, skipResponse?: boolean, callCompletion?: boolean, callTimeoutSec?: number, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).createSubscription(body, xKillbillCreatedBy, entitlementDate, billingDate, renameKeyIfExistsAndUnused, migrated, skipResponse, callCompletion, callTimeoutSec, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add custom fields to subscription
     * @param {Array<CustomField>} body 
     * @param {string} subscriptionId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public createSubscriptionCustomFields(body: Array<CustomField>, subscriptionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).createSubscriptionCustomFields(body, subscriptionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<string>} body 
     * @param {string} subscriptionId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public createSubscriptionTags(body: Array<string>, subscriptionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).createSubscriptionTags(body, subscriptionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create an entitlement with addOn products
     * @param {Array<Subscription>} body 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [entitlementDate] 
     * @param {string} [billingDate] 
     * @param {boolean} [migrated] 
     * @param {boolean} [skipResponse] 
     * @param {boolean} [renameKeyIfExistsAndUnused] 
     * @param {boolean} [callCompletion] 
     * @param {number} [callTimeoutSec] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public createSubscriptionWithAddOns(body: Array<Subscription>, xKillbillCreatedBy: string, entitlementDate?: string, billingDate?: string, migrated?: boolean, skipResponse?: boolean, renameKeyIfExistsAndUnused?: boolean, callCompletion?: boolean, callTimeoutSec?: number, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).createSubscriptionWithAddOns(body, xKillbillCreatedBy, entitlementDate, billingDate, migrated, skipResponse, renameKeyIfExistsAndUnused, callCompletion, callTimeoutSec, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create multiple entitlements with addOn products
     * @param {Array<BulkSubscriptionsBundle>} body 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [entitlementDate] 
     * @param {string} [billingDate] 
     * @param {boolean} [renameKeyIfExistsAndUnused] 
     * @param {boolean} [migrated] 
     * @param {boolean} [skipResponse] 
     * @param {boolean} [callCompletion] 
     * @param {number} [callTimeoutSec] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public createSubscriptionsWithAddOns(body: Array<BulkSubscriptionsBundle>, xKillbillCreatedBy: string, entitlementDate?: string, billingDate?: string, renameKeyIfExistsAndUnused?: boolean, migrated?: boolean, skipResponse?: boolean, callCompletion?: boolean, callTimeoutSec?: number, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).createSubscriptionsWithAddOns(body, xKillbillCreatedBy, entitlementDate, billingDate, renameKeyIfExistsAndUnused, migrated, skipResponse, callCompletion, callTimeoutSec, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove custom fields from subscription
     * @param {string} subscriptionId 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [customField] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public deleteSubscriptionCustomFields(subscriptionId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).deleteSubscriptionCustomFields(subscriptionId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove tags from subscription
     * @param {string} subscriptionId 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [tagDef] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public deleteSubscriptionTags(subscriptionId: string, xKillbillCreatedBy: string, tagDef?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).deleteSubscriptionTags(subscriptionId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a subscription by id
     * @param {string} subscriptionId 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public getSubscription(subscriptionId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).getSubscription(subscriptionId, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve subscription audit logs with history by id
     * @param {string} subscriptionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public getSubscriptionAuditLogsWithHistory(subscriptionId: string, options?: AxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).getSubscriptionAuditLogsWithHistory(subscriptionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a subscription by external key
     * @param {string} externalKey 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public getSubscriptionByKey(externalKey: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).getSubscriptionByKey(externalKey, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve subscription custom fields
     * @param {string} subscriptionId 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public getSubscriptionCustomFields(subscriptionId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).getSubscriptionCustomFields(subscriptionId, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve subscription event audit logs with history by id
     * @param {string} eventId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public getSubscriptionEventAuditLogsWithHistory(eventId: string, options?: AxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).getSubscriptionEventAuditLogsWithHistory(eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve subscription tags
     * @param {string} subscriptionId 
     * @param {boolean} [includedDeleted] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public getSubscriptionTags(subscriptionId: string, includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).getSubscriptionTags(subscriptionId, includedDeleted, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Modify custom fields to subscription
     * @param {Array<CustomField>} body 
     * @param {string} subscriptionId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public modifySubscriptionCustomFields(body: Array<CustomField>, subscriptionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).modifySubscriptionCustomFields(body, subscriptionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Un-cancel an entitlement
     * @param {string} subscriptionId 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public uncancelSubscriptionPlan(subscriptionId: string, xKillbillCreatedBy: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).uncancelSubscriptionPlan(subscriptionId, xKillbillCreatedBy, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Undo a pending change plan on an entitlement
     * @param {string} subscriptionId 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public undoChangeSubscriptionPlan(subscriptionId: string, xKillbillCreatedBy: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).undoChangeSubscriptionPlan(subscriptionId, xKillbillCreatedBy, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the BCD associated to a subscription
     * @param {Subscription} body 
     * @param {string} subscriptionId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [effectiveFromDate] 
     * @param {boolean} [forceNewBcdWithPastEffectiveDate] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public updateSubscriptionBCD(body: Subscription, subscriptionId: string, xKillbillCreatedBy: string, effectiveFromDate?: string, forceNewBcdWithPastEffectiveDate?: boolean, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).updateSubscriptionBCD(body, subscriptionId, xKillbillCreatedBy, effectiveFromDate, forceNewBcdWithPastEffectiveDate, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the quantity associated to a subscription
     * @param {Subscription} body 
     * @param {string} subscriptionId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [effectiveFromDate] 
     * @param {boolean} [forceNewQuantityWithPastEffectiveDate] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public updateSubscriptionQuantity(body: Subscription, subscriptionId: string, xKillbillCreatedBy: string, effectiveFromDate?: string, forceNewQuantityWithPastEffectiveDate?: boolean, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).updateSubscriptionQuantity(body, subscriptionId, xKillbillCreatedBy, effectiveFromDate, forceNewQuantityWithPastEffectiveDate, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TagApi - axios parameter creator
 * @export
 */
export const TagApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve tag audit logs with history by id
         * @param {string} tagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagAuditLogsWithHistory: async (tagId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('getTagAuditLogsWithHistory', 'tagId', tagId)
            const localVarPath = `/1.0/kb/tags/{tagId}/auditLogsWithHistory`
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List tags
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTags: async (offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/1.0/kb/tags/pagination`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search tags
         * @param {string} searchKey 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTags: async (searchKey: string, offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchKey' is not null or undefined
            assertParamExists('searchTags', 'searchKey', searchKey)
            const localVarPath = `/1.0/kb/tags/search/{searchKey}`
                .replace(`{${"searchKey"}}`, encodeURIComponent(String(searchKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagApi - functional programming interface
 * @export
 */
export const TagApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TagApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Retrieve tag audit logs with history by id
         * @param {string} tagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTagAuditLogsWithHistory(tagId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AuditLog>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTagAuditLogsWithHistory(tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List tags
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTags(offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTags(offset, limit, audit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Search tags
         * @param {string} searchKey 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchTags(searchKey: string, offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchTags(searchKey, offset, limit, audit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TagApi - factory interface
 * @export
 */
export const TagApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TagApiFp(configuration)
    return {
        /**
         * 
         * @summary Retrieve tag audit logs with history by id
         * @param {string} tagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagAuditLogsWithHistory(tagId: string, options?: any): AxiosPromise<Array<AuditLog>> {
            return localVarFp.getTagAuditLogsWithHistory(tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List tags
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTags(offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.getTags(offset, limit, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search tags
         * @param {string} searchKey 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTags(searchKey: string, offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.searchTags(searchKey, offset, limit, audit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TagApi - object-oriented interface
 * @export
 * @class TagApi
 * @extends {BaseAPI}
 */
export class TagApi extends BaseAPI {
    /**
     * 
     * @summary Retrieve tag audit logs with history by id
     * @param {string} tagId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public getTagAuditLogsWithHistory(tagId: string, options?: AxiosRequestConfig) {
        return TagApiFp(this.configuration).getTagAuditLogsWithHistory(tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List tags
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public getTags(offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig) {
        return TagApiFp(this.configuration).getTags(offset, limit, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search tags
     * @param {string} searchKey 
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public searchTags(searchKey: string, offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig) {
        return TagApiFp(this.configuration).searchTags(searchKey, offset, limit, audit, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TagDefinitionApi - axios parameter creator
 * @export
 */
export const TagDefinitionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a tag definition
         * @param {TagDefinition} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTagDefinition: async (body: TagDefinition, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createTagDefinition', 'body', body)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('createTagDefinition', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/tagDefinitions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a tag definition
         * @param {string} tagDefinitionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTagDefinition: async (tagDefinitionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tagDefinitionId' is not null or undefined
            assertParamExists('deleteTagDefinition', 'tagDefinitionId', tagDefinitionId)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('deleteTagDefinition', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/tagDefinitions/{tagDefinitionId}`
                .replace(`{${"tagDefinitionId"}}`, encodeURIComponent(String(tagDefinitionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a tag definition
         * @param {string} tagDefinitionId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagDefinition: async (tagDefinitionId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tagDefinitionId' is not null or undefined
            assertParamExists('getTagDefinition', 'tagDefinitionId', tagDefinitionId)
            const localVarPath = `/1.0/kb/tagDefinitions/{tagDefinitionId}`
                .replace(`{${"tagDefinitionId"}}`, encodeURIComponent(String(tagDefinitionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve tag definition audit logs with history by id
         * @param {string} tagDefinitionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagDefinitionAuditLogsWithHistory: async (tagDefinitionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tagDefinitionId' is not null or undefined
            assertParamExists('getTagDefinitionAuditLogsWithHistory', 'tagDefinitionId', tagDefinitionId)
            const localVarPath = `/1.0/kb/tagDefinitions/{tagDefinitionId}/auditLogsWithHistory`
                .replace(`{${"tagDefinitionId"}}`, encodeURIComponent(String(tagDefinitionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List tag definitions
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagDefinitions: async (audit?: 'FULL' | 'MINIMAL' | 'NONE', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/1.0/kb/tagDefinitions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagDefinitionApi - functional programming interface
 * @export
 */
export const TagDefinitionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TagDefinitionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a tag definition
         * @param {TagDefinition} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTagDefinition(body: TagDefinition, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagDefinition>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTagDefinition(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a tag definition
         * @param {string} tagDefinitionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTagDefinition(tagDefinitionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTagDefinition(tagDefinitionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a tag definition
         * @param {string} tagDefinitionId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTagDefinition(tagDefinitionId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagDefinition>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTagDefinition(tagDefinitionId, audit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve tag definition audit logs with history by id
         * @param {string} tagDefinitionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTagDefinitionAuditLogsWithHistory(tagDefinitionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AuditLog>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTagDefinitionAuditLogsWithHistory(tagDefinitionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List tag definitions
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTagDefinitions(audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TagDefinition>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTagDefinitions(audit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TagDefinitionApi - factory interface
 * @export
 */
export const TagDefinitionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TagDefinitionApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a tag definition
         * @param {TagDefinition} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTagDefinition(body: TagDefinition, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<TagDefinition> {
            return localVarFp.createTagDefinition(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a tag definition
         * @param {string} tagDefinitionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTagDefinition(tagDefinitionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTagDefinition(tagDefinitionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a tag definition
         * @param {string} tagDefinitionId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagDefinition(tagDefinitionId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<TagDefinition> {
            return localVarFp.getTagDefinition(tagDefinitionId, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve tag definition audit logs with history by id
         * @param {string} tagDefinitionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagDefinitionAuditLogsWithHistory(tagDefinitionId: string, options?: any): AxiosPromise<Array<AuditLog>> {
            return localVarFp.getTagDefinitionAuditLogsWithHistory(tagDefinitionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List tag definitions
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagDefinitions(audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<TagDefinition>> {
            return localVarFp.getTagDefinitions(audit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TagDefinitionApi - object-oriented interface
 * @export
 * @class TagDefinitionApi
 * @extends {BaseAPI}
 */
export class TagDefinitionApi extends BaseAPI {
    /**
     * 
     * @summary Create a tag definition
     * @param {TagDefinition} body 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagDefinitionApi
     */
    public createTagDefinition(body: TagDefinition, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return TagDefinitionApiFp(this.configuration).createTagDefinition(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a tag definition
     * @param {string} tagDefinitionId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagDefinitionApi
     */
    public deleteTagDefinition(tagDefinitionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return TagDefinitionApiFp(this.configuration).deleteTagDefinition(tagDefinitionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a tag definition
     * @param {string} tagDefinitionId 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagDefinitionApi
     */
    public getTagDefinition(tagDefinitionId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig) {
        return TagDefinitionApiFp(this.configuration).getTagDefinition(tagDefinitionId, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve tag definition audit logs with history by id
     * @param {string} tagDefinitionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagDefinitionApi
     */
    public getTagDefinitionAuditLogsWithHistory(tagDefinitionId: string, options?: AxiosRequestConfig) {
        return TagDefinitionApiFp(this.configuration).getTagDefinitionAuditLogsWithHistory(tagDefinitionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List tag definitions
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagDefinitionApi
     */
    public getTagDefinitions(audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: AxiosRequestConfig) {
        return TagDefinitionApiFp(this.configuration).getTagDefinitions(audit, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TenantApi - axios parameter creator
 * @export
 */
export const TenantApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a tenant
         * @param {Tenant} body 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [useGlobalDefault] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTenant: async (body: Tenant, xKillbillCreatedBy: string, useGlobalDefault?: boolean, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createTenant', 'body', body)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('createTenant', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/tenants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (useGlobalDefault !== undefined) {
                localVarQueryParameter['useGlobalDefault'] = useGlobalDefault;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a per tenant configuration (system properties)
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePerTenantConfiguration: async (xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('deletePerTenantConfiguration', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/tenants/uploadPerTenantConfig`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a per tenant configuration for a plugin
         * @param {string} pluginName 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePluginConfiguration: async (pluginName: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pluginName' is not null or undefined
            assertParamExists('deletePluginConfiguration', 'pluginName', pluginName)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('deletePluginConfiguration', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/tenants/uploadPluginConfig/{pluginName}`
                .replace(`{${"pluginName"}}`, encodeURIComponent(String(pluginName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a per tenant payment state machine for a plugin
         * @param {string} pluginName 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePluginPaymentStateMachineConfig: async (pluginName: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pluginName' is not null or undefined
            assertParamExists('deletePluginPaymentStateMachineConfig', 'pluginName', pluginName)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('deletePluginPaymentStateMachineConfig', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/tenants/uploadPluginPaymentStateMachineConfig/{pluginName}`
                .replace(`{${"pluginName"}}`, encodeURIComponent(String(pluginName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a push notification
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePushNotificationCallbacks: async (xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('deletePushNotificationCallbacks', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/tenants/registerNotificationCallback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete  a per tenant user key/value
         * @param {string} keyName 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserKeyValue: async (keyName: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'keyName' is not null or undefined
            assertParamExists('deleteUserKeyValue', 'keyName', keyName)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('deleteUserKeyValue', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/tenants/userKeyValue/{keyName}`
                .replace(`{${"keyName"}}`, encodeURIComponent(String(keyName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a per tenant key value based on key prefix
         * @param {string} keyPrefix 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPluginConfiguration: async (keyPrefix: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'keyPrefix' is not null or undefined
            assertParamExists('getAllPluginConfiguration', 'keyPrefix', keyPrefix)
            const localVarPath = `/1.0/kb/tenants/uploadPerTenantConfig/{keyPrefix}/search`
                .replace(`{${"keyPrefix"}}`, encodeURIComponent(String(keyPrefix)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a per tenant configuration (system properties)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPerTenantConfiguration: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/1.0/kb/tenants/uploadPerTenantConfig`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a per tenant configuration for a plugin
         * @param {string} pluginName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPluginConfiguration: async (pluginName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pluginName' is not null or undefined
            assertParamExists('getPluginConfiguration', 'pluginName', pluginName)
            const localVarPath = `/1.0/kb/tenants/uploadPluginConfig/{pluginName}`
                .replace(`{${"pluginName"}}`, encodeURIComponent(String(pluginName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a per tenant payment state machine for a plugin
         * @param {string} pluginName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPluginPaymentStateMachineConfig: async (pluginName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pluginName' is not null or undefined
            assertParamExists('getPluginPaymentStateMachineConfig', 'pluginName', pluginName)
            const localVarPath = `/1.0/kb/tenants/uploadPluginPaymentStateMachineConfig/{pluginName}`
                .replace(`{${"pluginName"}}`, encodeURIComponent(String(pluginName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a push notification
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPushNotificationCallbacks: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/1.0/kb/tenants/registerNotificationCallback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a tenant by id
         * @param {string} tenantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenant: async (tenantId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('getTenant', 'tenantId', tenantId)
            const localVarPath = `/1.0/kb/tenants/{tenantId}`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a tenant by its API key
         * @param {string} [apiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantByApiKey: async (apiKey?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/1.0/kb/tenants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (apiKey !== undefined) {
                localVarQueryParameter['apiKey'] = apiKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a per tenant user key/value
         * @param {string} keyName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserKeyValue: async (keyName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'keyName' is not null or undefined
            assertParamExists('getUserKeyValue', 'keyName', keyName)
            const localVarPath = `/1.0/kb/tenants/userKeyValue/{keyName}`
                .replace(`{${"keyName"}}`, encodeURIComponent(String(keyName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a per tenant user key/value
         * @param {string} body 
         * @param {string} keyName 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertUserKeyValue: async (body: string, keyName: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('insertUserKeyValue', 'body', body)
            // verify required parameter 'keyName' is not null or undefined
            assertParamExists('insertUserKeyValue', 'keyName', keyName)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('insertUserKeyValue', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/tenants/userKeyValue/{keyName}`
                .replace(`{${"keyName"}}`, encodeURIComponent(String(keyName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'text/plain';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a push notification
         * @param {string} xKillbillCreatedBy 
         * @param {string} [cb] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerPushNotificationCallback: async (xKillbillCreatedBy: string, cb?: string, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('registerPushNotificationCallback', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/tenants/registerNotificationCallback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (cb !== undefined) {
                localVarQueryParameter['cb'] = cb;
            }

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a per tenant configuration (system properties)
         * @param {string} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPerTenantConfiguration: async (body: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('uploadPerTenantConfiguration', 'body', body)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('uploadPerTenantConfiguration', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/tenants/uploadPerTenantConfig`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'text/plain';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a per tenant configuration for a plugin
         * @param {string} body 
         * @param {string} pluginName 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPluginConfiguration: async (body: string, pluginName: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('uploadPluginConfiguration', 'body', body)
            // verify required parameter 'pluginName' is not null or undefined
            assertParamExists('uploadPluginConfiguration', 'pluginName', pluginName)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('uploadPluginConfiguration', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/tenants/uploadPluginConfig/{pluginName}`
                .replace(`{${"pluginName"}}`, encodeURIComponent(String(pluginName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'text/plain';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a per tenant payment state machine for a plugin
         * @param {string} body 
         * @param {string} pluginName 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPluginPaymentStateMachineConfig: async (body: string, pluginName: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('uploadPluginPaymentStateMachineConfig', 'body', body)
            // verify required parameter 'pluginName' is not null or undefined
            assertParamExists('uploadPluginPaymentStateMachineConfig', 'pluginName', pluginName)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('uploadPluginPaymentStateMachineConfig', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/tenants/uploadPluginPaymentStateMachineConfig/{pluginName}`
                .replace(`{${"pluginName"}}`, encodeURIComponent(String(pluginName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'text/plain';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TenantApi - functional programming interface
 * @export
 */
export const TenantApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TenantApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a tenant
         * @param {Tenant} body 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [useGlobalDefault] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTenant(body: Tenant, xKillbillCreatedBy: string, useGlobalDefault?: boolean, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tenant>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTenant(body, xKillbillCreatedBy, useGlobalDefault, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a per tenant configuration (system properties)
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePerTenantConfiguration(xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePerTenantConfiguration(xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a per tenant configuration for a plugin
         * @param {string} pluginName 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePluginConfiguration(pluginName: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePluginConfiguration(pluginName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a per tenant payment state machine for a plugin
         * @param {string} pluginName 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePluginPaymentStateMachineConfig(pluginName: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePluginPaymentStateMachineConfig(pluginName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a push notification
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePushNotificationCallbacks(xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePushNotificationCallbacks(xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete  a per tenant user key/value
         * @param {string} keyName 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserKeyValue(keyName: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserKeyValue(keyName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a per tenant key value based on key prefix
         * @param {string} keyPrefix 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllPluginConfiguration(keyPrefix: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TenantKeyValue>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllPluginConfiguration(keyPrefix, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a per tenant configuration (system properties)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPerTenantConfiguration(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TenantKeyValue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPerTenantConfiguration(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a per tenant configuration for a plugin
         * @param {string} pluginName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPluginConfiguration(pluginName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TenantKeyValue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPluginConfiguration(pluginName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a per tenant payment state machine for a plugin
         * @param {string} pluginName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPluginPaymentStateMachineConfig(pluginName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TenantKeyValue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPluginPaymentStateMachineConfig(pluginName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a push notification
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPushNotificationCallbacks(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TenantKeyValue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPushNotificationCallbacks(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a tenant by id
         * @param {string} tenantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTenant(tenantId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tenant>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTenant(tenantId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a tenant by its API key
         * @param {string} [apiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTenantByApiKey(apiKey?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tenant>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTenantByApiKey(apiKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a per tenant user key/value
         * @param {string} keyName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserKeyValue(keyName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TenantKeyValue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserKeyValue(keyName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add a per tenant user key/value
         * @param {string} body 
         * @param {string} keyName 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insertUserKeyValue(body: string, keyName: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TenantKeyValue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insertUserKeyValue(body, keyName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a push notification
         * @param {string} xKillbillCreatedBy 
         * @param {string} [cb] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerPushNotificationCallback(xKillbillCreatedBy: string, cb?: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TenantKeyValue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerPushNotificationCallback(xKillbillCreatedBy, cb, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add a per tenant configuration (system properties)
         * @param {string} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadPerTenantConfiguration(body: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TenantKeyValue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadPerTenantConfiguration(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add a per tenant configuration for a plugin
         * @param {string} body 
         * @param {string} pluginName 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadPluginConfiguration(body: string, pluginName: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TenantKeyValue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadPluginConfiguration(body, pluginName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add a per tenant payment state machine for a plugin
         * @param {string} body 
         * @param {string} pluginName 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadPluginPaymentStateMachineConfig(body: string, pluginName: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TenantKeyValue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadPluginPaymentStateMachineConfig(body, pluginName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TenantApi - factory interface
 * @export
 */
export const TenantApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TenantApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a tenant
         * @param {Tenant} body 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [useGlobalDefault] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTenant(body: Tenant, xKillbillCreatedBy: string, useGlobalDefault?: boolean, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Tenant> {
            return localVarFp.createTenant(body, xKillbillCreatedBy, useGlobalDefault, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a per tenant configuration (system properties)
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePerTenantConfiguration(xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePerTenantConfiguration(xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a per tenant configuration for a plugin
         * @param {string} pluginName 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePluginConfiguration(pluginName: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePluginConfiguration(pluginName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a per tenant payment state machine for a plugin
         * @param {string} pluginName 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePluginPaymentStateMachineConfig(pluginName: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePluginPaymentStateMachineConfig(pluginName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a push notification
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePushNotificationCallbacks(xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePushNotificationCallbacks(xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete  a per tenant user key/value
         * @param {string} keyName 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserKeyValue(keyName: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUserKeyValue(keyName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a per tenant key value based on key prefix
         * @param {string} keyPrefix 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPluginConfiguration(keyPrefix: string, options?: any): AxiosPromise<Array<TenantKeyValue>> {
            return localVarFp.getAllPluginConfiguration(keyPrefix, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a per tenant configuration (system properties)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPerTenantConfiguration(options?: any): AxiosPromise<TenantKeyValue> {
            return localVarFp.getPerTenantConfiguration(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a per tenant configuration for a plugin
         * @param {string} pluginName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPluginConfiguration(pluginName: string, options?: any): AxiosPromise<TenantKeyValue> {
            return localVarFp.getPluginConfiguration(pluginName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a per tenant payment state machine for a plugin
         * @param {string} pluginName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPluginPaymentStateMachineConfig(pluginName: string, options?: any): AxiosPromise<TenantKeyValue> {
            return localVarFp.getPluginPaymentStateMachineConfig(pluginName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a push notification
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPushNotificationCallbacks(options?: any): AxiosPromise<TenantKeyValue> {
            return localVarFp.getPushNotificationCallbacks(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a tenant by id
         * @param {string} tenantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenant(tenantId: string, options?: any): AxiosPromise<Tenant> {
            return localVarFp.getTenant(tenantId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a tenant by its API key
         * @param {string} [apiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantByApiKey(apiKey?: string, options?: any): AxiosPromise<Tenant> {
            return localVarFp.getTenantByApiKey(apiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a per tenant user key/value
         * @param {string} keyName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserKeyValue(keyName: string, options?: any): AxiosPromise<TenantKeyValue> {
            return localVarFp.getUserKeyValue(keyName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a per tenant user key/value
         * @param {string} body 
         * @param {string} keyName 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertUserKeyValue(body: string, keyName: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<TenantKeyValue> {
            return localVarFp.insertUserKeyValue(body, keyName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a push notification
         * @param {string} xKillbillCreatedBy 
         * @param {string} [cb] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerPushNotificationCallback(xKillbillCreatedBy: string, cb?: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<TenantKeyValue> {
            return localVarFp.registerPushNotificationCallback(xKillbillCreatedBy, cb, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a per tenant configuration (system properties)
         * @param {string} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPerTenantConfiguration(body: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<TenantKeyValue> {
            return localVarFp.uploadPerTenantConfiguration(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a per tenant configuration for a plugin
         * @param {string} body 
         * @param {string} pluginName 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPluginConfiguration(body: string, pluginName: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<TenantKeyValue> {
            return localVarFp.uploadPluginConfiguration(body, pluginName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a per tenant payment state machine for a plugin
         * @param {string} body 
         * @param {string} pluginName 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPluginPaymentStateMachineConfig(body: string, pluginName: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<TenantKeyValue> {
            return localVarFp.uploadPluginPaymentStateMachineConfig(body, pluginName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TenantApi - object-oriented interface
 * @export
 * @class TenantApi
 * @extends {BaseAPI}
 */
export class TenantApi extends BaseAPI {
    /**
     * 
     * @summary Create a tenant
     * @param {Tenant} body 
     * @param {string} xKillbillCreatedBy 
     * @param {boolean} [useGlobalDefault] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    public createTenant(body: Tenant, xKillbillCreatedBy: string, useGlobalDefault?: boolean, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return TenantApiFp(this.configuration).createTenant(body, xKillbillCreatedBy, useGlobalDefault, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a per tenant configuration (system properties)
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    public deletePerTenantConfiguration(xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return TenantApiFp(this.configuration).deletePerTenantConfiguration(xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a per tenant configuration for a plugin
     * @param {string} pluginName 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    public deletePluginConfiguration(pluginName: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return TenantApiFp(this.configuration).deletePluginConfiguration(pluginName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a per tenant payment state machine for a plugin
     * @param {string} pluginName 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    public deletePluginPaymentStateMachineConfig(pluginName: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return TenantApiFp(this.configuration).deletePluginPaymentStateMachineConfig(pluginName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a push notification
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    public deletePushNotificationCallbacks(xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return TenantApiFp(this.configuration).deletePushNotificationCallbacks(xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete  a per tenant user key/value
     * @param {string} keyName 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    public deleteUserKeyValue(keyName: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return TenantApiFp(this.configuration).deleteUserKeyValue(keyName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a per tenant key value based on key prefix
     * @param {string} keyPrefix 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    public getAllPluginConfiguration(keyPrefix: string, options?: AxiosRequestConfig) {
        return TenantApiFp(this.configuration).getAllPluginConfiguration(keyPrefix, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a per tenant configuration (system properties)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    public getPerTenantConfiguration(options?: AxiosRequestConfig) {
        return TenantApiFp(this.configuration).getPerTenantConfiguration(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a per tenant configuration for a plugin
     * @param {string} pluginName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    public getPluginConfiguration(pluginName: string, options?: AxiosRequestConfig) {
        return TenantApiFp(this.configuration).getPluginConfiguration(pluginName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a per tenant payment state machine for a plugin
     * @param {string} pluginName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    public getPluginPaymentStateMachineConfig(pluginName: string, options?: AxiosRequestConfig) {
        return TenantApiFp(this.configuration).getPluginPaymentStateMachineConfig(pluginName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a push notification
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    public getPushNotificationCallbacks(options?: AxiosRequestConfig) {
        return TenantApiFp(this.configuration).getPushNotificationCallbacks(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a tenant by id
     * @param {string} tenantId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    public getTenant(tenantId: string, options?: AxiosRequestConfig) {
        return TenantApiFp(this.configuration).getTenant(tenantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a tenant by its API key
     * @param {string} [apiKey] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    public getTenantByApiKey(apiKey?: string, options?: AxiosRequestConfig) {
        return TenantApiFp(this.configuration).getTenantByApiKey(apiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a per tenant user key/value
     * @param {string} keyName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    public getUserKeyValue(keyName: string, options?: AxiosRequestConfig) {
        return TenantApiFp(this.configuration).getUserKeyValue(keyName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a per tenant user key/value
     * @param {string} body 
     * @param {string} keyName 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    public insertUserKeyValue(body: string, keyName: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return TenantApiFp(this.configuration).insertUserKeyValue(body, keyName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a push notification
     * @param {string} xKillbillCreatedBy 
     * @param {string} [cb] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    public registerPushNotificationCallback(xKillbillCreatedBy: string, cb?: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return TenantApiFp(this.configuration).registerPushNotificationCallback(xKillbillCreatedBy, cb, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a per tenant configuration (system properties)
     * @param {string} body 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    public uploadPerTenantConfiguration(body: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return TenantApiFp(this.configuration).uploadPerTenantConfiguration(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a per tenant configuration for a plugin
     * @param {string} body 
     * @param {string} pluginName 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    public uploadPluginConfiguration(body: string, pluginName: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return TenantApiFp(this.configuration).uploadPluginConfiguration(body, pluginName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a per tenant payment state machine for a plugin
     * @param {string} body 
     * @param {string} pluginName 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    public uploadPluginPaymentStateMachineConfig(body: string, pluginName: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return TenantApiFp(this.configuration).uploadPluginPaymentStateMachineConfig(body, pluginName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsageApi - axios parameter creator
 * @export
 */
export const UsageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve usage for a subscription
         * @param {string} subscriptionId 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {Array<string>} [pluginProperty] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsage: async (subscriptionId: string, startDate?: string, endDate?: string, pluginProperty?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('getAllUsage', 'subscriptionId', subscriptionId)
            const localVarPath = `/1.0/kb/usages/{subscriptionId}`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString().substr(0,10) :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString().substr(0,10) :
                    endDate;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve usage for a subscription and unit type
         * @param {string} subscriptionId 
         * @param {string} unitType 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {Array<string>} [pluginProperty] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsage: async (subscriptionId: string, unitType: string, startDate?: string, endDate?: string, pluginProperty?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('getUsage', 'subscriptionId', subscriptionId)
            // verify required parameter 'unitType' is not null or undefined
            assertParamExists('getUsage', 'unitType', unitType)
            const localVarPath = `/1.0/kb/usages/{subscriptionId}/{unitType}`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)))
                .replace(`{${"unitType"}}`, encodeURIComponent(String(unitType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString().substr(0,10) :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString().substr(0,10) :
                    endDate;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Record usage for a subscription
         * @param {SubscriptionUsageRecord} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordUsage: async (body: SubscriptionUsageRecord, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('recordUsage', 'body', body)
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            assertParamExists('recordUsage', 'xKillbillCreatedBy', xKillbillCreatedBy)
            const localVarPath = `/1.0/kb/usages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiKey", configuration)

            // authentication Killbill Api Secret required
            await setApiKeyToObject(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration)

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsageApi - functional programming interface
 * @export
 */
export const UsageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsageApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Retrieve usage for a subscription
         * @param {string} subscriptionId 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {Array<string>} [pluginProperty] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllUsage(subscriptionId: string, startDate?: string, endDate?: string, pluginProperty?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RolledUpUsage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllUsage(subscriptionId, startDate, endDate, pluginProperty, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve usage for a subscription and unit type
         * @param {string} subscriptionId 
         * @param {string} unitType 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {Array<string>} [pluginProperty] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsage(subscriptionId: string, unitType: string, startDate?: string, endDate?: string, pluginProperty?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RolledUpUsage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsage(subscriptionId, unitType, startDate, endDate, pluginProperty, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Record usage for a subscription
         * @param {SubscriptionUsageRecord} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recordUsage(body: SubscriptionUsageRecord, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recordUsage(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsageApi - factory interface
 * @export
 */
export const UsageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsageApiFp(configuration)
    return {
        /**
         * 
         * @summary Retrieve usage for a subscription
         * @param {string} subscriptionId 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {Array<string>} [pluginProperty] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsage(subscriptionId: string, startDate?: string, endDate?: string, pluginProperty?: Array<string>, options?: any): AxiosPromise<RolledUpUsage> {
            return localVarFp.getAllUsage(subscriptionId, startDate, endDate, pluginProperty, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve usage for a subscription and unit type
         * @param {string} subscriptionId 
         * @param {string} unitType 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {Array<string>} [pluginProperty] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsage(subscriptionId: string, unitType: string, startDate?: string, endDate?: string, pluginProperty?: Array<string>, options?: any): AxiosPromise<RolledUpUsage> {
            return localVarFp.getUsage(subscriptionId, unitType, startDate, endDate, pluginProperty, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Record usage for a subscription
         * @param {SubscriptionUsageRecord} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordUsage(body: SubscriptionUsageRecord, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return localVarFp.recordUsage(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsageApi - object-oriented interface
 * @export
 * @class UsageApi
 * @extends {BaseAPI}
 */
export class UsageApi extends BaseAPI {
    /**
     * 
     * @summary Retrieve usage for a subscription
     * @param {string} subscriptionId 
     * @param {string} [startDate] 
     * @param {string} [endDate] 
     * @param {Array<string>} [pluginProperty] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageApi
     */
    public getAllUsage(subscriptionId: string, startDate?: string, endDate?: string, pluginProperty?: Array<string>, options?: AxiosRequestConfig) {
        return UsageApiFp(this.configuration).getAllUsage(subscriptionId, startDate, endDate, pluginProperty, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve usage for a subscription and unit type
     * @param {string} subscriptionId 
     * @param {string} unitType 
     * @param {string} [startDate] 
     * @param {string} [endDate] 
     * @param {Array<string>} [pluginProperty] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageApi
     */
    public getUsage(subscriptionId: string, unitType: string, startDate?: string, endDate?: string, pluginProperty?: Array<string>, options?: AxiosRequestConfig) {
        return UsageApiFp(this.configuration).getUsage(subscriptionId, unitType, startDate, endDate, pluginProperty, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Record usage for a subscription
     * @param {SubscriptionUsageRecord} body 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageApi
     */
    public recordUsage(body: SubscriptionUsageRecord, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: AxiosRequestConfig) {
        return UsageApiFp(this.configuration).recordUsage(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
}


